/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@branch-ts/core/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@branch-ts/core/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CriteriaBuilder = exports.TemplateBuilder = exports.Criteria = exports.Errors = exports.Const = void 0;
///<reference path="./src/types.d.ts"/>
///<reference path="./src/gen/types.descriptor.d.ts"/>
__exportStar(__webpack_require__(/*! ./src/typeSystem */ "./node_modules/@branch-ts/core/src/typeSystem.js"), exports);
const Const = __importStar(__webpack_require__(/*! ./src/const */ "./node_modules/@branch-ts/core/src/const.js"));
exports.Const = Const;
var errors_1 = __webpack_require__(/*! ./src/errors */ "./node_modules/@branch-ts/core/src/errors.js");
Object.defineProperty(exports, "Errors", ({ enumerable: true, get: function () { return errors_1.Errors; } }));
__exportStar(__webpack_require__(/*! ./src/codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js"), exports);
__exportStar(__webpack_require__(/*! ./src/codex/codex */ "./node_modules/@branch-ts/core/src/codex/codex.js"), exports);
__exportStar(__webpack_require__(/*! ./src/annotation */ "./node_modules/@branch-ts/core/src/annotation.js"), exports);
__exportStar(__webpack_require__(/*! ./src/group */ "./node_modules/@branch-ts/core/src/group.js"), exports);
__exportStar(__webpack_require__(/*! ./src/model */ "./node_modules/@branch-ts/core/src/model.js"), exports);
__exportStar(__webpack_require__(/*! ./src/context */ "./node_modules/@branch-ts/core/src/context.js"), exports);
__exportStar(__webpack_require__(/*! ./src/keeper */ "./node_modules/@branch-ts/core/src/keeper.js"), exports);
__exportStar(__webpack_require__(/*! ./src/repository */ "./node_modules/@branch-ts/core/src/repository.js"), exports);
__exportStar(__webpack_require__(/*! ./src/application */ "./node_modules/@branch-ts/core/src/application.js"), exports);
__exportStar(__webpack_require__(/*! ./src/domain */ "./node_modules/@branch-ts/core/src/domain.js"), exports);
__exportStar(__webpack_require__(/*! ./src/access */ "./node_modules/@branch-ts/core/src/access.js"), exports);
__exportStar(__webpack_require__(/*! ./src/hook */ "./node_modules/@branch-ts/core/src/hook.js"), exports);
__exportStar(__webpack_require__(/*! ./src/document */ "./node_modules/@branch-ts/core/src/document.js"), exports);
__exportStar(__webpack_require__(/*! ./src/namespace */ "./node_modules/@branch-ts/core/src/namespace.js"), exports);
__exportStar(__webpack_require__(/*! ./src/util */ "./node_modules/@branch-ts/core/src/util.js"), exports);
__exportStar(__webpack_require__(/*! ./src/i18n */ "./node_modules/@branch-ts/core/src/i18n.js"), exports);
__exportStar(__webpack_require__(/*! ./src/codex/valueNode */ "./node_modules/@branch-ts/core/src/codex/valueNode.js"), exports);
__exportStar(__webpack_require__(/*! ./src/log */ "./node_modules/@branch-ts/core/src/log.js"), exports);
__exportStar(__webpack_require__(/*! ./src/config */ "./node_modules/@branch-ts/core/src/config.js"), exports);
__exportStar(__webpack_require__(/*! ./src/typeSystem */ "./node_modules/@branch-ts/core/src/typeSystem.js"), exports);
__exportStar(__webpack_require__(/*! ./src/procedure/procedure */ "./node_modules/@branch-ts/core/src/procedure/procedure.js"), exports);
__exportStar(__webpack_require__(/*! ./src/migration */ "./node_modules/@branch-ts/core/src/migration.js"), exports);
__exportStar(__webpack_require__(/*! ./src/mechanism */ "./node_modules/@branch-ts/core/src/mechanism.js"), exports);
__exportStar(__webpack_require__(/*! ./src/behavior */ "./node_modules/@branch-ts/core/src/behavior.js"), exports);
var criteria_1 = __webpack_require__(/*! @root-ts/criteria */ "./node_modules/@root-ts/criteria/index.js");
Object.defineProperty(exports, "Criteria", ({ enumerable: true, get: function () { return criteria_1.Criteria; } }));
Object.defineProperty(exports, "TemplateBuilder", ({ enumerable: true, get: function () { return criteria_1.TemplateBuilder; } }));
Object.defineProperty(exports, "CriteriaBuilder", ({ enumerable: true, get: function () { return criteria_1.CriteriaBuilder; } }));
const codex_1 = __webpack_require__(/*! ./src/codex/codex */ "./node_modules/@branch-ts/core/src/codex/codex.js");
const design_1 = __webpack_require__(/*! ./src/design/design */ "./node_modules/@branch-ts/core/src/design/design.js");
codex_1.Codex.current.register(design_1.DefaultDesign);
__exportStar(__webpack_require__(/*! ./src/design/design */ "./node_modules/@branch-ts/core/src/design/design.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/access.js":
/*!****************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/access.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _AccessControl_accesses, _Access_instances, _Access_possibleActions, _Access_getPossibleActions;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemAccess = exports.OwnerAccess = exports.Access = exports.AccessControl = void 0;
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
const group_1 = __webpack_require__(/*! ./group */ "./node_modules/@branch-ts/core/src/group.js");
const log_1 = __webpack_require__(/*! ./log */ "./node_modules/@branch-ts/core/src/log.js");
class AccessControl {
    constructor(domain) {
        this.domain = domain;
        _AccessControl_accesses.set(this, void 0);
    }
    isSystem(session) {
        return session && session.type == "system" && session.role == "system";
    }
    get accesses() {
        if (!__classPrivateFieldGet(this, _AccessControl_accesses, "f")) {
            __classPrivateFieldSet(this, _AccessControl_accesses, this.domain.findAspects("access").map(dec => new dec.cons), "f");
        }
        return __classPrivateFieldGet(this, _AccessControl_accesses, "f").slice();
    }
    // Choose a valid access descriptors, if none found, access denied
    getAccessCandidates(option) {
        return __awaiter(this, void 0, void 0, function* () {
            // pick basics
            let session = option.session;
            let accesses = option.accesses || this.accesses;
            let model = this.domain.blueprint.getAspect("model", option.request.modelUniqueName);
            if (!model) {
                throw new errors_1.Errors.NotFound(`Model definition ${option.request.modelUniqueName} not found`);
            }
            if (model.policy == "root" && session.role !== "root")
                return [];
            let group = this.domain.blueprint.getAspect("group", [option.request.modelUniqueName, option.request.groupName].join("."));
            const groupDisables = group.disables || [];
            const actions = Object.keys(option.request.action);
            let allActionsSupportedByGroup = actions.every(
            // Every requesting action
            (type) => 
            // Is not part of ANY groupDisables
            !groupDisables.some(kind => 
            // Test the group disable kind has the action type
            group_1.Group.actionKind[kind].includes(type)));
            if (!allActionsSupportedByGroup)
                return [];
            accesses = accesses.filter(acc => {
                // acc type match environment session type
                if (acc.type && session.type !== acc.type) {
                    return false;
                }
                // acc roles restriction exists, should match
                if (acc.roles && acc.roles.length > 0) {
                    if (!acc.roles.includes(session.role)) {
                        return false;
                    }
                }
                // Every action should be supported by access
                if (!actions.every(type => acc.possibleActions.includes(type)))
                    return false;
                // no model specified so all ok
                if (!acc.models || acc.models.length == 0)
                    return true;
                // match model specification
                if (acc.models.indexOf(model.uniqueName) >= 0)
                    return true;
                // match model specification by short name
                if (acc.models.indexOf(model.name) >= 0)
                    return true;
            });
            const candidates = yield Promise.all(accesses.map((acc) => __awaiter(this, void 0, void 0, function* () {
                if (!acc.access)
                    return;
                try {
                    yield acc.access({
                        request: option.request,
                        session: option.session,
                        domain: this.domain,
                    });
                    return acc;
                }
                catch (e) {
                    log_1.Logger.error(e);
                    return null;
                }
            })));
            return candidates.filter(item => !!item);
        });
    }
    access(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const candidates = (yield this.getAccessCandidates(option)).sort((a, b) => b.priority - a.priority);
            if (candidates.length == 0) {
                throw new errors_1.Errors.Forbidden();
            }
            const access = candidates[0];
            return access;
        });
    }
}
exports.AccessControl = AccessControl;
_AccessControl_accesses = new WeakMap();
class Access {
    constructor() {
        _Access_instances.add(this);
        this.roles = ["root"];
        this.priority = 0;
        this.userIdRestriction = false;
        _Access_possibleActions.set(this, void 0);
    }
    /* c8 ignore start */
    access(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return null;
        });
    }
    get possibleActions() {
        if (__classPrivateFieldGet(this, _Access_possibleActions, "f"))
            return __classPrivateFieldGet(this, _Access_possibleActions, "f");
        __classPrivateFieldSet(this, _Access_possibleActions, __classPrivateFieldGet(this, _Access_instances, "m", _Access_getPossibleActions).call(this), "f");
        return __classPrivateFieldGet(this, _Access_possibleActions, "f");
    }
}
exports.Access = Access;
_Access_possibleActions = new WeakMap(), _Access_instances = new WeakSet(), _Access_getPossibleActions = function _Access_getPossibleActions() {
    let allowedActions = group_1.Group.actions.slice();
    // whitelist first
    if (this.acceptedActions && this.acceptedActions.length > 0) {
        allowedActions = allowedActions.filter(action => {
            if (this.acceptedActions.indexOf(action) >= 0) {
                return true;
            }
            return false;
        });
    }
    else if (this.deniedActions && this.deniedActions.length > 0) {
        allowedActions = allowedActions.filter(action => {
            if (this.deniedActions.indexOf(action) >= 0) {
                return false;
            }
            return true;
        });
    }
    else if (this.allows && this.allows.length > 0) {
        allowedActions = allowedActions.filter(action => {
            for (let kind of this.allows) {
                if (group_1.Group.actionKind[kind] && group_1.Group.actionKind[kind].indexOf(action) >= 0) {
                    return true;
                }
            }
            return false;
        });
    }
    else if (this.denies && this.denies.length > 0) {
        allowedActions = allowedActions.filter(action => {
            for (let kind of this.denies) {
                if (group_1.Group.actionKind[kind] && group_1.Group.actionKind[kind].indexOf(action) >= 0) {
                    return false;
                }
            }
            return true;
        });
    }
    return allowedActions;
};
class OwnerAccess extends Access {
    access(option) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const userId = (_a = option.request.restriction) === null || _a === void 0 ? void 0 : _a["userId"];
            if (!userId || userId !== option.session.userId) {
                throw new errors_1.Errors.Forbidden("You are not the owner of this resource");
            }
        });
    }
}
exports.OwnerAccess = OwnerAccess;
exports.SystemAccess = new class extends Access {
    constructor() {
        super(...arguments);
        this.type = "system";
        this.roles = ["system"];
        this.priority = 1;
    }
};
//# sourceMappingURL=access.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/annotation.js":
/*!********************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/annotation.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
var __filename = "/index.js";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _AnnotationContext_isSealed;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnnotationContext = exports.Annotation = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const codex_1 = __webpack_require__(/*! ./codex/codex */ "./node_modules/@branch-ts/core/src/codex/codex.js");
const pathModule = __importStar(__webpack_require__(/*! path */ "./node_modules/path/path.js"));
const Const = __importStar(__webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/const.js"));
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
const util_1 = __webpack_require__(/*! ./util */ "./node_modules/@branch-ts/core/src/util.js");
const log_1 = __webpack_require__(/*! ./log */ "./node_modules/@branch-ts/core/src/log.js");
var Annotation;
(function (Annotation) {
    Annotation.version = "1";
    Annotation.errorLevel = 2;
    Annotation.allowAmbientNamespace = false;
    function namespace(namespace) {
        if (Annotation.allowAmbientNamespace) {
            AnnotationContext.current.ambientNamespace = namespace;
        }
        else {
            AnnotationContext.current.ambientNamespace = Const.DefaultNamespace;
        }
    }
    Annotation.namespace = namespace;
    function decorator(definition) {
        if (!definition)
            throw new errors_1.Errors.LogicError(`Aspect definition missing`);
        if (AnnotationContext.current.version !== Annotation.version) {
            log_1.Logger.error(`Decorator code version ${Annotation.version} miss match with AnnotationContextVersion ${AnnotationContext.current.version}, possibly multiple incompatible version of @branch-ts/core included`);
        }
        const fn = function (option) {
            let order = AnnotationContext.current.nextOrder();
            if ((typeof option !== "object" || Array.isArray(option)) && definition.fastOption) {
                option = {
                    [definition.fastOption]: option
                };
            }
            return (target, context) => {
                var _a;
                const annotation = AnnotationContext.current;
                if (annotation.isSealed) {
                    throw new errors_1.Errors.DesignError("Can't add acknowledgement after annotation is sealed");
                }
                const runtime = {
                    definition: definition,
                    ambientNamespace: annotation.ambientNamespace,
                    name: context.name.toString(),
                    uniqueName: null,
                    inputs: option,
                    value: target,
                    kind: context.kind,
                    order,
                };
                if (annotation.debug || annotation.mode == "compile") {
                    runtime.src = annotation.getCurrentSourceLocation();
                }
                if (annotation.mode == "compile") {
                    runtime.fileBoundId = annotation.getCurrentFileBoundId();
                    annotation.annotatedFileBoundIds.add(runtime.fileBoundId);
                }
                if (!definition.parents) {
                    if (definition.style == "class") {
                        runtime.instance = new target();
                    }
                    if (((_a = definition.subClassOf) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                        if (definition.subClassOf.every(Cons => {
                            return !util_1.Util.isConstructorOfBase(target, Cons);
                        })) {
                            throw new errors_1.Errors.DesignError(`${runtime.src} should extends <${definition.subClassOf.map(Cons => Cons.name).join("|")}>`);
                        }
                    }
                    annotation.closeRuntimeAcknowledgementBy(runtime);
                }
                else {
                    annotation.pendingRuntimeAcknowledgements.push(runtime);
                }
                if (definition.decorateToNewValue) {
                    return definition.decorateToNewValue(target, context, runtime);
                }
            };
        };
        // https://dev.to/tmikeschu/dynamically-assigning-a-function-name-in-javascript-2d70
        // Using the tricks to set function name properly
        const { [definition.name]: result } = { [definition.name]: fn };
        return result;
    }
    Annotation.decorator = decorator;
})(Annotation || (exports.Annotation = Annotation = {}));
const lastFileName = Leaf.ensureGlobal("LastAnnotationIncludeFileName", () => {
    return __filename;
});
class AnnotationContext {
    static change(context = new AnnotationContext) {
        AnnotationContext.current = context;
    }
    static get current() {
        return CurrentAnnotationContext;
    }
    static set current(context) {
        CurrentAnnotationContext = context;
    }
    nextOrder() {
        return this.order++;
    }
    resetOrder() {
        return this.order = 0;
    }
    constructor(codex = codex_1.CurrentCodex) {
        this.codex = codex;
        this.version = Annotation.version;
        this.order = 0;
        this.annotatedFileBoundIds = new Set();
        _AnnotationContext_isSealed.set(this, false);
        this.mode = "compile";
        this.debug = false;
        this.pendingRuntimeAcknowledgements = [];
        this.runtimeAcknowledgements = [];
        this.ambientNamespace = Const.DefaultNamespace;
    }
    getRuntimeAcknowledgementsByFileboundId(fileBoundId) {
        return this.runtimeAcknowledgements.filter(item => item.fileBoundId == fileBoundId);
    }
    removeRuntimeAcknowledgementsByFileboundId(fileBoundId) {
        this.runtimeAcknowledgements = this.runtimeAcknowledgements.filter(item => item.fileBoundId != fileBoundId);
    }
    getCurrentSourceLocation(level = Annotation.errorLevel) {
        const error = new Error();
        let lines = error.stack.split("\n");
        let begin = this.getFirstErrorAt(lines);
        let line = lines.slice(begin)[level];
        if (!line)
            return "Not found";
        const start = line.indexOf("(");
        const end = line.lastIndexOf(")");
        line = line.slice(start + 1, end);
        return line;
    }
    getCurrentFileBoundId(level = 2) {
        const error = new Error();
        let lines = error.stack.split("\n");
        let begin = this.getFirstErrorAt(lines);
        let line = lines.slice(begin)[level];
        if (!line)
            return "Not found";
        const start = line.indexOf("(");
        const end = line.lastIndexOf(")");
        line = line.slice(start + 1, end);
        let filename = line.split(":").slice(0, -2).join(":");
        const dir = pathModule.dirname(filename);
        const ext = pathModule.extname(filename);
        const base = pathModule.basename(filename, ext);
        const currentLearningFileBoundId = pathModule.join(dir, base);
        return currentLearningFileBoundId;
    }
    getFirstErrorAt(lines) {
        return lines.findIndex(line => line.startsWith("    at "));
    }
    get isSealed() {
        return __classPrivateFieldGet(this, _AnnotationContext_isSealed, "f");
    }
    set isSealed(value) {
        if (!value) {
            throw new errors_1.Errors.DesignError("Can't reverse sealed mode");
        }
        __classPrivateFieldSet(this, _AnnotationContext_isSealed, true, "f");
    }
    seal() {
        if (this.isSealed)
            return;
        if (this.pendingRuntimeAcknowledgements.length > 0) {
            throw new errors_1.Errors.DesignError(`Pending runtime acknowledgements not closed:
 ${this.pendingRuntimeAcknowledgements.map(item => item.src).join("\n")}`);
        }
        this.isSealed = true;
    }
    closeRuntimeAcknowledgementBy(parentAcknowledgement) {
        var _a;
        if (this.isSealed) {
            throw new errors_1.Errors.DesignError("Can't add acknowledgement after annotation is sealed");
        }
        const namespace = ((_a = parentAcknowledgement.inputs) === null || _a === void 0 ? void 0 : _a.namespace) || parentAcknowledgement.ambientNamespace;
        if (parentAcknowledgement.definition.makeUniqueName) {
            parentAcknowledgement.uniqueName = parentAcknowledgement.definition.makeUniqueName(parentAcknowledgement);
        }
        else {
            parentAcknowledgement.uniqueName = namespace + "." + parentAcknowledgement.name;
        }
        if (this.mode == "compile") {
            parentAcknowledgement.fileBoundTargetPath = parentAcknowledgement.name;
            parentAcknowledgement.fileBoundFullTargetPath = [parentAcknowledgement.fileBoundId, parentAcknowledgement.fileBoundTargetPath].join("::");
        }
        this.runtimeAcknowledgements.push(parentAcknowledgement);
        for (let runtime of this.pendingRuntimeAcknowledgements) {
            if (!runtime.definition.parents.includes(parentAcknowledgement.definition.name)) {
                throw new errors_1.Errors.DesignError(`Aspect ${runtime.definition.name} should be class member of ${runtime.definition.parents} but is under ${parentAcknowledgement.definition.name}`);
            }
            runtime.parentAcknowledgement = parentAcknowledgement;
            runtime.uniqueName = parentAcknowledgement.uniqueName + "." + runtime.name;
            this.runtimeAcknowledgements.push(runtime);
            if (this.mode == "compile") {
                runtime.fileBoundTargetPath = [parentAcknowledgement.name, runtime.name].join(".");
                runtime.fileBoundFullTargetPath = [parentAcknowledgement.fileBoundFullTargetPath, runtime.name].join(".");
            }
        }
        this.pendingRuntimeAcknowledgements.length = 0;
    }
}
exports.AnnotationContext = AnnotationContext;
_AnnotationContext_isSealed = new WeakMap();
let CurrentAnnotationContext = Leaf.ensureGlobal("BranchTsAnnotationContext", () => new AnnotationContext());
//# sourceMappingURL=annotation.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/application.js":
/*!*********************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/application.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ApplicationInformation_isDebug, _ApplicationInformation_name, _ApplicationInformation_releaseDir, _ApplicationInformation_releaseCodeDir, _ApplicationInformation_runDir, _ApplicationInformation_runtimeDir, _ApplicationInformation_tempDir, _ApplicationInformation_infos;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SubApplicationInformation = exports.AppInfo = exports.Application = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const blueprint_1 = __webpack_require__(/*! ./codex/blueprint */ "./node_modules/@branch-ts/core/src/codex/blueprint.js");
const builder_1 = __webpack_require__(/*! ./codex/builder */ "./node_modules/@branch-ts/core/src/codex/builder.js");
const domain_1 = __webpack_require__(/*! ./domain */ "./node_modules/@branch-ts/core/src/domain.js");
const log_1 = __webpack_require__(/*! ./log */ "./node_modules/@branch-ts/core/src/log.js");
const pathModule = __importStar(__webpack_require__(/*! path */ "./node_modules/path/path.js"));
class Application {
    constructor(option) {
        this.option = option;
        this.ready = new Leaf.ReadyBehavior();
        if (!option) {
            return;
        }
        this.initializeDomain();
    }
    get material() {
        var _a;
        return (_a = this.domain) === null || _a === void 0 ? void 0 : _a.blueprint.material;
    }
    initializeDomain() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.initializeDomainByMaterial(this.option);
            this.domain.asMain();
            yield this.domain.setup(this.option);
            this.ready.yes();
        });
    }
    initializeDomainByMaterial(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const builder = new builder_1.BlueprintBuilder({
                codex: option.codex,
                annotation: option.annotation,
                material: option.material,
            });
            builder.annotation.seal();
            const context = yield builder.build();
            const material = context.getMaterial();
            const blueprint = new blueprint_1.Blueprint(material, option.codex);
            this.domain = new domain_1.Domain(blueprint, material.name);
            if (option.debug) {
                this.domain.isDebug = true;
            }
        });
    }
    createDomainFromMaterial(option) {
        return __awaiter(this, void 0, void 0, function* () {
            log_1.Logger.warn(`Using legacy createDomainFromMaterial method of Application, please use constructor paramter instead`);
            if (this.option) {
                yield this.ready.wait();
                return this.domain;
            }
            else {
                this.option = { material: option.material };
                yield this.initializeDomainByMaterial(this.option);
                this.domain.asMain();
                return this.domain;
            }
        });
    }
}
exports.Application = Application;
// ipr1008 for now.
class ApplicationInformation {
    constructor() {
        _ApplicationInformation_isDebug.set(this, null);
        _ApplicationInformation_name.set(this, void 0);
        _ApplicationInformation_releaseDir.set(this, void 0);
        _ApplicationInformation_releaseCodeDir.set(this, void 0);
        _ApplicationInformation_runDir.set(this, void 0);
        _ApplicationInformation_runtimeDir.set(this, void 0);
        _ApplicationInformation_tempDir.set(this, void 0);
        _ApplicationInformation_infos.set(this, {});
    }
    get tempDir() {
        return __classPrivateFieldGet(this, _ApplicationInformation_tempDir, "f") || pathModule.join(this.runDir, "temp");
    }
    set tempDir(dir) {
        __classPrivateFieldSet(this, _ApplicationInformation_tempDir, dir, "f");
    }
    set runDir(v) {
        __classPrivateFieldSet(this, _ApplicationInformation_runDir, v, "f");
    }
    get runDir() {
        return __classPrivateFieldGet(this, _ApplicationInformation_runDir, "f") || (process === null || process === void 0 ? void 0 : process.cwd()) || "";
    }
    get runtimeDir() {
        return __classPrivateFieldGet(this, _ApplicationInformation_runtimeDir, "f") || pathModule.join(this.runDir, "runtime");
    }
    set runtimeDir(v) {
        __classPrivateFieldSet(this, _ApplicationInformation_runtimeDir, v, "f");
    }
    get name() {
        return __classPrivateFieldGet(this, _ApplicationInformation_name, "f") || pathModule.basename(this.runDir);
    }
    set name(v) {
        __classPrivateFieldSet(this, _ApplicationInformation_name, v, "f");
    }
    get releaseDir() {
        return __classPrivateFieldGet(this, _ApplicationInformation_releaseDir, "f") || this.runDir;
    }
    get releaseCodeDir() {
        return __classPrivateFieldGet(this, _ApplicationInformation_releaseCodeDir, "f") || pathModule.join(this.releaseDir, "code");
    }
    get dataDir() {
        return pathModule.join(this.runDir, "data");
    }
    set isDebug(v) {
        __classPrivateFieldSet(this, _ApplicationInformation_isDebug, !!v, "f");
    }
    get isDebug() {
        if (typeof __classPrivateFieldGet(this, _ApplicationInformation_isDebug, "f") == "boolean")
            return __classPrivateFieldGet(this, _ApplicationInformation_isDebug, "f");
        let isDebug = !!(process === null || process === void 0 ? void 0 : process.env["DEBUG"]);
        return isDebug;
    }
    get(key) {
        return __classPrivateFieldGet(this, _ApplicationInformation_infos, "f")[key];
    }
    set(key, value) {
        __classPrivateFieldGet(this, _ApplicationInformation_infos, "f")[key] = value;
        return this;
    }
    defaults(info = {}) {
        for (let key of Object.keys(info)) {
            this.set(key, info[key]);
        }
        return this;
    }
}
_ApplicationInformation_isDebug = new WeakMap(), _ApplicationInformation_name = new WeakMap(), _ApplicationInformation_releaseDir = new WeakMap(), _ApplicationInformation_releaseCodeDir = new WeakMap(), _ApplicationInformation_runDir = new WeakMap(), _ApplicationInformation_runtimeDir = new WeakMap(), _ApplicationInformation_tempDir = new WeakMap(), _ApplicationInformation_infos = new WeakMap();
exports.AppInfo = Leaf.ensureGlobal("@branch-ts/core/AppInfo", () => {
    return new ApplicationInformation;
});
class SubApplicationInformation extends ApplicationInformation {
    constructor(name, appInfo = exports.AppInfo) {
        super();
        this.appInfo = appInfo;
        this.name = pathModule.join(this.appInfo.name, name);
        this.tempDir = pathModule.join(this.appInfo.tempDir, name);
        this.runDir = pathModule.join(this.appInfo.runDir, name);
        this.isDebug = this.appInfo.isDebug;
    }
    sub(name) {
        let sub = new SubApplicationInformation(name, this);
        return sub;
    }
    tempOf(name) {
        return pathModule.join(this.tempDir, name);
    }
    runtimeOf(name) {
        return pathModule.join(this.runtimeDir, name);
    }
}
exports.SubApplicationInformation = SubApplicationInformation;
//# sourceMappingURL=application.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/behavior.js":
/*!******************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/behavior.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Behaviors = void 0;
class Behaviors {
    constructor(target) {
        this.target = target;
        this.dependencies = [];
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
}
exports.Behaviors = Behaviors;
//# sourceMappingURL=behavior.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/codex/blueprint.js":
/*!*************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/codex/blueprint.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Blueprint = void 0;
const codex_1 = __webpack_require__(/*! ./codex */ "./node_modules/@branch-ts/core/src/codex/codex.js");
class Blueprint {
    constructor(material, codex = codex_1.Codex.current) {
        this.material = material;
        this.codex = codex;
        this.seal();
    }
    seal() {
        if (this.material.sealed)
            return;
        this.material.sealed = true;
        for (let def of this.codex.getAllAspectDefinitions()) {
            const parents = this.findAspects(def.name);
            for (let child of def.children || []) {
                for (let parent of parents) {
                    const children = this.findAspects(child.name, { [child.parentUniqueNameKey]: parent.uniqueName });
                    parent[child.parentChildKey] = children;
                }
            }
        }
    }
    getAspect(name, uniqueName) {
        return this.material.aspects[name][uniqueName];
    }
    findAspects(name, match = {}) {
        const aspects = this.material.aspects[name] || {};
        if (match && Object.keys(match).length == 1 && match["uniqueName"]) {
            const target = aspects[match.uniqueName];
            if (target)
                return [target];
            return [];
        }
        return Object.keys(aspects).map(uniqueName => {
            return aspects[uniqueName];
        }).filter(item => {
            for (let key in match) {
                if (item[key] != match[key]) {
                    return false;
                }
            }
            return true;
        });
    }
    findAspect(name, match) {
        return this.findAspects(name, match)[0];
    }
}
exports.Blueprint = Blueprint;
//# sourceMappingURL=blueprint.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/codex/builder.js":
/*!***********************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/codex/builder.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _BuildContext_isSealed;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuildContext = exports.BlueprintBuilder = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const annotation_1 = __webpack_require__(/*! ../annotation */ "./node_modules/@branch-ts/core/src/annotation.js");
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const log_1 = __webpack_require__(/*! ../log */ "./node_modules/@branch-ts/core/src/log.js");
const codex_1 = __webpack_require__(/*! ./codex */ "./node_modules/@branch-ts/core/src/codex/codex.js");
__webpack_require__(/*! ../design/design */ "./node_modules/@branch-ts/core/src/design/design.js");
const service_1 = __webpack_require__(/*! ../service */ "./node_modules/@branch-ts/core/src/service.js");
class BlueprintBuilder {
    constructor(option = {}) {
        this.option = option;
        this.codex = this.option.codex || codex_1.Codex.current;
        this.annotation = this.option.annotation || annotation_1.AnnotationContext.current;
        this.givenMaterial = this.option.material || { aspects: {}, config: {} };
        this.stage = "pending";
        this.pendingParsedAcknowledgement = [];
        this.entries = {};
        this.fileboundFullTargetPathIndex = {};
    }
    addParsedAcknowledgement(acknowledgement) {
        if (this.stage !== "pending")
            throw new Error("Cannot add parsed acknowledgement after building");
        if (this.annotation.mode !== "compile")
            throw new Error("Annotation mode must be compile to add parsed acknowledgement");
        this.pendingParsedAcknowledgement.push(acknowledgement);
    }
    getAspectDescriptorBuildEntries(aspectName) {
        const obj = this.entries[aspectName] || {};
        return Object.keys(obj).map(key => obj[key]);
    }
    build() {
        return __awaiter(this, void 0, void 0, function* () {
            this.prepare();
            const result = yield this.make();
            return result;
        });
    }
    prepare() {
        this.entries = {};
        this.fileboundFullTargetPathIndex = {};
        // 1. make build entry/file bound path
        // 2. bind parsed acknowledgement (if mode == compile)
        // 3. run by rules
        this.annotation.runtimeAcknowledgements.sort((a, b) => { return a.order - b.order; });
        for (let item of this.annotation.runtimeAcknowledgements) {
            const entries = this.entries[item.definition.name] = this.entries[item.definition.name] || {};
            const uniqueName = item.uniqueName;
            if (entries[uniqueName]) {
                let dup = entries[uniqueName];
                if (item.src) {
                    log_1.Logger.error(item.src);
                    log_1.Logger.error(`${item.uniqueName} already declared in ${dup.runtime.src}`);
                }
                log_1.Logger.error(`Duplicated ${item.definition.name}: ${uniqueName}
This is usually caused by conflict service name in same namespace,
or different version of same library (like @branch-ts/web) are imported.
`);
                throw new errors_1.Errors.DesignError(`Duplicated ${item.definition.name}: ${uniqueName}`);
            }
            const entry = entries[uniqueName] = {
                aspectName: item.definition.name,
                uniqueName: item.uniqueName,
                name: item.name,
                runtime: item,
            };
            if (this.annotation.mode != "runtime") {
                if (!item.fileBoundFullTargetPath) {
                    throw new errors_1.Errors.LogicError("Missing fileBoundFullTargetPath");
                }
                if (!this.fileboundFullTargetPathIndex[item.fileBoundFullTargetPath]) {
                    this.fileboundFullTargetPathIndex[item.fileBoundFullTargetPath] = [entry];
                }
                else {
                    this.fileboundFullTargetPathIndex[item.fileBoundFullTargetPath].push(entry);
                }
            }
        }
        if (this.annotation.mode != "runtime") {
            for (let item of this.pendingParsedAcknowledgement) {
                const entries = this.fileboundFullTargetPathIndex[item.fileBoundFullTargetPath];
                if (!entries) {
                    throw new errors_1.Errors.DesignError(`Missing runtime acknowledgement ${item.fileBoundFullTargetPath}`);
                }
                for (let entry of entries) {
                    entry.parsed = item;
                }
            }
        }
    }
    make() {
        return __awaiter(this, void 0, void 0, function* () {
            const context = new BuildContext(this);
            for (let definition of this.codex.getAllAspectDefinitions()) {
                const aspectBuildSection = new AspectBuildSection(context, definition);
                context.add(aspectBuildSection);
            }
            yield context.build();
            context.seal();
            return context;
        });
    }
}
exports.BlueprintBuilder = BlueprintBuilder;
// {aspectName}[acknowledged]
// {aspectName.property}[acknowledged]
// {aspectName}[before]
// {aspectName.property}[before]
// multi => {aspectName.property}<instanceUniqueName>[make]
// {aspectName.property}[after]
// {aspectName}[after]
// {aspectName.property}[secured]
// {aspectName}[post]
// {aspectName}[secured]
class AspectBuildSection {
    constructor(context, definition) {
        this.context = context;
        this.definition = definition;
        this.type = "aspect";
        this.sectionName = this.definition.name;
        this.propertySections = [];
        this.participations = [];
        this.createPropertySections();
        this.createParticipations();
        this.createPhaseSections();
    }
    createPropertySections() {
        for (let key in this.definition.properties) {
            const section = new AspectPropertyBuildSection(this, key);
            this.propertySections.push(section);
        }
    }
    createPhaseSections() {
        this.secured = new AspectPhaseBuildSection(this, "secured", [
            // require all {aspectName.property}[secured]
            `${this.sectionName}[post]`,
            ...(this.definition.children || []).map(child => `${child.name}[secured]`),
            ...(this.participations.map((part) => part.sectionName))
        ], () => __awaiter(this, void 0, void 0, function* () { }));
        this.after = new AspectPhaseBuildSection(this, "after", [
            // require all {aspectName.property}[after]
            ...this.propertySections.map(sec => sec.after.sectionName)
        ]);
        this.before = new AspectPhaseBuildSection(this, "before", [
            // require all {aspectName.property}[before]
            ...this.propertySections.map(sec => sec.acknowledged.sectionName)
        ]);
        this.acknowledged = new AspectPhaseBuildSection(this, "acknowledged", [], () => __awaiter(this, void 0, void 0, function* () {
            // Initialize the empty aspect
            const buildingAspects = this.context.material.aspects[this.definition.name] = this.context.material.aspects[this.definition.name] || {};
            const entries = this.context.builder.entries[this.definition.name] || {};
            for (let uniqueName in entries) {
                buildingAspects[uniqueName] = buildingAspects[uniqueName] || {};
            }
        }));
    }
    createParticipations() {
        for (let part of this.definition.participations || []) {
            this.participations.push(new AspectParticipationSection(this.context, this.definition, part));
        }
    }
    getBuildSections() {
        const sections = [];
        sections.push(this.acknowledged, this.before, this.after, this.secured);
        sections.push(...this.propertySections);
        sections.push(new AspectPostProcessBuildSection(this));
        sections.push(...this.participations);
        return sections;
    }
}
class AspectParticipationSection {
    constructor(context, definition, participation) {
        this.context = context;
        this.definition = definition;
        this.participation = participation;
        this.type = "participation";
        this.requires = [];
        this.sectionName = "#" + this.participation.name;
        for (let req of this.participation.requires) {
            this.addExternalRequire(req);
        }
    }
    todo(builder) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            yield ((_b = (_a = this.participation).todo) === null || _b === void 0 ? void 0 : _b.call(_a, this.context));
        });
    }
    addExternalRequire(req) {
        const part = this.context.parseSectionNameString(req);
        let aspectName;
        let propertyName;
        if (part.global) {
            this.requires.push(req);
            return;
        }
        if (!part.secondName) {
            aspectName = this.definition.name;
            propertyName = part.firstName;
        }
        else {
            aspectName = part.firstName;
            propertyName = part.secondName;
        }
        this.requires.push(`${aspectName}.${propertyName}[after]`);
    }
}
class AspectPropertyBuildSection {
    constructor(aspectBuildSection, key) {
        this.aspectBuildSection = aspectBuildSection;
        this.key = key;
        this.type = "aspectProperty";
        this.aspectDefinition = this.aspectBuildSection.definition;
        this.propertyDefinition = this.aspectDefinition.properties[this.key];
        this.context = this.aspectBuildSection.context;
        this.sectionName = this.aspectBuildSection.definition.name + "." + this.key;
        this.createPhaseSections();
    }
    createPhaseSections() {
        this.secured = new AspectPropertyPhaseBuildSection(this, "secured", [
            `${this.aspectDefinition.name}[after]`
        ]);
        this.after = new AspectPropertyPhaseBuildSection(this, "after", [
            // All instance of this property is done
            ...this.context.builder
                .getAspectDescriptorBuildEntries(this.aspectDefinition.name)
                .map(entry => `${this.aspectDefinition.name}.${this.propertyDefinition.key}<${entry.uniqueName}>[make]`)
        ]);
        this.before = new AspectPropertyPhaseBuildSection(this, "before", [
            `${this.aspectDefinition.name}[before]`
        ]);
        this.acknowledged = new AspectPropertyPhaseBuildSection(this, "acknowledged", [`${this.aspectDefinition.name}[acknowledged]`], () => __awaiter(this, void 0, void 0, function* () {
            // Setup legacy value to given context.builder's material
            const buildingAspects = this.context.material.aspects[this.aspectDefinition.name];
            this.context.builder.getAspectDescriptorBuildEntries(this.aspectDefinition.name).forEach(entry => {
                var _a, _b, _c, _d;
                const value = (_d = (_c = (_b = (_a = this.context.builder.givenMaterial) === null || _a === void 0 ? void 0 : _a.aspects) === null || _b === void 0 ? void 0 : _b[this.aspectDefinition.name]) === null || _c === void 0 ? void 0 : _c[entry.uniqueName]) === null || _d === void 0 ? void 0 : _d[this.propertyDefinition.key];
                const buildingAspect = buildingAspects[entry.uniqueName];
                buildingAspect[this.propertyDefinition.key] = value;
            });
        }));
    }
    getBuildSections() {
        const sections = [];
        sections.push(this.acknowledged, this.before, this.after, this.secured);
        this.context.builder.getAspectDescriptorBuildEntries(this.aspectDefinition.name).forEach(entry => {
            sections.push(new AspectPropertyInstanceBuildSection(this, entry));
        });
        return sections;
    }
}
class AspectPostProcessBuildSection {
    constructor(aspectBuildSection) {
        this.aspectBuildSection = aspectBuildSection;
        this.type = "aspectPostProcess";
        this.requires = [...this.aspectBuildSection.propertySections.map(sec => sec.secured.sectionName)];
        this.sectionName = `${this.aspectBuildSection.sectionName}[post]`;
    }
    todo(builder) {
        return __awaiter(this, void 0, void 0, function* () {
            const todos = this.aspectBuildSection.definition.onBeforeSecured || [];
            for (let todo of todos) {
                todo(this.aspectBuildSection.context);
            }
        });
    }
}
class AspectPhaseBuildSection {
    constructor(aspectBuildSection, phase, requires, todo) {
        this.aspectBuildSection = aspectBuildSection;
        this.phase = phase;
        this.requires = requires;
        this.todo = todo;
        this.type = "aspectPhase";
        this.sectionName = this.aspectBuildSection.sectionName + "[" + this.phase + "]";
    }
}
class AspectPropertyPhaseBuildSection {
    constructor(aspectPropertyBuildSection, phase, requires, todo) {
        this.aspectPropertyBuildSection = aspectPropertyBuildSection;
        this.phase = phase;
        this.requires = requires;
        this.todo = todo;
        this.type = "aspectPropertyPhase";
        this.sectionName = this.aspectPropertyBuildSection.sectionName + "[" + this.phase + "]";
    }
}
class AspectPropertyInstanceBuildSection {
    constructor(aspectPropertyBuildSection, entry) {
        this.aspectPropertyBuildSection = aspectPropertyBuildSection;
        this.entry = entry;
        this.type = "aspectPropertyInstanceMake";
        this.context = this.aspectPropertyBuildSection.context;
        this.sectionName = this.aspectPropertyBuildSection.sectionName + `<${this.entry.uniqueName}>` + "[make]";
        this.requires = [this.aspectPropertyBuildSection.sectionName + "[before]"];
        this.aspectDefinition = this.aspectPropertyBuildSection.aspectDefinition;
        this.propertyDefinition = this.aspectPropertyBuildSection.propertyDefinition;
        for (let req of this.propertyDefinition.requires) {
            const part = this.context.parseSectionNameString(req);
            if (part.at) {
                this.addLocalRequire(part.firstName);
            }
            else {
                this.addExternalRequire(req);
            }
        }
        // Requires parent's uniqueName to be ready
        if (this.aspectDefinition.parents) {
            if (this.propertyDefinition.key == "uniqueName") {
                for (let parentName of this.aspectDefinition.parents) {
                    this.addExternalRequire(parentName + ".uniqueName");
                }
            }
            if (this.propertyDefinition.key == "knowledge") {
                for (let parentName of this.aspectDefinition.parents) {
                    this.addExternalRequire(parentName + ".knowledge");
                }
            }
        }
    }
    addLocalRequire(req) {
        const name = `${this.aspectDefinition.name}.${req}<${this.entry.uniqueName}>[make]`;
        this.requires.push(name);
    }
    addExternalRequire(req) {
        const part = this.context.parseSectionNameString(req);
        let aspectName;
        let propertyName;
        if (part.global) {
            this.requires.push(req);
            return;
        }
        if (!part.secondName) {
            aspectName = this.aspectDefinition.name;
            propertyName = part.firstName;
        }
        else {
            aspectName = part.firstName;
            propertyName = part.secondName;
        }
        const symbol = `${aspectName}.${propertyName}[after]`;
        if (!this.requires.includes(symbol)) {
            this.requires.push(symbol);
        }
    }
    todo() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const aspect = this.context.material.aspects[this.aspectDefinition.name][this.entry.uniqueName];
            const entry = this.entry;
            const propertyContext = {
                context: this.context,
                aspectName: this.aspectDefinition.name,
                runtime: entry.runtime,
                parsed: entry.parsed,
                aspectDefinition: this.aspectDefinition,
                propertyDefinition: this.propertyDefinition,
                aspect,
                parentAspects: {},
                key: this.propertyDefinition.key,
                value: aspect[this.propertyDefinition.key],
                error(message) {
                    var _a;
                    if ((_a = this.runtime) === null || _a === void 0 ? void 0 : _a.src) {
                        log_1.Logger.error(`@${this.aspectDefinition.name}.${entry.runtime.name}  error at ${this.runtime.src}`);
                    }
                    throw new errors_1.Errors.DesignError(message);
                }
            };
            const parents = this.aspectDefinition.parents || [];
            for (let parent of parents) {
                const parentUniqueName = entry.runtime.parentAcknowledgement.uniqueName;
                propertyContext.parentAspects[parent] = (_a = this.context.material.aspects[parent]) === null || _a === void 0 ? void 0 : _a[parentUniqueName];
            }
            if (this.propertyDefinition.key == "uniqueName") {
                BuildContext.setContext(aspect, propertyContext);
            }
            if (this.propertyDefinition.make) {
                const value = yield this.propertyDefinition.make(propertyContext);
                aspect[this.propertyDefinition.key] = value;
            }
            else {
                const value = yield this.defaultMake(propertyContext);
                aspect[this.propertyDefinition.key] = value;
            }
        });
    }
    defaultMake(ctx) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const propDef = ctx.propertyDefinition;
            if (typeof ctx.value !== "undefined") {
                return ctx.value;
            }
            let value;
            if (propDef.input === "optional") {
                value = (_a = ctx.runtime.inputs) === null || _a === void 0 ? void 0 : _a[propDef.key];
            }
            else if (propDef.input == "required") {
                value = (_b = ctx.runtime.inputs) === null || _b === void 0 ? void 0 : _b[propDef.key];
                if (typeof value == "undefined") {
                    if (ctx.runtime.src) {
                        log_1.Logger.error(`${ctx.propertyDefinition.key} is required at ${ctx.runtime.src}`);
                        log_1.Logger.error(ctx.runtime.src);
                    }
                    throw new errors_1.Errors.DesignError(`${ctx.propertyDefinition.key} is required`);
                }
            }
            else if (propDef.input === "value") {
                value = ctx.runtime.value;
            }
            else {
                throw new errors_1.Errors.LogicError(`Missing make function for ${ctx.aspectDefinition.name}.${ctx.propertyDefinition.key}`);
            }
            ctx.value = value;
            return value;
        });
    }
}
class BuildContext {
    static setContext(aspect, context) {
        Object.defineProperty(aspect, this.contextSymbol, {
            enumerable: false,
            value: context,
        });
    }
    static getContext(aspect) {
        return aspect[this.contextSymbol];
    }
    constructor(builder) {
        this.builder = builder;
        this.material = Leaf.Util.clone(this.builder.givenMaterial);
        this.tasks = {};
        this.deps = new service_1.FastDependencyManager();
        this.verbose = false;
        _BuildContext_isSealed.set(this, false);
    }
    toJSON() {
        const result = {
            aspects: {}
        };
        for (let aspectName in this.builder.codex.aspectDefinitions) {
            const definition = this.builder.codex.aspectDefinitions[aspectName];
            const resultAspects = result.aspects[definition.name] = {};
            const aspects = this.material.aspects[definition.name];
            for (let uniqueName in aspects) {
                const compiledAspect = aspects[uniqueName];
                const resultAspect = resultAspects[uniqueName] = {};
                for (let propertyName in definition.properties) {
                    const def = definition.properties[propertyName];
                    resultAspect[def.key] = compiledAspect[def.key];
                }
            }
        }
        return result;
    }
    getMaterial() {
        return this.material;
    }
    addFinalAspect(aspect) {
        const definition = this.builder.codex.getAspectDefinition(aspect);
        const aspects = this.material.aspects[definition.name] = this.material.aspects[definition.name] || {};
        aspects[aspect.uniqueName] = aspect;
    }
    getAspects(name) {
        const aspects = this.material.aspects[name] || {};
        return Object.keys(aspects).map(key => this.material.aspects[name][key]);
    }
    findAspects(name, match) {
        return this.getAspects(name).filter(item => {
            for (let key in match) {
                if (item[key] != match[key]) {
                    return false;
                }
            }
            return true;
        });
    }
    findAspect(name, match) {
        return this.getAspects(name).find(item => {
            for (let key in match) {
                if (item[key] != match[key]) {
                    return false;
                }
            }
            return true;
        });
    }
    add(...sections) {
        for (let section of sections) {
            if (this.tasks[section.sectionName]) {
                throw new errors_1.Errors.LogicError(`Duplicated build section ${section.sectionName}`);
            }
            this.tasks[section.sectionName] = section;
            this.deps.add(section.sectionName, section.requires || []);
            if (section.getBuildSections) {
                this.add(...section.getBuildSections());
            }
        }
    }
    solve() {
        return this.deps.resolve();
    }
    runs(orders) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let order of orders) {
                const task = this.tasks[order];
                if (!task) {
                    throw new errors_1.Errors.LogicError(`Missing build section ${order}`);
                }
                if (this.verbose) {
                    log_1.Logger.debug(`Build section ${order}`);
                }
                if (task.todo) {
                    yield task.todo(this.builder);
                }
            }
        });
    }
    parseSectionNameString(name) {
        const reg = /^[@#]?([a-z]+)(\.[a-z]+)?(<[a-z.]+>)?(\[[a-z]\])?$/i;
        const match = reg.exec(name);
        if (!match)
            return null;
        let [_, firstName, secondName, instanceUniqueName, phase] = match;
        if (secondName)
            secondName = secondName.replace(".", "");
        if (instanceUniqueName)
            instanceUniqueName = instanceUniqueName.slice(1, -1);
        if (phase)
            phase = phase.slice(1, -2);
        return {
            at: name[0] == "@",
            global: name[0] == "#",
            firstName,
            secondName,
            instanceUniqueName,
            phase
        };
    }
    build() {
        return __awaiter(this, void 0, void 0, function* () {
            if (__classPrivateFieldGet(this, _BuildContext_isSealed, "f"))
                throw new errors_1.Errors.LogicError(`Can't build after BuildContext is sealed`);
            for (let [name, design] of Object.entries(this.builder.codex.designs)) {
                for (let aspectName in design.builtInAspects) {
                    let aspects = design.builtInAspects[aspectName];
                    if ((aspects === null || aspects === void 0 ? void 0 : aspects.length) > 0) {
                        for (let aspect of aspects) {
                            this.material.aspects = this.material.aspects || {};
                            let targetAspects = this.material.aspects[aspectName] = this.material.aspects[aspectName] || {};
                            for (let aspect of aspects) {
                                targetAspects[aspect.uniqueName] = aspect;
                            }
                        }
                    }
                }
            }
            const orders = this.solve();
            yield this.runs(orders);
        });
    }
    clean() {
        if (__classPrivateFieldGet(this, _BuildContext_isSealed, "f"))
            throw new errors_1.Errors.LogicError(`Can't clean after BuildContext is sealed`);
        this.deps = new service_1.FastDependencyManager();
        this.material = Leaf.Util.clone(this.builder.givenMaterial);
    }
    seal() {
        __classPrivateFieldSet(this, _BuildContext_isSealed, true, "f");
    }
}
exports.BuildContext = BuildContext;
_BuildContext_isSealed = new WeakMap();
BuildContext.contextSymbol = Leaf.ensureGlobal("BuildContextContextSymbol", () => Symbol("BuildContextContextSymbol"));
//# sourceMappingURL=builder.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/codex/codex.js":
/*!*********************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/codex/codex.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CurrentCodex = exports.Codex = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const nanoid_1 = __webpack_require__(/*! nanoid */ "./node_modules/nanoid/index.browser.js");
const knowledge_1 = __webpack_require__(/*! ./knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const typeSystem_1 = __webpack_require__(/*! ../typeSystem */ "./node_modules/@branch-ts/core/src/typeSystem.js");
const namespace_1 = __webpack_require__(/*! ../namespace */ "./node_modules/@branch-ts/core/src/namespace.js");
const log_1 = __webpack_require__(/*! ../log */ "./node_modules/@branch-ts/core/src/log.js");
class Codex {
    constructor() {
        this.namespace = namespace_1.GlobalNamespace;
        this.designs = {};
        this.aspectDefinitions = {};
    }
    static get current() {
        return exports.CurrentCodex;
    }
    get typeSystem() {
        return typeSystem_1.GlobalTypeSystem;
    }
    generateId() {
        return (0, nanoid_1.nanoid)();
    }
    now() {
        return Date.now();
    }
    random() {
        return Math.random();
    }
    register(design) {
        if (this.designs[design.name]) {
            log_1.Logger.error(`Design ${design.name} already registered`);
            return;
        }
        this.designs[design.name] = design;
        for (let definition of design.definitions) {
            this.registerAspectDefinition(definition);
        }
    }
    registerAspectDefinition(definition) {
        if (this.aspectDefinitions[definition.name]) {
            throw new Error(`Aspect ${definition.name} already registered`);
        }
        this.aspectDefinitions[definition.name] = definition;
        this.generateBuiltInAspectPropertiesInPlace(definition);
        if (definition.parents) {
            for (let parentName of definition.parents) {
                const parent = this.aspectDefinitions[parentName];
                parent.children = parent.children || [];
                parent.children.push(definition);
            }
        }
        definition.children = definition.children || [];
    }
    generateBuiltInAspectPropertiesInPlace(definition) {
        if (!definition.properties["namespace"]) {
            let namespaceDef = definition.properties["namespace"] = {
                key: "namespace",
                input: "required",
                knowledge: knowledge_1.KnowledgeScope.User,
                requires: [],
                make(ctx) {
                    var _a, _b, _c, _d, _e, _f, _g;
                    return __awaiter(this, void 0, void 0, function* () {
                        let parentNamespace;
                        if (definition.parents) {
                            parentNamespace = ((_c = (_b = (_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.parentAcknowledgement) === null || _b === void 0 ? void 0 : _b.inputs) === null || _c === void 0 ? void 0 : _c.namespace) || ((_d = ctx.runtime) === null || _d === void 0 ? void 0 : _d.parentAcknowledgement.ambientNamespace);
                        }
                        const value = ctx.value || ((_f = (_e = ctx.runtime) === null || _e === void 0 ? void 0 : _e.inputs) === null || _f === void 0 ? void 0 : _f.namespace) || parentNamespace || ((_g = ctx.runtime) === null || _g === void 0 ? void 0 : _g.ambientNamespace);
                        ctx.value = value;
                        return value;
                    });
                },
                typeSpec: "Type.Branch.Name.NamespaceName",
            };
            if (definition.parents && definition.parents.length > 0) {
                namespaceDef.input = "none";
            }
        }
        if (!definition.properties["name"]) {
            definition.properties["name"] = {
                key: "name",
                input: "none",
                knowledge: knowledge_1.KnowledgeScope.User,
                requires: [],
                make(ctx) {
                    var _a;
                    return __awaiter(this, void 0, void 0, function* () {
                        const value = ctx.value || ((_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.name);
                        return value;
                    });
                },
                typeSpec: `Type.Branch.Name.${Leaf.Util.capitalize(definition.name)}Name`
            };
        }
        if (!definition.properties["hardcoded"]) {
            definition.properties["hardcoded"] = {
                key: "hardcoded",
                input: "none",
                knowledge: knowledge_1.KnowledgeScope.User,
                unique: false,
                requires: [],
                make(ctx) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const value = ctx.value || false;
                        return value;
                    });
                },
                typeSpec: `boolean`,
                optional: true,
            };
        }
        if (!definition.properties["uniqueName"]) {
            definition.properties["uniqueName"] = {
                key: "uniqueName",
                input: "none",
                knowledge: knowledge_1.KnowledgeScope.User,
                unique: true,
                requires: [],
                make(ctx) {
                    var _a;
                    return __awaiter(this, void 0, void 0, function* () {
                        const value = ctx.value || ((_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.uniqueName);
                        return value;
                    });
                },
                typeSpec: `Type.Branch.Name.${Leaf.Util.capitalize(definition.name)}UniqueName`
            };
        }
        definition.properties["uniqueName"].unique = true;
        if (!definition.properties["knowledge"]) {
            const parents = definition.parents || [];
            const requires = parents.map(parentName => {
                return `${parentName}.knowledge`;
            });
            definition.properties["knowledge"] = {
                key: "knowledge",
                input: "optional",
                knowledge: knowledge_1.KnowledgeScope.User,
                requires,
                make(ctx) {
                    var _a, _b;
                    return __awaiter(this, void 0, void 0, function* () {
                        let value = ctx.value || ((_b = (_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b.knowledge) || definition.defaultKnowledge;
                        if (typeof value !== "number")
                            value = knowledge_1.KnowledgeScope.Implementer;
                        ctx.value = value;
                        for (let key in ctx.parentAspects) {
                            const parentAspect = ctx.parentAspects[key];
                            if (!parentAspect) {
                                continue;
                            }
                            const parentKnowledge = parentAspect["knowledge"] || knowledge_1.KnowledgeScope.User;
                            if (parentKnowledge > ctx.value) {
                                console.error(`Parent`, parentAspect[`uniqueName`], `has stricter knowledge(${parentKnowledge}) than child ${ctx.aspect.uniqueName}(${ctx.value}) which make child knowledge obsolete`);
                            }
                        }
                        return value;
                    });
                },
                typeSpec: "Type.Branch.Spec.KnowledgeScope"
            };
        }
        definition.properties["aspectName"] = {
            key: "aspectName",
            input: "none",
            knowledge: knowledge_1.KnowledgeScope.User,
            requires: [],
            make(ctx) {
                return __awaiter(this, void 0, void 0, function* () {
                    let value = ctx.value || ctx.aspectName;
                    return value;
                });
            },
            typeSpec: "Type.Branch.Name.AspectName"
        };
    }
    getAspectDefinition(option) {
        if (option.aspectName) {
            return this.aspectDefinitions[option.aspectName];
        }
        return this.aspectDefinitions[option.aspect.aspectName];
    }
    getAllAspectDefinitions() {
        return Object.keys(this.aspectDefinitions).map(key => this.aspectDefinitions[key]);
    }
}
exports.Codex = Codex;
exports.CurrentCodex = Leaf.ensureGlobal("BranchTsCodex", () => new Codex());
(function (Codex) {
    function makeOptionalBooleanPropertyDefinition(key, option) {
        const annotate = option.annotate || (() => undefined);
        const knowledge = option.knowledge || knowledge_1.KnowledgeScope.User;
        return {
            key,
            input: "optional",
            requires: [],
            knowledge,
            make(ctx) {
                var _a, _b, _c, _d;
                return __awaiter(this, void 0, void 0, function* () {
                    let value;
                    let valueFromAnnotation = annotate(ctx);
                    if (typeof ctx.value !== "undefined")
                        value = ctx.value;
                    else if (typeof ((_b = (_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b[key]) !== "undefined")
                        value = (_d = (_c = ctx.runtime) === null || _c === void 0 ? void 0 : _c.inputs) === null || _d === void 0 ? void 0 : _d[key];
                    else if (typeof valueFromAnnotation !== "undefined")
                        value = valueFromAnnotation;
                    else
                        value = false;
                    ctx.value = value;
                    return value;
                });
            },
            description: option.description,
            typeSpec: "boolean"
        };
    }
    Codex.makeOptionalBooleanPropertyDefinition = makeOptionalBooleanPropertyDefinition;
})(Codex || (exports.Codex = Codex = {}));
//# sourceMappingURL=codex.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/codex/design.js":
/*!**********************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/codex/design.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Design = void 0;
class Design {
    constructor(name, option = {}) {
        this.name = name;
        this.option = option;
        this.definitions = this.option.definitions || [];
        this.builtInAspects = this.option.builtInAspects || {};
        for (let def of this.definitions) {
            def.design = this.name;
        }
    }
}
exports.Design = Design;
//# sourceMappingURL=design.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/codex/flow.js":
/*!********************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/codex/flow.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Flow = void 0;
const valueNode_1 = __webpack_require__(/*! ./valueNode */ "./node_modules/@branch-ts/core/src/codex/valueNode.js");
const aspect_field_1 = __webpack_require__(/*! ../design/aspect.field */ "./node_modules/@branch-ts/core/src/design/aspect.field.js");
class Flow {
    constructor(domain, model, environment = {}) {
        this.domain = domain;
        this.model = model;
        this.environment = environment;
        this.codex = this.domain.codex;
        this.typeSystem = this.codex.typeSystem;
        this.nodeMap = {};
        this.resolvedOrders = [];
        for (let field of this.model.fields) {
            this.nodeMap[field.key] = new valueNode_1.ValueNode(this, field);
        }
        this.compile();
    }
    compile() {
        this.resolvedOrders.length = 0;
        this.resolvedOrders = this.model.fieldInitOrders.slice();
    }
    getEnvironment(environment = {}) {
        return Object.assign(Object.assign({}, this.environment), environment);
    }
    genFlowMapFinalValues(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const environment = this.getEnvironment(option.environment);
            const currentDataMap = {};
            const evalResultMap = {};
            for (let id of this.resolvedOrders) {
                const node = this.nodeMap[id];
                const context = new valueNode_1.ValueNodeEvalContext();
                context.original = option.original || {};
                context.procedure = option.procedure;
                context.currentDataMap = currentDataMap;
                context.environment = environment;
                context.evalResultMap = evalResultMap;
                context.domain = this.domain;
                // When create with init value, we consider init value as originValue
                if (node.descriptor.hasInitValue && option.procedure == "create") {
                    context.original[id] = node.descriptor.initValue;
                    context.originNodeValue = node.descriptor.initValue;
                }
                else {
                    context.originNodeValue = context.original[id];
                }
                // When create with default value, and no user input
                // We consider the default value as input
                if (typeof node.descriptor.default !== "undefined"
                    && option.procedure == "create"
                    && typeof option.input[id] == "undefined") {
                    context.inputNodeValue = node.descriptor.default;
                }
                else {
                    context.inputNodeValue = option.input[id];
                }
                context.hasInputValue = id in option.input && typeof option.input[id] !== "undefined";
                context.fields = option.fields;
                context.locale = option.locale || "en";
                context.systemContext = this.domain.getSystemContext();
                context.codex = this.codex;
                // if not mutable, generate will not called, but input will pass by
                // 1. If input provided by original value, it's a valid behavior
                // 2. If input provided by unchecked input, it's caller's duty to check the mutability
                //    and give proper warning.
                const result = yield node.apply(context);
                context.currentDataMap[id] = result.resultValue;
                evalResultMap[id] = result;
            }
            return evalResultMap;
        });
    }
    eval(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const fields = {};
            for (let field of this.model.fields) {
                fields[field.key] = field;
            }
            const map = yield this.genFlowMapFinalValues({
                input: option.input,
                procedure: option.procedure,
                environment: option.environment,
                original: option.original,
                fields,
                locale: option.locale,
            });
            const changed = {};
            const initialized = {};
            const updated = {};
            const data = {};
            const original = option.original || null;
            for (let field of this.model.fields) {
                if (!aspect_field_1.FieldSpecification.OutputableAvailabilities.includes(field.availability)) {
                    continue;
                }
                if (field.availability === "virtual") {
                    Object.defineProperty(data, field.key, {
                        get: field.generate,
                        enumerable: false,
                    });
                    if (original) {
                        Object.defineProperty(original, field.key, {
                            get: field.generate,
                            enumerable: false,
                        });
                    }
                    continue;
                }
                const key = field.key;
                const result = map[key];
                data[key] = result.resultValue;
                original[key] = result.originValue;
                if (map[key].initialized) {
                    initialized[key] = result.resultValue;
                }
                if (map[key].updated) {
                    updated[key] = result.resultValue;
                }
                if (map[key].changed) {
                    changed[key] = result.resultValue;
                }
            }
            const ret = {
                data, changed, initialized, updated, original
            };
            if (option.textSearch) {
                ret["searchIndexes"] = option.textSearch.getSearchIndexCache(data);
            }
            return ret;
        });
    }
}
exports.Flow = Flow;
//# sourceMappingURL=flow.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/codex/knowledge.js":
/*!*************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/codex/knowledge.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Knowledge = exports.KnowledgeScope = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const codex_1 = __webpack_require__(/*! ./codex */ "./node_modules/@branch-ts/core/src/codex/codex.js");
class KnowledgeScope {
    constructor(codex = codex_1.Codex.current) {
        this.codex = codex;
    }
    requiredKnowledgeOfAspect(option) {
        const definition = this.codex.getAspectDefinition(option);
        if (!definition) {
            throw new errors_1.Errors.DesignError(`Aspect ${option.aspect} is not defined`);
        }
        const desc = option.aspect;
        let min;
        // 1. Descriptor knowledge overwrites the default knowledge of AspectDefinition
        if (typeof desc.knowledge == "number") {
            min = desc.knowledge;
        }
        else if (typeof definition.defaultKnowledge == "number") {
            min = definition.defaultKnowledge;
        }
        else {
            min = KnowledgeScope.Implementer;
        }
        return min;
    }
    requiredKnowledgeOfProperty(option) {
        var _a;
        const fromParent = this.requiredKnowledgeOfAspect(option);
        const definition = this.codex.getAspectDefinition(option.aspect);
        const fromProperty = ((_a = definition.properties[option.key]) === null || _a === void 0 ? void 0 : _a.knowledge) || KnowledgeScope.Implementer;
        return Math.max(fromParent, fromProperty);
    }
}
exports.KnowledgeScope = KnowledgeScope;
(function (KnowledgeScope) {
    KnowledgeScope.Implementer = 32;
    KnowledgeScope.UI = 2;
    KnowledgeScope.User = 1;
})(KnowledgeScope || (exports.KnowledgeScope = KnowledgeScope = {}));
var Knowledge;
(function (Knowledge) {
    function has(my, target) {
        return my >= target;
    }
    Knowledge.has = has;
})(Knowledge || (exports.Knowledge = Knowledge = {}));
//# sourceMappingURL=knowledge.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/codex/valueNode.js":
/*!*************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/codex/valueNode.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValueNode = exports.ValueNodeEvalContext = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
class ValueNodeEvalContext {
    constructor() {
        this.evalResultMap = {};
    }
}
exports.ValueNodeEvalContext = ValueNodeEvalContext;
class ValueNode {
    constructor(flow, descriptor) {
        this.flow = flow;
        this.descriptor = descriptor;
        this.typeSystem = this.flow.typeSystem;
    }
    apply(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const typeSpec = this.typeSystem.getSpec(this.descriptor.type);
            const resultValue = yield this.evaluate(context);
            const result = {
                originValue: context.originNodeValue,
                resultValue,
                initialized: false,
                updated: false,
                changed: false,
            };
            let originUninit = typeSpec.isUninitialized(context.originNodeValue);
            let resultUninit = typeSpec.isUninitialized(resultValue);
            if (originUninit && !resultUninit) {
                result.initialized = true;
            }
            if (!Leaf.Util.deepEqual(resultValue, context.originNodeValue)) {
                result.changed = true;
                if (!originUninit && !resultUninit) {
                    result.updated = true;
                }
            }
            if (context.procedure === "create" && this.descriptor.hasInitValue) {
                result.initialized = true;
            }
            return result;
        });
    }
    needRegenerate(context) {
        for (let dep of this.descriptor.dependencies || []) {
            const depInfo = context.evalResultMap[dep];
            // dependency changed or dependency generated
            if (depInfo.changed || depInfo.useGenerate) {
                return true;
            }
        }
        return false;
    }
    evaluate(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const orig = context.original || {};
            const self = Object.assign(Object.assign({}, orig), context.currentDataMap);
            let info = this.descriptor.generate;
            if (!info) {
                if (this.descriptor.hasGenerate) {
                    throw new errors_1.Errors.RuntimeError(`Expecting generate of ${this.descriptor.uniqueName}, but not got nothing. It's likely the decorator file is not loaded in the runtime`);
                }
                // When create with init value, and not a generator, we will ignore user input
                if (context.procedure == "create" && this.descriptor.hasInitValue) {
                    return this.descriptor.initValue;
                }
                if (typeof context.inputNodeValue !== "undefined") {
                    return context.inputNodeValue;
                }
                return context.originNodeValue;
            }
            let evaluator;
            if (typeof info == "function") {
                evaluator = info;
            }
            else if (info.action == "valueDereference") {
                const key = info.field;
                const modelUniqueName = info.model;
                evaluator = (context) => __awaiter(this, void 0, void 0, function* () {
                    const id = context.currentDataMap[key];
                    const field = context.fields[key];
                    const typeSpec = this.typeSystem.getSpec(field.type);
                    if (typeSpec.isUninitialized(id))
                        return typeSpec.getUninitializedValue();
                    const model = context.systemContext.getModel(modelUniqueName);
                    if (!model) {
                        throw new errors_1.Errors.DesignError(`Dereferencing to unknown model ${modelUniqueName} `);
                    }
                    const group = model.getGroup({});
                    const result = yield group.get({ id });
                    return result;
                });
            }
            else if (info.action == "valueAccess") {
                const key = info.field;
                const property = info.property;
                evaluator = () => __awaiter(this, void 0, void 0, function* () {
                    const path = [key, property].filter(item => !!item).join(".");
                    const result = Leaf.Util.getObjectValue(context.currentDataMap, path);
                    const typeSpec = this.typeSystem.getSpec(this.descriptor.type);
                    if (typeof result == "undefined")
                        return typeSpec.getUninitializedValue();
                    return result;
                });
            }
            else if (info.action == "environmentReference") {
                const reference = info.reference;
                evaluator = () => __awaiter(this, void 0, void 0, function* () {
                    return Leaf.Util.getObjectValue(context.environment, reference);
                });
            }
            else if (info.action == "custom") {
                evaluator = info.todo;
            }
            else {
                throw new errors_1.Errors.LogicError(`Unknown generate  ${info}, ${JSON.stringify(info)}`);
            }
            const result = yield evaluator.call(self, context);
            return result;
        });
    }
}
exports.ValueNode = ValueNode;
//# sourceMappingURL=valueNode.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/config.js":
/*!****************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/config.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ConfigManager_domains, _ConfigManager_options;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigValueResolver = exports.Config = exports.GlobalConfigManager = exports.ConfigManager = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const domain_1 = __webpack_require__(/*! ./domain */ "./node_modules/@branch-ts/core/src/domain.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
const log_1 = __webpack_require__(/*! ./log */ "./node_modules/@branch-ts/core/src/log.js");
class ConfigManager {
    constructor() {
        _ConfigManager_domains.set(this, void 0);
        _ConfigManager_options.set(this, {});
    }
    get domains() {
        return __classPrivateFieldSet(this, _ConfigManager_domains, __classPrivateFieldGet(this, _ConfigManager_domains, "f") || new domain_1.Domains(), "f");
    }
    decorateToNewConstructor(Cons, context, runtime) {
        const self = this;
        return class extends Cons {
            constructor(...args) {
                super(args);
                return self.getProxy(this, runtime, args);
            }
        };
    }
    include(domain) {
        this.domains.include(domain);
        return this;
    }
    setValue(path, value) {
        const slot = this.getOptionSlot(path);
        if (!slot) {
            throw new errors_1.Errors.DesignError(`Config option ${path} not found`);
        }
        slot.value = value;
        slot.hasValue = true;
    }
    hasValue(path) {
        const slot = this.getOptionSlot(path);
        if (!slot) {
            return false;
        }
        return slot.hasValue;
    }
    getValue(path) {
        const slot = this.getOptionSlot(path);
        if (!slot) {
            throw new errors_1.Errors.DesignError(`Config option ${path} not found`);
        }
        return slot.value;
    }
    getOptionSlot(uniqueName) {
        if (__classPrivateFieldGet(this, _ConfigManager_options, "f")[uniqueName])
            return __classPrivateFieldGet(this, _ConfigManager_options, "f")[uniqueName];
        const descriptor = this.domains.findAspect("option", {
            uniqueName
        });
        if (!descriptor)
            return null;
        return __classPrivateFieldGet(this, _ConfigManager_options, "f")[uniqueName] = {
            descriptor,
            hasValue: false,
        };
    }
    getProxy(base, runtime, args) {
        const resolver = new ConfigValueResolver(runtime.uniqueName);
        return new Proxy(base, {
            get: (target, key) => {
                const slot = resolver.getOptionSlot(key);
                if (!slot) {
                    return Reflect.get(target, key);
                }
                if (!slot.hasValue) {
                    return Reflect.get(target, key);
                }
                return slot.value;
            }
        });
    }
    setConfigEntry(configUniqueName, value) {
        const config = this.domains.findAspect("config", {
            uniqueName: configUniqueName
        });
        if (!config) {
            log_1.Logger.warn(`Set unknown config: ${configUniqueName}`);
            return;
        }
        value = value || {};
        for (let option of config.options) {
            if (typeof value[option.name] == "undefined")
                continue;
            const slot = this.getOptionSlot(option.uniqueName);
            if (!slot) {
                log_1.Logger.warn(`Set unknown config option: ${option.uniqueName}`);
                continue;
            }
            slot.hasValue = true;
            slot.value = value[option.name];
        }
    }
    setConfig(config) {
        config = config || {};
        for (let key in config) {
            this.setConfigEntry(key, config[key]);
        }
    }
}
exports.ConfigManager = ConfigManager;
_ConfigManager_domains = new WeakMap(), _ConfigManager_options = new WeakMap();
exports.GlobalConfigManager = Leaf.ensureGlobal("BranchTsGlobalConfigManager", () => new ConfigManager());
class Config {
}
exports.Config = Config;
class ConfigValueResolver {
    constructor(configUniqueName, manager = exports.GlobalConfigManager) {
        this.configUniqueName = configUniqueName;
        this.manager = manager;
    }
    getOptionSlot(name) {
        return this.manager.getOptionSlot([this.configUniqueName, name].join("."));
    }
}
exports.ConfigValueResolver = ConfigValueResolver;
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/const.js":
/*!***************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/const.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultSystemSessionInfo = exports.DefaultGuestSessionInfo = exports.DefaultRepositoryProviderName = exports.DefaultViewportName = exports.DefaultGroupName = exports.DefaultGroupSomeCount = exports.Symbols = exports.TextSearchCacheKeyPrefix = exports.DefaultNamespace = void 0;
exports.DefaultNamespace = "Local";
exports.TextSearchCacheKeyPrefix = "_tsc_";
var Symbols;
(function (Symbols) {
    Symbols.Empty = Symbol("Empty");
    Symbols.Missing = Symbol("Missing");
})(Symbols || (exports.Symbols = Symbols = {}));
exports.DefaultGroupSomeCount = 100;
exports.DefaultGroupName = "defaultGroup";
exports.DefaultViewportName = "defaultViewport";
exports.DefaultRepositoryProviderName = "Default";
exports.DefaultGuestSessionInfo = Object.freeze({
    type: "none",
    userId: null,
    username: null,
    role: "guest",
    meta: null,
    locale: null
});
exports.DefaultSystemSessionInfo = Object.freeze({
    type: "system",
    userId: null,
    username: null,
    role: "system",
    meta: null,
    locale: null
});
//# sourceMappingURL=const.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/context.js":
/*!*****************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/context.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DomainSystemContext = exports.Context = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const Const = __importStar(__webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/const.js"));
const model_1 = __webpack_require__(/*! ./model */ "./node_modules/@branch-ts/core/src/model.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
class Context {
    constructor(domain, session = Leaf.Util.clone(Const.DefaultGuestSessionInfo)) {
        this.domain = domain;
        this.session = session;
        this.getModel = this.model;
        this.defaultNamespace = Const.DefaultNamespace;
        this.locale = "en";
    }
    get codex() { return this.domain.codex; }
    model(name) {
        const modelUniqueName = this.domain.codex.namespace.ensureUniqueName(name, this.defaultNamespace);
        const descriptor = this.domain.findAspect("model", {
            uniqueName: modelUniqueName
        });
        if (!descriptor) {
            throw new errors_1.Errors.RuntimeError(`Unknown model ${name} => ${modelUniqueName}`);
        }
        return new model_1.Model(this, descriptor);
    }
    getGroup(...args) {
        return this.group(args[0], args[1]);
    }
    group(option, params) {
        if (typeof option == "string") {
            option = { group: option };
        }
        if (option.group) {
            const naming = this.domain.codex.namespace.parseNaming(option.group, this.domain.codex.namespace.defaultNamespace);
            option.modelUniqueName = naming.uniqueName || option.modelUniqueName;
            option.name = naming.path || option.name;
        }
        if (params) {
            option.restriction = params || option.restriction;
        }
        const model = this.model(option.modelUniqueName);
        return model.group(option);
    }
    single(modelUniqueName) {
        return __awaiter(this, void 0, void 0, function* () {
            const model = this.model(modelUniqueName);
            if (!model.descriptor.single) {
                throw new Error(`${modelUniqueName} is not single`);
            }
            const result = yield model.some({
                offset: 0,
                count: 1,
            });
            let one = result[0];
            if (!one && typeof model.descriptor.single == "object") {
                return yield model.create({
                    data: model.descriptor.single
                });
            }
            return one;
        });
    }
    requestResourceAction(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.domain.requestResourceAction({
                descriptor: option.descriptor,
                session: this.session,
            });
        });
    }
}
exports.Context = Context;
class DomainSystemContext extends Context {
    constructor(domain, viaSession) {
        var _a;
        super(domain, viaSession);
        this.locale = ((_a = this.session) === null || _a === void 0 ? void 0 : _a.locale) || this.locale || "en";
        this.session = Object.freeze(Leaf.Util.clone(Const.DefaultSystemSessionInfo));
    }
}
exports.DomainSystemContext = DomainSystemContext;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.access.js":
/*!******************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.access.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccessAspectDescriptor = void 0;
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const access_1 = __webpack_require__(/*! ../access */ "./node_modules/@branch-ts/core/src/access.js");
const util_1 = __webpack_require__(/*! ../util */ "./node_modules/@branch-ts/core/src/util.js");
const access_cons = {
    key: "cons",
    requires: [],
    input: "value",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    description: "Class cons of the access",
    typeSpec: "Constructor<any>"
};
exports.AccessAspectDescriptor = {
    name: "access",
    style: "constructor",
    parents: null,
    parentUniqueNameKey: null,
    defaultKnowledge: knowledge_1.KnowledgeScope.Implementer,
    subClassOf: [access_1.Access],
    autoIncludeInDomain: true,
    properties: {
        cons: access_cons,
    }
};
util_1.Util.markBaseConstructor(access_1.Access);
//# sourceMappingURL=aspect.access.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.config.js":
/*!******************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.config.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigAspectDescriptor = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const config_1 = __webpack_require__(/*! ../config */ "./node_modules/@branch-ts/core/src/config.js");
const config_name = {
    key: "name",
    requires: [],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const value = ctx.value || ((_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.name);
        const reg = /^[A-Z][a-zA-Z0-9]*Config$/;
        if (!reg.test(value)) {
            throw new errors_1.Errors.DesignError(`Config name '${value}' must capitalized and contains only alphabets and end with Config`);
        }
        ctx.value = value;
        return value;
    }),
    description: "Name of the config, should be unique under same namespace, contains only alphabet and number only and must start with capitalized alphabet",
    typeSpec: "string"
};
const config_cons = {
    key: "cons",
    requires: [],
    input: "value",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    description: "Class Constructor of the config",
    typeSpec: "Constructor<any>"
};
exports.ConfigAspectDescriptor = {
    name: "config",
    style: "class",
    parents: null,
    parentUniqueNameKey: null,
    autoIncludeInDomain: true,
    defaultKnowledge: knowledge_1.KnowledgeScope.Implementer,
    decorateToNewValue: config_1.GlobalConfigManager.decorateToNewConstructor.bind(config_1.GlobalConfigManager),
    properties: {
        name: config_name,
        cons: config_cons,
    }
};
//# sourceMappingURL=aspect.config.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.field.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.field.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldAspectDescriptor = exports.FieldSpecification = exports.parseTsUnions = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const typeSystem_1 = __webpack_require__(/*! ../typeSystem */ "./node_modules/@branch-ts/core/src/typeSystem.js");
const codex_1 = __webpack_require__(/*! ../codex/codex */ "./node_modules/@branch-ts/core/src/codex/codex.js");
const reference_1 = __webpack_require__(/*! ./reference */ "./node_modules/@branch-ts/core/src/design/reference.js");
const scope_1 = __webpack_require__(/*! ./scope */ "./node_modules/@branch-ts/core/src/design/scope.js");
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const implementDeriveLogic_1 = __webpack_require__(/*! ./aspect.field/implementDeriveLogic */ "./node_modules/@branch-ts/core/src/design/aspect.field/implementDeriveLogic.js");
const autoGenerateTime_1 = __webpack_require__(/*! ./aspect.field/autoGenerateTime */ "./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateTime.js");
const autoGenerateCreator_1 = __webpack_require__(/*! ./aspect.field/autoGenerateCreator */ "./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateCreator.js");
const autoGenerateId_1 = __webpack_require__(/*! ./aspect.field/autoGenerateId */ "./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateId.js");
const autoSingleId_1 = __webpack_require__(/*! ./aspect.field/autoSingleId */ "./node_modules/@branch-ts/core/src/design/aspect.field/autoSingleId.js");
const autoGenerateField_1 = __webpack_require__(/*! ./aspect.field/autoGenerateField */ "./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateField.js");
function parseTsUnions(value) {
    const stringReg = new RegExp("^\".+\"$", "i");
    if (stringReg.test(value)) {
        return value.split("|").map(item => JSON.parse(item));
    }
    else if (value.indexOf("|") > 0) {
        return value.split("|").map(item => JSON.parse(item));
    }
    return [];
}
exports.parseTsUnions = parseTsUnions;
var FieldSpecification;
(function (FieldSpecification) {
    FieldSpecification.InputableAvailabilities = ["input", "store"];
    FieldSpecification.OutputableAvailabilities = ["store", "virtual", "auto"];
    FieldSpecification.PersistentAvailabilities = ["store", "auto"];
})(FieldSpecification || (exports.FieldSpecification = FieldSpecification = {}));
const field_modelUniqueName = {
    key: "modelUniqueName",
    knowledge: knowledge_1.KnowledgeScope.User,
    input: "none",
    requires: [],
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        const value = ctx.value || ctx.runtime.parentAcknowledgement.uniqueName;
        ctx.value = value;
        return value;
    }),
    description: "ModelUniqueName of the field",
    typeSpec: "Type.Branch.Name.ModelUniqueName"
};
const field_key = {
    key: "key",
    requires: [],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        const reg = /^[a-z][a-z0-9A-Z_]+$/;
        const value = ctx.value || ctx.runtime.name;
        if (!reg.test(value))
            ctx.error(`key "${value}" is not a valid key name`);
        ctx.value = value;
        return value;
    }),
    description: "key of the field",
    typeSpec: "string"
};
const field_type = {
    key: "type",
    input: "optional",
    requires: ["@tsTypeLiteral", "@enums", "@uniqueName", "model.uniqueName"],
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b, _c, _d;
        let value = ctx.value || ((_b = (_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b.type);
        if (!value && ctx.aspect.tsTypeLiteral) {
            value = typeSystem_1.GlobalTypeSystem.getTypeByLiteralType(ctx.aspect.tsTypeLiteral);
        }
        // resolve model types
        if (value && !typeSystem_1.GlobalTypeSystem.getSupportedTypeNames().includes(value)) {
            ctx.error(`${value} is not a valid type for ${ctx.aspect.uniqueName}`);
        }
        if (ctx.aspect.enums && Object.keys(ctx.aspect.enums).length > 0) {
            value = "enum";
        }
        if (!value && ctx.aspect.tsTypeLiteral) {
            // Unknown type for the type system
            value = "unknown";
        }
        if (value == "any") {
            if (!ctx.aspect.tsTypeLiteral) {
                if (((_d = (_c = ctx.runtime) === null || _c === void 0 ? void 0 : _c.inputs) === null || _d === void 0 ? void 0 : _d.type) !== "any") {
                    ctx.error(`Implied "any" is not allowed, please specify the type explicitly`);
                }
            }
        }
        ctx.value = value;
        return ctx.value;
    }),
    description: "Type of the field registered in branch-ts type system",
    typeSpec: "Type.Branch.BuiltInTypeLiteral"
};
const field_textSearch = {
    key: "textSearch",
    requires: ["@type"],
    input: "optional",
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (context) => __awaiter(void 0, void 0, void 0, function* () {
        var _e, _f;
        let value = context.value || ((_f = (_e = context.runtime) === null || _e === void 0 ? void 0 : _e.inputs) === null || _f === void 0 ? void 0 : _f.textSearch);
        if (!value) {
            context.value = value = false;
            return value;
        }
        const typeSpec = typeSystem_1.GlobalTypeSystem.getSpec(context.aspect.type);
        if (!typeSpec.isBasedOf("string") && context.aspect.type !== "enum") {
            context.error(`field ${context.aspect.name} is not text searchable, only string based type is text searchable`);
        }
        if (typeof value == "boolean" || typeof value == "string") {
            context.value = value;
            return context.value;
        }
        context.value = false;
        return false;
    }),
    description: "Speficy the built-in text search behavior of the field, if using string we will using it as name of the cached text search index",
    typeSpec: "boolean | Type.Branch.Name.TextSearchIndexName"
};
const field_displayName = {
    key: "displayName",
    requires: ["@key"],
    knowledge: knowledge_1.KnowledgeScope.UI,
    optional: true,
    input: "optional",
    make: (context) => __awaiter(void 0, void 0, void 0, function* () {
        var _g, _h;
        const value = context.value || ((_h = (_g = context.runtime) === null || _g === void 0 ? void 0 : _g.inputs) === null || _h === void 0 ? void 0 : _h.displayName);
        if (!!value && typeof value != "string") {
            context.error(`displayName must be string`);
        }
        context.value = value;
        return context.value;
    }),
    description: "DisplayName of the field",
    typeSpec: "string"
};
const field_optional = {
    key: "optional",
    knowledge: knowledge_1.KnowledgeScope.User,
    input: "optional",
    requires: [],
    make: (context) => __awaiter(void 0, void 0, void 0, function* () {
        var _j, _k, _l, _m, _o, _p;
        let value;
        if (typeof context.value !== "undefined") {
            value = context.value;
        }
        else if (typeof ((_k = (_j = context.runtime) === null || _j === void 0 ? void 0 : _j.inputs) === null || _k === void 0 ? void 0 : _k.optional) == "boolean") {
            value = (_m = (_l = context.runtime) === null || _l === void 0 ? void 0 : _l.inputs) === null || _m === void 0 ? void 0 : _m.optional;
        }
        else if ((_p = (_o = context.parsed) === null || _o === void 0 ? void 0 : _o.modifiers) === null || _p === void 0 ? void 0 : _p.includes("optional")) {
            value = true;
        }
        else {
            value = false;
        }
        context.value = value;
        return value;
    }),
    typeSpec: "boolean",
    description: "Is field optional for the document to be valid",
};
const field_unique = codex_1.Codex.makeOptionalBooleanPropertyDefinition("unique", {
    description: "If field should be unique across all document",
});
const field_description = {
    key: "description",
    knowledge: knowledge_1.KnowledgeScope.UI,
    requires: [],
    input: "optional",
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _q, _r;
        const value = ctx.value || ((_r = (_q = ctx.runtime) === null || _q === void 0 ? void 0 : _q.inputs) === null || _r === void 0 ? void 0 : _r.description) || "";
        ctx.value = value;
        return value;
    }),
    description: "Description of model",
    typeSpec: "Type.Branch.Text"
};
const field_initValue = {
    key: "initValue",
    requires: ["field.key"],
    input: "optional",
    optional: true,
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _s, _t, _u, _v, _w;
        let value;
        if (typeof ctx.value !== "undefined")
            value = ctx.value;
        else if (typeof ((_t = (_s = ctx.runtime) === null || _s === void 0 ? void 0 : _s.inputs) === null || _t === void 0 ? void 0 : _t.initValue) !== "undefined")
            value = ctx.runtime.inputs.initValue;
        else if (typeof ((_u = ctx.parsed) === null || _u === void 0 ? void 0 : _u.parsedInitialValue) !== "undefined")
            value = ctx.parsed.parsedInitialValue;
        else {
            if ((_w = (_v = ctx.runtime) === null || _v === void 0 ? void 0 : _v.parentAcknowledgement) === null || _w === void 0 ? void 0 : _w.instance) {
                const instance = ctx.runtime.parentAcknowledgement.instance;
                const property = Object.getOwnPropertyDescriptor(instance, ctx.aspect.key);
                if (typeof (property === null || property === void 0 ? void 0 : property.value) !== "undefined") {
                    value = property.value;
                }
            }
        }
        ctx.value = value;
        return value;
    }),
    description: "init value of the field if no user input provided",
    typeSpec: "any"
};
const field_hasInitValue = {
    key: "hasInitValue",
    requires: ["field.key", "@initValue"],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        if (typeof ctx.aspect.initValue == "undefined") {
            ctx.value = false;
            return false;
        }
        else {
            ctx.value = true;
            return true;
        }
    }),
    description: "If init value is provided, knowledge default to user while the value it self is for implementer only",
    typeSpec: "any"
};
const field_default = {
    key: "default",
    requires: ["field.key"],
    input: "optional",
    optional: true,
    knowledge: knowledge_1.KnowledgeScope.User,
    description: "Default value of the field if no user input provided",
    typeSpec: "any"
};
const field_meta = {
    key: "meta",
    requires: ["field.key"],
    input: "optional",
    optional: true,
    knowledge: knowledge_1.KnowledgeScope.User,
    description: "Meta is restriction or annotation to the fields to provide validation or intuitive UI by the implementer",
    typeSpec: "{[key:string]:any}"
};
const field_dependencies = {
    key: "dependencies",
    input: "none",
    requires: ["@generate", "@referenceExplain", "field.modelUniqueName", "field.key", "#autoGenerateField"],
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (context) => __awaiter(void 0, void 0, void 0, function* () {
        var _x, _y, _z;
        let value = context.value;
        if (!Array.isArray(value) && context.parsed) {
            const references = ((_x = context.parsed) === null || _x === void 0 ? void 0 : _x.functionContentIdentifierReferences) || [];
            const deps = [];
            const fields = context.context.findAspects("field", {
                modelUniqueName: context.aspect.modelUniqueName
            });
            const fieldKeys = fields.map(field => field.key);
            const key = context.aspect.key;
            for (let path of references) {
                const parts = path.split(".");
                const dep = parts[1];
                if (parts[0] == "this" && fieldKeys.includes(dep) && dep !== key) {
                    if (!deps.includes(parts[1])) {
                        deps.push(parts[1]);
                    }
                }
            }
            value = deps;
            if ((_y = context.aspect.referenceExplain) === null || _y === void 0 ? void 0 : _y.innerRoot) {
                if (!deps.includes((_z = context.aspect.referenceExplain) === null || _z === void 0 ? void 0 : _z.innerRoot)) {
                    deps.push(context.aspect.referenceExplain.innerRoot);
                }
            }
        }
        context.value = value;
        return value;
    }),
    description: `Field is referencing to another value.
Reference, two syntax
1. Outter: "{{ModelUniqueName}}.{{field}}" => referencing a specific kind of model's field. (which can be dereferenced latter)
2. Inner "{{outterReferencedField}}.$.{{field}}<...$.field recursively>" => dereference the outter field recursively to certain field.`,
    typeSpec: "string[]"
};
const field_reference = {
    key: "reference",
    input: "optional",
    requires: ["@key", "field.uniqueName", "@tsTypeLiteral", "model.uniqueName", "#autoGenerateField"],
    optional: true,
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (context) => __awaiter(void 0, void 0, void 0, function* () {
        var _0, _1;
        let value = context.value || ((_1 = (_0 = context.runtime) === null || _0 === void 0 ? void 0 : _0.inputs) === null || _1 === void 0 ? void 0 : _1.reference);
        if (value) {
            context.value = value;
            return value;
        }
        const reference = reference_1.Reference.referenceFromTypeLiteral(context.aspect.tsTypeLiteral);
        if (reference) {
            // validate it
            const parsed = reference_1.Reference.parse(reference);
            const target = context.context.findAspect("model", { uniqueName: parsed.typeModelUniqueName });
            if (!target) {
                console.error(context.context.findAspects("model", {}).map(item => item.uniqueName));
                context.error(`Literal type as reference model not found ${context.aspect.tsTypeLiteral}=>${reference}(${parsed.typeModelUniqueName})`);
            }
            value = reference;
            context.value = value;
        }
        if (!value)
            return;
        // [TODO] maybe we should check the reference more strictly
        if (typeof value !== "string") {
            context.error(`Invalid reference`);
        }
        context.value = value;
        return value;
    }),
    description: `Field is referencing to another value.
Reference, two syntax
1. Outter: "{{ModelUniqueName}}.{{field}}" => referencing a specific kind of model's field. (which can be dereferenced latter)
2. Inner "{{outterReferencedField}}.$.{{field}}<...$.field recursively>" => dereference the outter field recursively to certain field.`,
    typeSpec: "string"
};
const field_referenceExplain = {
    key: "referenceExplain",
    input: "none",
    optional: true,
    requires: [
        "model.uniqueName",
        "field.key",
        "field.reference",
        "field.modelUniqueName",
        "field.type",
        "field.enums",
        "field.immutable",
        "field.tsTypeLiteral",
        "field.optional",
        "field.knowledge",
        "field.access",
    ],
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (context) => __awaiter(void 0, void 0, void 0, function* () {
        let value = context.value || null;
        if (value) {
            context.value = value;
            return value;
        }
        if (!context.aspect.reference) {
            context.value = value;
            return value;
        }
        const derive = new implementDeriveLogic_1.ImplementDeriveLogic(context.context);
        const model = context.context.findAspect("model", {
            uniqueName: context.aspect.modelUniqueName
        });
        const field = context.aspect;
        const result = yield derive.implementDerive(model, field);
        value = result.referenceExplain;
        context.value = value;
        return value;
    }),
    description: `Referencing detail explained`,
    typeSpec: `Type.Branch.Spec.ReferenceExplain`
};
const field_tsTypeLiteral = {
    key: "tsTypeLiteral",
    input: "optional",
    requires: ["@enums", "@name", "@uniqueName"],
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (context) => __awaiter(void 0, void 0, void 0, function* () {
        var _2, _3;
        if (context.value)
            return context.value;
        if (context.parsed) {
            let value = ((_2 = context.parsed.parsedType) === null || _2 === void 0 ? void 0 : _2.value) || ((_3 = context.parsed.parsedType) === null || _3 === void 0 ? void 0 : _3.return);
            if (value) {
                const promiseReg = /Promise<(.*)>/;
                const match = value.match(promiseReg);
                if (match) {
                    value = match[1];
                }
            }
            else {
                context.error(`Field ${context.aspect.name} missing explicit ts type specification`);
            }
            context.value = value;
            if (value == "string" && context.aspect.enums) {
                const names = Object.keys(context.aspect.enums);
                const values = names.map(name => context.aspect.enums[name]);
                context.value = values.map(v => JSON.stringify(v)).join(" | ");
            }
            return context.value;
        }
        if (context.aspect.enums) {
            const names = Object.keys(context.aspect.enums);
            const values = names.map(name => context.aspect.enums[name]);
            context.value = values.map(v => JSON.stringify(v)).join(" | ");
            return context.value;
        }
        context.error(`Field missing explicit ts type specification`);
    }),
    description: `Type specification of the field of the typescript definination`,
    typeSpec: `string`
};
const field_readProtect = codex_1.Codex.makeOptionalBooleanPropertyDefinition("readProtect", {
    description: `Field will be wiped out when get/query. To get the raw value, try using the raw repository apis`,
});
const field_immutable = codex_1.Codex.makeOptionalBooleanPropertyDefinition("immutable", {
    description: `field can't be modified (can specify with typescript keyword "readonly" when annotating)`,
    annotate(ctx) {
        var _a, _b;
        if ((_b = (_a = ctx.parsed) === null || _a === void 0 ? void 0 : _a.modifiers) === null || _b === void 0 ? void 0 : _b.includes("readonly"))
            return true;
    }
});
const field_availability = {
    key: "availability",
    requires: ["@reference", "@referenceExplain"],
    input: "optional",
    knowledge: knowledge_1.KnowledgeScope.User,
    enums: ["store", "transient", "virtual", "input", "auto"],
    make(ctx) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            let value = ctx.value || ((_b = (_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b.availability);
            if (value) {
                ctx.value = value;
                return value;
            }
            if (((_c = ctx.runtime) === null || _c === void 0 ? void 0 : _c.kind) == "getter") {
                value = "virtual";
            }
            if (!value && ctx.aspect.reference) {
                if (ctx.aspect.referenceExplain.innerRoot) {
                    value = "auto";
                }
                else {
                    value = "store";
                }
            }
            if (!value) {
                value = "store";
            }
            if (!this.enums.includes(value)) {
                ctx.error(`Invali value for availability must be one of: ${JSON.stringify(this.enums)}`);
            }
            return value;
        });
    },
    description: `The 'store' field are persisted and always available.
The 'transient' are only available during the create/update flow internaly, and will not be part of the data type.
The 'virtual' are getters and calculated on the fly for and will be serialized when transfer, we initialize a getter of the field to create an virtual field.
The 'auto' are field generated by requirements such as generate/reference, and accept no input but will be persisted
The 'input' are field accept input but will not be persisted, only used as reference value for  runtime creation/update of other fields`,
};
const field_designer = {
    key: "designer",
    requires: [],
    input: "optional",
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _4, _5;
        let value = ctx.value || ((_5 = (_4 = ctx.runtime) === null || _4 === void 0 ? void 0 : _4.inputs) === null || _5 === void 0 ? void 0 : _5.designer) || "designer";
        ctx.value = value;
        return value;
    }),
    description: `Who designs the field:
1. designer: programmer designed it
2. conventional: field is generated by convention like auto id / createdAt / updatedAt.
3. flow: field is generated by flow to fill some auto requirements.
4. "packageName" like @branch-ts/core: if designed by specific package`,
    typeSpec: "string",
};
const field_access = {
    key: "access",
    requires: [],
    input: "optional",
    enums: ["public", "protected", "private"],
    knowledge: knowledge_1.KnowledgeScope.User,
    make(context) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const value = context.value || ((_b = (_a = context.runtime) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b.access) || ((_c = context.parsed) === null || _c === void 0 ? void 0 : _c.modifiers.find(item => this.enums.includes(item))) || "public";
            context.value = value;
            return value;
        });
    },
    description: `
public is readable and writable(if mutable) by authorized access
protected field can be readable by UI but not writable by UI (still writable by program).
private field can't won't be able to access through perception(remote)

NOTE: "private" restriction is enforced, while public and protected are integrited by client side at will.
`,
};
const field_enums = {
    key: "enums",
    requires: [],
    input: "optional",
    optional: true,
    knowledge: knowledge_1.KnowledgeScope.User,
    description: `Possible valid name:value of the field `,
    typeSpec: `{ [displayName: string]: any } `
};
const field_sortable = codex_1.Codex.makeOptionalBooleanPropertyDefinition("sortable", {
    knowledge: knowledge_1.KnowledgeScope.User,
    description: `Sortable in frontend and implies a index in database.`,
});
const field_generate = {
    key: "generate",
    input: "none",
    requires: ["@referenceExplain", "@availability", "@name"],
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _6, _7, _8;
        if (ctx.value)
            return ctx.value;
        let value = (_6 = ctx.runtime) === null || _6 === void 0 ? void 0 : _6.value;
        if (ctx.aspect.availability === "virtual" && ((_8 = (_7 = ctx.runtime) === null || _7 === void 0 ? void 0 : _7.value) === null || _8 === void 0 ? void 0 : _8.length) !== 0) {
            ctx.error(`Virtual field getter ${ctx.aspect.name} can't accept arguments`);
        }
        ctx.value = value;
        return ctx.value;
    }),
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    description: `May be an async generate function to provide of the field`,
    typeSpec: `Type.Branch.Spec.FieldGenerator`
};
const field_hasGenerate = {
    key: "hasGenerate",
    input: "none",
    requires: ["@generate"],
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        const value = !!ctx.aspect.generate;
        ctx.value = value;
        return ctx.value;
    }),
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    description: `Has generate, in case we miss the generate function, we still have this field to indicate it`,
    typeSpec: `boolean`
};
const field_knowledge = {
    key: "knowledge",
    input: "optional",
    requires: [],
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    description: `Whatever we would like the ui to know about it`,
    typeSpec: `Type.Branch.Spec.KnowledgeScope`
};
const onBeforeSecured_ensureConventionalFields = (context) => __awaiter(void 0, void 0, void 0, function* () {
    const models = context.getAspects("model");
    for (let model of models) {
    }
});
const onBeforeSecured_calculateEnumsByUnionTypeLiterals = (context) => __awaiter(void 0, void 0, void 0, function* () {
    const fields = context.getAspects("field");
    for (let field of fields) {
        if (field.tsTypeLiteral && !field.enums) {
            const unions = parseTsUnions(field.tsTypeLiteral);
            if (unions.length > 0) {
                field.enums = {};
                for (let value of unions) {
                    field.enums[value] = value;
                }
                if (field.type == "unknown") {
                    field.type = "enum";
                }
            }
        }
    }
});
const onBeforeSecured_calculateModelScope = (context) => __awaiter(void 0, void 0, void 0, function* () {
    var _9;
    const models = context.getAspects("model");
    const cal = new scope_1.ScopeCalculator(models);
    for (let model of models) {
        const fields = context.findAspects("field", {
            modelUniqueName: model.uniqueName
        });
        for (let field of fields) {
            if (((_9 = field.referenceExplain) === null || _9 === void 0 ? void 0 : _9.kind) == "scope") {
                const refInfo = reference_1.Reference.parse(field.reference, model);
                const expectedKey = Leaf.Util.uncapitalize(refInfo.typeModel) + "Id";
                if (expectedKey != field.key) {
                    throw new Error(`Invalid scope reference name:Model ${model.uniqueName}.${field.key} 's reference ${field.reference} should have key ${expectedKey}`);
                }
                const parentName = context.builder.codex.namespace.ensureUniqueName(refInfo.typeModelUniqueName, model.namespace);
                cal.addScope(parentName, model.uniqueName);
            }
        }
    }
    const chains = cal.calculate();
    for (let model of cal.candidates) {
        model.scopes = chains.filter(item => item.includes(model.uniqueName));
    }
});
exports.FieldAspectDescriptor = {
    name: "field",
    defaultKnowledge: knowledge_1.KnowledgeScope.User,
    parents: ["model"],
    parentChildKey: "fields",
    parentUniqueNameKey: "modelUniqueName",
    style: "property",
    properties: {
        modelUniqueName: field_modelUniqueName,
        key: field_key,
        type: field_type,
        textSearch: field_textSearch,
        displayName: field_displayName,
        optional: field_optional,
        unique: field_unique,
        description: field_description,
        dependencies: field_dependencies,
        reference: field_reference,
        referenceExplain: field_referenceExplain,
        availability: field_availability,
        tsTypeLiteral: field_tsTypeLiteral,
        readProtect: field_readProtect,
        immutable: field_immutable,
        designer: field_designer,
        access: field_access,
        enums: field_enums,
        sortable: field_sortable,
        generate: field_generate,
        hasGenerate: field_hasGenerate,
        knowledge: field_knowledge,
        initValue: field_initValue,
        hasInitValue: field_hasInitValue,
        default: field_default,
        meta: field_meta,
    },
    onBeforeSecured: [
        onBeforeSecured_ensureConventionalFields,
        onBeforeSecured_calculateEnumsByUnionTypeLiterals,
        onBeforeSecured_calculateModelScope,
    ],
    participations: [
        autoGenerateField_1.AutoGenerateField,
        autoGenerateTime_1.AutoGenerateTime,
        autoGenerateCreator_1.AutoGenerateCreator,
        autoGenerateId_1.AutoGenerateId,
        autoSingleId_1.AutoSingleId,
    ],
    fastOption: "displayName"
};
//# sourceMappingURL=aspect.field.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateCreator.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateCreator.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoGenerateCreator = void 0;
const knowledge_1 = __webpack_require__(/*! ../../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const errors_1 = __webpack_require__(/*! ../../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const autoGenerateField_1 = __webpack_require__(/*! ./autoGenerateField */ "./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateField.js");
exports.AutoGenerateCreator = {
    name: "autoGenerateCreator",
    requires: ["field.key", "model.uniqueName", "model.enable", "model.namespace"],
    todo(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const models = context.getAspects("model");
            for (let model of models) {
                if (!model.enable || !model.enable.includes("AutoCreator")) {
                    continue;
                }
                let creatorIdField = context.findAspect("field", {
                    modelUniqueName: model.uniqueName,
                    key: "creatorId",
                });
                if (creatorIdField && creatorIdField.designer !== "convention") {
                    throw new errors_1.Errors.DesignError(`Model ${model.uniqueName} already has creatorId field, please remove it or disable AutoCreator feature`);
                }
                creatorIdField = creatorIdField || {
                    namespace: model.namespace,
                    aspectName: "field",
                    uniqueName: `${model.uniqueName}.creatorId`,
                    name: "creatorId",
                    knowledge: knowledge_1.KnowledgeScope.User,
                    modelUniqueName: model.uniqueName,
                    key: "creatorId",
                    type: "userId",
                    optional: false,
                    description: `Creator Id of the field`,
                    tsTypeLiteral: "Type.Branch.Timestamp",
                    unique: false,
                    readProtect: false,
                    textSearch: false,
                    availability: "auto",
                    dependencies: [],
                    designer: "convention",
                    immutable: true,
                    sortable: true,
                    access: "public",
                    generate: null,
                    hasGenerate: false,
                    hasInitValue: false,
                };
                creatorIdField.generate = function (context) {
                    if (context.procedure == "create") {
                        const id = Leaf.Util.getObjectValue(context.environment, "session.userId");
                        return id;
                    }
                    return context.originNodeValue;
                };
                creatorIdField.hasGenerate = true;
                context.addFinalAspect(creatorIdField);
                let creatorNameField = context.findAspect("field", {
                    modelUniqueName: model.uniqueName,
                    key: "creatorName",
                });
                if (creatorNameField && creatorNameField.designer !== "convention") {
                    throw new Error(`AutoCreator feature conflicts with ${model.uniqueName}.creatorName, please remove the field first`);
                }
                creatorNameField = creatorNameField || {
                    namespace: model.namespace,
                    aspectName: "field",
                    uniqueName: `${model.uniqueName}.creatorName`,
                    name: "creatorName",
                    dependencies: [],
                    knowledge: knowledge_1.KnowledgeScope.User,
                    modelUniqueName: model.uniqueName,
                    key: "creatorName",
                    type: "userId",
                    optional: true,
                    description: `Creator Id of the field`,
                    tsTypeLiteral: "Type.Branch.Timestamp",
                    unique: false,
                    readProtect: false,
                    textSearch: false,
                    availability: "auto",
                    designer: "convention",
                    immutable: true,
                    sortable: true,
                    access: "public",
                    generate: null,
                    hasGenerate: false,
                    hasInitValue: false,
                };
                creatorNameField.generate = function (context) {
                    if (context.procedure == "create") {
                        const name = Leaf.Util.getObjectValue(context.environment, "session.username");
                        return name;
                    }
                    return context.originNodeValue;
                };
                creatorNameField.hasGenerate = true;
                context.addFinalAspect(creatorNameField);
            }
        });
    }
};
autoGenerateField_1.AutoGenerateField.requires.push(`#${exports.AutoGenerateCreator.name}`);
//# sourceMappingURL=autoGenerateCreator.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateField.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateField.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoGenerateField = void 0;
exports.AutoGenerateField = {
    name: "autoGenerateField",
    requires: [],
};
//# sourceMappingURL=autoGenerateField.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateId.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateId.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoGenerateId = void 0;
const knowledge_1 = __webpack_require__(/*! ../../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const log_1 = __webpack_require__(/*! ../../log */ "./node_modules/@branch-ts/core/src/log.js");
const autoGenerateField_1 = __webpack_require__(/*! ./autoGenerateField */ "./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateField.js");
exports.AutoGenerateId = {
    name: "autoGenerateId",
    requires: ["field.key"],
    todo(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const models = context.getAspects("model");
            for (let model of models) {
                let idFieldOfModel = context.findAspect("field", {
                    modelUniqueName: model.uniqueName,
                    key: "id",
                });
                if (!idFieldOfModel) {
                    const op = {
                        namespace: model.namespace,
                        dependencies: [],
                        aspectName: "field",
                        uniqueName: `${model.uniqueName}.id`,
                        name: "id",
                        knowledge: knowledge_1.KnowledgeScope.User,
                        modelUniqueName: model.uniqueName,
                        key: "id",
                        type: "id",
                        optional: false,
                        unique: true,
                        description: `Built-in Id of ${model.uniqueName}`,
                        tsTypeLiteral: "string",
                        availability: "auto",
                        immutable: true,
                        access: "public",
                        readProtect: false,
                        designer: "convention",
                        sortable: false,
                        textSearch: false,
                        generate: function (context) {
                            return context.originNodeValue || context.codex.generateId();
                        },
                        hasGenerate: true,
                        hasInitValue: false,
                    };
                    context.addFinalAspect(op);
                    idFieldOfModel = op;
                }
                else {
                    if (idFieldOfModel.designer == "convention") {
                        idFieldOfModel.generate = function (context) {
                            return context.originNodeValue || context.codex.generateId();
                        };
                        idFieldOfModel.hasGenerate = true;
                    }
                    if (!idFieldOfModel.unique) {
                        log_1.Logger.warn(`id field of model ${model.uniqueName} is not unique, we will make it unique`);
                        idFieldOfModel.unique = true;
                    }
                }
            }
        });
    }
};
autoGenerateField_1.AutoGenerateField.requires.push(`#${exports.AutoGenerateId.name}`);
//# sourceMappingURL=autoGenerateId.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateTime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateTime.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoGenerateTime = void 0;
const knowledge_1 = __webpack_require__(/*! ../../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const autoGenerateField_1 = __webpack_require__(/*! ./autoGenerateField */ "./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateField.js");
exports.AutoGenerateTime = {
    name: "autoGenerateTime",
    requires: ["field.key", "model.uniqueName", "model.enable"],
    todo(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const models = context.getAspects("model");
            for (let model of models) {
                const times = ["createdAt", "updatedAt"];
                for (let timeType of times) {
                    let timeTypeOfModel = context.findAspect("field", {
                        modelUniqueName: model.uniqueName,
                        key: timeType
                    });
                    if (!timeTypeOfModel) {
                        const op = {
                            namespace: model.namespace,
                            aspectName: "field",
                            uniqueName: `${model.uniqueName}.${timeType}`,
                            dependencies: [],
                            name: timeType,
                            knowledge: knowledge_1.KnowledgeScope.User,
                            modelUniqueName: model.uniqueName,
                            key: timeType,
                            type: "timestamp",
                            optional: true,
                            description: `Built-in ${timeType} of ${model.uniqueName}`,
                            tsTypeLiteral: "Type.Branch.Timestamp",
                            unique: false,
                            readProtect: false,
                            textSearch: false,
                            availability: "auto",
                            designer: "convention",
                            immutable: true,
                            sortable: true,
                            access: "public",
                            generate: null,
                            hasGenerate: false,
                            hasInitValue: false,
                        };
                        if (timeType === "createdAt") {
                            op.generate = function (context) {
                                if (context.procedure == "create")
                                    return Date.now();
                                return context.originNodeValue;
                            };
                            op.hasGenerate = true;
                            op.immutable = true;
                        }
                        else if (timeType == "updatedAt") {
                            op.generate = function (context) {
                                if (context.procedure == "create") {
                                    return Date.now();
                                }
                                if (context.procedure == "update") {
                                    return Date.now();
                                }
                                return context.originNodeValue || Date.now();
                            };
                            op.immutable = false;
                            op.hasGenerate = true;
                        }
                        context.addFinalAspect(op);
                    }
                    else {
                        if (timeTypeOfModel.designer == "convention") {
                            if (timeType === "createdAt") {
                                timeTypeOfModel.generate = function (context) {
                                    if (context.procedure == "create")
                                        return Date.now();
                                    return context.originNodeValue;
                                };
                                timeTypeOfModel.immutable = true;
                            }
                            else if (timeType == "updatedAt") {
                                timeTypeOfModel.generate = function (context) {
                                    return Date.now();
                                };
                                timeTypeOfModel.immutable = false;
                            }
                        }
                    }
                }
            }
        });
    }
};
autoGenerateField_1.AutoGenerateField.requires.push(`#${exports.AutoGenerateTime.name}`);
//# sourceMappingURL=autoGenerateTime.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.field/autoSingleId.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.field/autoSingleId.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AutoSingleId = void 0;
const autoGenerateField_1 = __webpack_require__(/*! ./autoGenerateField */ "./node_modules/@branch-ts/core/src/design/aspect.field/autoGenerateField.js");
exports.AutoSingleId = {
    name: "autoGenerateSingleId",
    requires: ["field.key", "model.uniqueName", "#autoGenerateId"],
    todo(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const models = context.getAspects("model");
            for (let model of models) {
                if (!!model.single) {
                    // id field of single model is forced to have value of ${model.uniqueName}
                    let idFieldOfModel = context.findAspect("field", {
                        modelUniqueName: model.uniqueName,
                        key: "id",
                    });
                    idFieldOfModel.generate = function () {
                        return model.uniqueName;
                    };
                }
            }
        });
    }
};
autoGenerateField_1.AutoGenerateField.requires.push(`#${exports.AutoSingleId.name}`);
//# sourceMappingURL=autoSingleId.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.field/implementDeriveLogic.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.field/implementDeriveLogic.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementDeriveLogic = void 0;
const errors_1 = __webpack_require__(/*! ../../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const Const = __importStar(__webpack_require__(/*! ../../const */ "./node_modules/@branch-ts/core/src/const.js"));
const reference_1 = __webpack_require__(/*! ../reference */ "./node_modules/@branch-ts/core/src/design/reference.js");
const knowledge_1 = __webpack_require__(/*! ../../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const log_1 = __webpack_require__(/*! ../../log */ "./node_modules/@branch-ts/core/src/log.js");
// value
// Base:              ["targetName"]  Contact
// Standard(Result):  [] "targetName" Contact  {ref:targetName}
//                        <= v <= Contact.identityId_deref_endpointName
// Unbox:             [identityId,$,endpointName] "" Contact {ref:identityId.$.endpointName}
//                        <= v <= Contact.identityId_deref.endpointName
// Normalize:         [identityId.$] <= "endpointName" Contact {ref:identityId.$.endpointName}
//                        <= v <= Contact.identityId_deref
// Derefed:           [Identity] <= "endpointName" Contact {ref:identityId.$.endpointName}
// Rebase:            [endpointName] <= Identity
// Rebase:            [] <= "endpointName" Identity {ref:endpointName}
// FieldExpand:       [endpointId,$,name] "" Identity
// Conversion:        [endpointId,$] <= "name" Identity
// [Endpoint] <= "name" Identity
// [] <= "name" Endpoint
// Done: base route is empty, and tail prop of context don't have reference
// [Contact.targetName]
// [targetName] "" Contact
// [] targetName Contact
// [identityId.$.endpointName]
class ImplementDeriveLogic {
    typeIsModel(name) {
        return /[A-Z]/.test(name[0]) && name.split(".")[0] !== "Type";
    }
    typeIsTypeDef(name) {
        // NOTE: we use Type.XXX.XXX literal to identify it's an customized type instead of a model
        // though generated model in typescript might be referer to Type.{Namespace}.{Model} which corresponding to
        // type of {Namespace}.{Model} (without "Type.") inside design/branch system
        return name.split(".")[0] == "Type";
    }
    constructor(context) {
        this.context = context;
        this.codex = this.context.builder.codex;
        this.solveStack = [];
    }
    uniqueNameOfField(field) {
        return `${field.modelUniqueName}.${field.key} `;
    }
    implementDerive(root, field) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!field.type && !field.reference) {
                throw new errors_1.Errors.DesignError(`Invalid field missing reference and type ${this.uniqueNameOfField(field)} `);
            }
            // don't duplicate derived field
            if (field.availability == "transient")
                return field;
            if (!field.reference)
                return field;
            field.referenceExplain = field.referenceExplain || {};
            const resolved = this.resolveReference(root, field.reference);
            if (!resolved.tail) {
                // Tricky reminder here
                if (field.availability !== "transient") {
                    throw new Error(`${field.reference} resolve to an model which is not supported`);
                }
                else {
                    // Derived field can be resolved to Model for the moment.
                }
            }
            const finalField = this.context.findAspect("field", {
                modelUniqueName: resolved.modelUniqueName,
                key: resolved.tail
            });
            if (!finalField) {
                if (resolved.tail === "id") {
                    // it's OK for id
                }
                else {
                    throw new errors_1.Errors.RuntimeError(`Referencing to unknown target ${field.reference}`);
                }
            }
            else {
                if (!field.type || field.type == "any" || field.type == "unknown" || field.type == "auto")
                    field.type = finalField.type;
                const inheritProps = ["enums", "immutable"];
                for (let prop of inheritProps) {
                    if (typeof field[prop] == "undefined" && finalField[prop]) {
                        field[prop] = finalField[prop];
                    }
                }
                if (typeof field.enums == "undefined" && finalField.enums) {
                    field.enums = finalField.enums;
                }
            }
            if (field.type == "id") {
                field.type = "reference";
            }
            const refInfo = reference_1.Reference.parse(field.reference, root);
            if (typeof ((_a = field.referenceExplain) === null || _a === void 0 ? void 0 : _a.kind) == "undefined") {
                if (refInfo.scope) {
                    field.referenceExplain.kind = "scope";
                }
                else {
                    field.referenceExplain.kind = "application";
                }
            }
            if (refInfo.kind == "value") {
                field.referenceExplain.innerRoot = field.referenceExplain.innerRoot || refInfo.routes[0];
            }
            else {
                if (refInfo.routes[refInfo.routes.length - 1] == "id") {
                    field.referenceExplain.referencingModelUniqueName = refInfo.typeModelUniqueName;
                }
            }
            // Used to decide if we are a slave property,
            // By slave, it means it's decided by other field
            if ((!field.tsTypeLiteral || field.tsTypeLiteral == "Type.Branch.Auto") && (finalField === null || finalField === void 0 ? void 0 : finalField.tsTypeLiteral)) {
                field.tsTypeLiteral = finalField.tsTypeLiteral;
            }
            const localSharedHiddenFields = resolved.sharedHiddenFields.filter(ref => {
                if (ref.modelUniqueName == root.uniqueName) {
                    return true;
                }
                return false;
            });
            field.referenceExplain.referencingValueFields = localSharedHiddenFields.map(ref => ref.key);
            if (refInfo.kind !== "value")
                return field;
            const used = [];
            for (let share of resolved.sharedHiddenFields) {
                const model = this.context.findAspect("model", {
                    uniqueName: share.modelUniqueName
                });
                const dep = this.context.findAspect("field", {
                    modelUniqueName: model.uniqueName,
                    key: share.of
                });
                if (!dep) {
                    throw new errors_1.Errors.DesignError(`${share.key} referencing ${share.of} not exists`);
                }
                let type = null;
                let tsTypeLiteral = null;
                if (share.action == "prop") {
                    if (share.prop) {
                        const targetModelUniqueName = dep.type;
                        const targetModel = this.context.findAspect("model", {
                            uniqueName: dep.type
                        });
                        const targetField = this.context.findAspect("field", {
                            modelUniqueName: targetModel.uniqueName,
                            key: share.prop
                        });
                        if (!targetField) {
                            throw new errors_1.Errors.DesignError(`${share.key} referencing ${share.of}.${share.prop} not eixsts`);
                        }
                        type = targetField.type;
                        tsTypeLiteral = targetField.tsTypeLiteral;
                    }
                    else {
                        type = dep.type;
                        tsTypeLiteral = dep.tsTypeLiteral;
                    }
                }
                else if (share.action == "deref") {
                    type = share.derefModel;
                    tsTypeLiteral = "Type." + share.derefModel;
                }
                let shareField = this.context.findAspect("field", {
                    modelUniqueName: model.uniqueName,
                    key: share.key
                });
                if (!shareField) {
                    const genField = {
                        namespace: model.namespace,
                        aspectName: "field",
                        uniqueName: `${model.uniqueName}.${share.key}`,
                        name: share.key,
                        type: type,
                        key: share.key,
                        knowledge: knowledge_1.KnowledgeScope.Implementer,
                        textSearch: false,
                        optional: dep.optional,
                        unique: false,
                        readProtect: true,
                        access: dep.access,
                        sortable: false,
                        description: `Auto generated by refereing to ${share.of} ${share.action}:${share.prop || share.derefModel} `,
                        reference: share.reference,
                        immutable: dep.immutable,
                        modelUniqueName: share.modelUniqueName,
                        dependencies: [share.of],
                        referenceExplain: {
                            referencingValueFields: used.filter(item => item.modelUniqueName == share.modelUniqueName).map(item => item.key),
                        },
                        availability: "transient",
                        designer: "flow",
                        tsTypeLiteral,
                        generate: null,
                        hasGenerate: true,
                        hasInitValue: false,
                    };
                    this.context.addFinalAspect(genField);
                    if (share.action == "deref") {
                        genField.generate = {
                            action: "valueDereference",
                            field: share.of,
                            model: share.derefModel
                        };
                    }
                    else if (share.action == "prop") {
                        genField.generate = {
                            action: "valueAccess",
                            field: share.of,
                            property: share.prop
                        };
                        if (!share.prop) {
                            throw new Error("none prop");
                        }
                    }
                }
                used.push(share);
            }
            const last = localSharedHiddenFields.pop();
            field.dependencies = [last.key];
            field.generate = {
                action: "valueAccess",
                field: last.key,
                property: null,
            };
            return field;
        });
    }
    resolveReference(root, reference) {
        const anchor = `${root.uniqueName}.${reference} `;
        if (this.solveStack.indexOf(anchor) >= 0) {
            for (let anchor of this.solveStack) {
                log_1.Logger.error("Solving anchor", anchor);
            }
            throw new Error("recursive resolving reference");
        }
        this.solveStack.push(anchor);
        try {
            const refInfo = reference_1.Reference.parse(reference, root);
            if (refInfo.routes.length == 0 && !refInfo.typeModelUniqueName) {
                throw new Error("Invalid reference");
            }
            let context = {
                modelUniqueName: root.uniqueName,
                tail: null,
                base: refInfo.routes.slice(),
                sharedHiddenFields: []
            };
            if (refInfo.typeModelUniqueName) {
                context.base.unshift(refInfo.typeModelUniqueName);
            }
            while (true) {
                const model = this.context.findAspect("model", {
                    uniqueName: context.modelUniqueName
                });
                // Fin      1. base:0 tail:0
                // Fin'     2. base:0 tail:+
                //              2.1 tail no ref
                //              2.2 tail has ref          => Recursive to 3.
                // Start:   3. base:+ tail:0              => tail ref   => 4.
                //          4. base:+ tail:+
                //              4.1 rebase to id          => tail==$ and =>2. or Error
                //              4.2 rebase to base:0       => base:0 =>`Model rebase` and =>2.
                if (context.base.length == 0) {
                    if (!context.tail) {
                        // 1. => Fin
                        return context;
                    }
                    else {
                        if (this.codex.namespace.isNamespaceLike(context.tail)) {
                            context.modelUniqueName = context.tail;
                            context.tail = null;
                            continue;
                        }
                        const model = this.context.findAspect("model", {
                            uniqueName: context.modelUniqueName
                        });
                        if (!model) {
                            throw new Error(`During ${root.uniqueName}=>${reference}: ${context.modelUniqueName} not found`);
                        }
                        const field = this.context.findAspect("field", {
                            modelUniqueName: context.modelUniqueName,
                            key: context.tail,
                        });
                        if (!field) {
                            // id is not ready for some model that doesn't declare id specifically
                            if (context.tail === "id") {
                                return context;
                            }
                            if (context.tail == "$") {
                                throw new Error(`Invalid reference ${reference}, do deref model.id, not model.`);
                            }
                            throw new Error(`Encounter invalid field ${context.tail} resolving ${reference} `);
                        }
                        if (field.reference) {
                            // 2.2 => 3
                            const next = this.resolveReference(model, field.reference);
                            context = {
                                modelUniqueName: next.modelUniqueName,
                                tail: next.tail,
                                base: next.base,
                                sharedHiddenFields: [...context.sharedHiddenFields, ...next.sharedHiddenFields]
                            };
                            return context;
                        }
                        else {
                            // 2.1 => Fin
                            return context;
                        }
                    }
                }
                else {
                    if (!context.tail) {
                        const tail = context.base.pop();
                        // 3. => 4.
                        context.tail = tail;
                        continue;
                    }
                    else {
                        // do a rebase
                        const rebase = this.resolveReference(model, context.base.join("."));
                        if (!rebase.tail) {
                            const ref = context.base.join(".") + "." + context.tail;
                            const key = reference_1.Reference.toSharedKey(ref);
                            if (context.base.length > 0 && refInfo.kind == "value") {
                                context.sharedHiddenFields.unshift({
                                    modelUniqueName: context.modelUniqueName,
                                    key,
                                    reference: ref,
                                    action: "prop",
                                    of: reference_1.Reference.toSharedKey(context.base),
                                    prop: context.tail,
                                });
                            }
                            context.sharedHiddenFields.unshift(...rebase.sharedHiddenFields);
                            context.modelUniqueName = rebase.modelUniqueName;
                            context.base = [];
                            continue;
                        }
                        else {
                            if (rebase.tail == "id" && context.tail == "$") {
                                // do a deref
                                const ref = context.base.join(".") + ".$";
                                context.sharedHiddenFields.unshift({
                                    modelUniqueName: context.modelUniqueName,
                                    key: reference_1.Reference.toSharedKey(context.base) + "_deref",
                                    action: "deref",
                                    of: reference_1.Reference.toSharedKey(context.base),
                                    derefModel: rebase.modelUniqueName,
                                    reference: ref,
                                });
                                context.modelUniqueName = rebase.modelUniqueName;
                                context.tail = null;
                                context.base = [];
                                context.sharedHiddenFields.unshift(...rebase.sharedHiddenFields);
                            }
                            else if (rebase.tail !== "id") {
                                throw new errors_1.Errors.DesignError(`Reference ${root.uniqueName}=>${reference} deref not-id ? `);
                            }
                            else if (context.tail != "$") {
                                throw new errors_1.Errors.DesignError(`Reference ${root.uniqueName}=>${reference} access prop of another field, which is not allowed.`);
                            }
                            continue;
                        }
                    }
                }
            }
        }
        finally {
            this.solveStack.pop();
        }
    }
    getModelUniqueNameFromIdReference(reference, namespace = null) {
        const parts = reference.split(".");
        const id = parts.pop();
        if (id !== "id") {
            if (/[A-Z]/.test(id[0])) {
                parts.push(id);
            }
            else {
                throw new errors_1.Errors.DesignError(`Invalid id reference: ${reference} `);
            }
        }
        if (parts.length == 1) {
            parts.unshift(namespace || Const.DefaultNamespace);
        }
        return parts.join(".");
    }
}
exports.ImplementDeriveLogic = ImplementDeriveLogic;
//# sourceMappingURL=implementDeriveLogic.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.group.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.group.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupAspectDescriptor = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const Const = __importStar(__webpack_require__(/*! ../const */ "./node_modules/@branch-ts/core/src/const.js"));
const group_1 = __webpack_require__(/*! ../group */ "./node_modules/@branch-ts/core/src/group.js");
const parameterRequirement_1 = __webpack_require__(/*! ./parameterRequirement */ "./node_modules/@branch-ts/core/src/design/parameterRequirement.js");
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const log_1 = __webpack_require__(/*! ../log */ "./node_modules/@branch-ts/core/src/log.js");
const group_name = {
    key: "name",
    input: "none",
    requires: ["model.uniqueName"],
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const value = ctx.value || ((_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.name);
        const reg = /^[a-z][a-zA-Z0-9]*Group$/;
        if (!reg.test(value)) {
            throw new errors_1.Errors.DesignError(`group must uncapitalized and contains only alphabets, and should always end with "Group"`);
        }
        ctx.value = value;
        return ctx.value;
    }),
    description: "Name of the group",
    typeSpec: "Type.Branch.Name.GroupName"
};
const group_modelUniqueName = {
    key: "modelUniqueName",
    requires: ["model.uniqueName", "@name"],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        const value = ctx.value || ctx.runtime.parentAcknowledgement.uniqueName;
        ctx.value = value;
        return value;
    }),
    description: "ModelUniqueName the group belongs to",
    typeSpec: "Type.Branch.Name.ModelUniqueName"
};
const group_hardRestrictionTemplate = {
    key: "hardRestrictionTemplate",
    requires: [],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _b, _c, _d;
        let value = ctx.value || ((_b = ctx.runtime) === null || _b === void 0 ? void 0 : _b.parentAcknowledgement.instance[(_c = ctx.runtime) === null || _c === void 0 ? void 0 : _c.name]);
        if (value === null || value === void 0 ? void 0 : value.getTemplate) {
            value = value.getTemplate();
        }
        if (value && !value.ors) {
            throw new errors_1.Errors.DesignError(`${(_d = ctx.runtime) === null || _d === void 0 ? void 0 : _d.src} not a valid group restriction`);
        }
        ctx.value = value;
        return value;
    }),
    description: "Hard restriction of the group",
    typeSpec: "Type.Criteria.Condition"
};
const group_hardRestrictionRequirements = {
    key: "hardRestrictionRequirements",
    input: "none",
    requires: ["@hardRestrictionTemplate", "@modelUniqueName", "field.key", "field.tsTypeLiteral"],
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        let value = ctx.value;
        if (!value) {
            const fields = {};
            const modelFields = ctx.context.findAspects("field", {
                modelUniqueName: ctx.aspect.modelUniqueName
            });
            modelFields.forEach(field => {
                fields[field.key] = field;
            });
            const requirements = parameterRequirement_1.ParameterRequirements.build({
                fields,
                template: ctx.aspect.hardRestrictionTemplate
            });
            value = requirements.getSpec();
        }
        ctx.value = value;
        return ctx.value;
    }),
    description: "Required hard restriction of the group",
    typeSpec: "Type.Branch.Spec.ParameterRequirements"
};
const group_hardRestrictionRequirementsTypeLiteral = {
    key: "hardRestrictionRequirementsTypeLiteral",
    input: "none",
    requires: ["@hardRestrictionTemplate", "@hardRestrictionRequirements"],
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        let value = ctx.value;
        if (!value) {
            if (!ctx.aspect.hardRestrictionTemplate) {
                value = "null";
            }
            else {
                const fields = {};
                const modelFields = ctx.context.findAspects("field", {
                    modelUniqueName: ctx.aspect.modelUniqueName
                });
                modelFields.forEach(field => {
                    fields[field.key] = field;
                });
                const requirements = parameterRequirement_1.ParameterRequirements.build({
                    fields,
                    template: ctx.aspect.hardRestrictionTemplate
                });
                value = requirements.getRestrictionLiteral();
            }
        }
        ctx.value = value;
        return value;
    }),
    description: "Typescript type definination of the hard restriction requirement",
    typeSpec: "string"
};
const group_disables = {
    key: "disables",
    input: "optional",
    requires: ["@hardRestrictionTemplate", "@hardRestrictionRequirements"],
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        let value = ctx.value;
        if (!Array.isArray(value)) {
            value = [];
        }
        value.forEach(type => {
            var _a;
            if (!Object.keys(group_1.Group.actionKind).includes(type)) {
                if ((_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.src) {
                    log_1.Logger.error(ctx.runtime.src);
                }
                throw new errors_1.Errors.DesignError(`${type} is not avalid GroupActionKind to disable`);
            }
        });
        ctx.value = value;
        return value;
    }),
    description: "Disable certian action kind of the group",
    typeSpec: "Type.Branch.Spec.ResourceActionKind[]"
};
const onBeforeSecured_ensureDefaultGroup = (context) => __awaiter(void 0, void 0, void 0, function* () {
    const models = context.getAspects("model");
    for (let model of models) {
        let defaultGroup = context.findAspect("group", {
            modelUniqueName: model.uniqueName,
            name: Const.DefaultGroupName,
        });
        if (!defaultGroup) {
            const op = {
                aspectName: "group",
                namespace: model.namespace,
                knowledge: knowledge_1.KnowledgeScope.User,
                modelUniqueName: model.uniqueName,
                uniqueName: `${model.uniqueName}.${Const.DefaultGroupName}`,
                name: Const.DefaultGroupName,
                hardRestrictionTemplate: null,
                hardRestrictionRequirements: {},
                hardRestrictionRequirementsTypeLiteral: "null",
                disables: [],
            };
            context.addFinalAspect(op);
        }
    }
});
exports.GroupAspectDescriptor = {
    name: "group",
    defaultKnowledge: knowledge_1.KnowledgeScope.User,
    parents: ["model"],
    parentChildKey: "groups",
    parentUniqueNameKey: "modelUniqueName",
    style: "property",
    properties: {
        name: group_name,
        modelUniqueName: group_modelUniqueName,
        hardRestrictionTemplate: group_hardRestrictionTemplate,
        hardRestrictionRequirements: group_hardRestrictionRequirements,
        hardRestrictionRequirementsTypeLiteral: group_hardRestrictionRequirementsTypeLiteral,
        disables: group_disables,
    },
    onBeforeSecured: [onBeforeSecured_ensureDefaultGroup],
};
//# sourceMappingURL=aspect.group.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.hook.js":
/*!****************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.hook.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HookAspectDescriptor = void 0;
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const hook_1 = __webpack_require__(/*! ../hook */ "./node_modules/@branch-ts/core/src/hook.js");
const util_1 = __webpack_require__(/*! ../util */ "./node_modules/@branch-ts/core/src/util.js");
const hook_model = {
    key: "model",
    requires: ["model.uniqueName"],
    input: "required",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make(ctx) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const value = ctx.value || ((_b = (_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b.model);
            if (!value) {
                return ctx.error("model is required");
            }
            ctx.value = value;
            return value;
        });
    },
    typeSpec: "Type.Branch.Name.ModelUniqueName"
};
const hook_cons = {
    key: "cons",
    requires: [],
    input: "value",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    description: "Class cons of the hook",
    typeSpec: "Constructor<any>"
};
exports.HookAspectDescriptor = {
    name: "hook",
    style: "constructor",
    parents: null,
    parentUniqueNameKey: null,
    autoIncludeInDomain: true,
    defaultKnowledge: knowledge_1.KnowledgeScope.Implementer,
    subClassOf: [hook_1.Hook],
    properties: {
        model: hook_model,
        cons: hook_cons,
    }
};
util_1.Util.markBaseConstructor(hook_1.Hook);
//# sourceMappingURL=aspect.hook.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.i18n.js":
/*!****************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.i18n.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.I18nAspectDescriptor = void 0;
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const i18n_1 = __webpack_require__(/*! ../i18n */ "./node_modules/@branch-ts/core/src/i18n.js");
const util_1 = __webpack_require__(/*! ../util */ "./node_modules/@branch-ts/core/src/util.js");
const i18n_cons = {
    key: "cons",
    requires: [],
    input: "value",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    description: "Class Constructor of the i18n",
    typeSpec: "Constructor<any>"
};
const i18n_material = {
    key: "material",
    requires: [],
    input: "none",
    make(ctx) {
        return __awaiter(this, void 0, void 0, function* () {
            let value = ctx.value;
            if (!value && ctx.runtime) {
                value = i18n_1.I18nLocaleMaterial.instanceToMaterial(new ctx.runtime.value);
            }
            value = value || {};
            ctx.value = value;
            return value;
        });
    },
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    description: "{name:template} pair of i18n file",
    typeSpec: "{ [name: string]: string }"
};
exports.I18nAspectDescriptor = {
    name: "i18n",
    style: "constructor",
    parents: null,
    parentUniqueNameKey: null,
    autoIncludeInDomain: true,
    defaultKnowledge: knowledge_1.KnowledgeScope.Implementer,
    decorateToNewValue: i18n_1.GlobalI18nManager.decorateToNewConstructor.bind(i18n_1.GlobalI18nManager),
    subClassOf: [i18n_1.I18n],
    properties: {
        cons: i18n_cons,
        material: i18n_material,
    }
};
util_1.Util.markBaseConstructor(i18n_1.I18n);
//# sourceMappingURL=aspect.i18n.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.keeper.js":
/*!******************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.keeper.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeeperAspectDescriptor = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const keeper_1 = __webpack_require__(/*! ../keeper */ "./node_modules/@branch-ts/core/src/keeper.js");
const util_1 = __webpack_require__(/*! ../util */ "./node_modules/@branch-ts/core/src/util.js");
const keeper_name = {
    key: "name",
    requires: [],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const value = ctx.value || ((_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.name);
        const reg = /^[A-Z][a-zA-Z0-9]*Keeper*$/;
        if (!reg.test(value)) {
            throw new errors_1.Errors.DesignError(`Keeper name '${value}' must capitalized and contains only alphabets and end with Keeper`);
        }
        ctx.value = value;
        return value;
    }),
    description: "Name of the keeper, should be unique under same namespace, contains only alphabet and number only and must start with capitalized alphabet",
    typeSpec: "string"
};
const keeper_model = {
    key: "model",
    requires: ["model.uniqueName"],
    input: "required",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make(ctx) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const value = ctx.value || ((_b = (_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b.model);
            ctx.value = value;
            if (!value) {
                ctx.error(`model: ModelUniqueName is required for keeper`);
            }
            const targetModel = ctx.context.findAspect("model", { uniqueName: value });
            if (!targetModel) {
                ctx.error(`model: ${value} not found`);
            }
            return value;
        });
    },
    typeSpec: "Type.Branch.Name.ModelUniqueName"
};
const keeper_loadCondition = {
    key: "loadCondition",
    requires: [],
    input: "optional",
    optional: true,
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make(ctx) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const value = ctx.value || ((_b = (_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b.loadCondition);
            ctx.value = value;
            return value;
        });
    },
    typeSpec: "Type.Criteria.Condition"
};
const keeper_cons = {
    key: "cons",
    requires: [],
    input: "value",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    description: "Class Constructor of the keeper",
    typeSpec: "Constructor<any>"
};
exports.KeeperAspectDescriptor = {
    name: "keeper",
    style: "constructor",
    parents: null,
    parentUniqueNameKey: null,
    defaultKnowledge: knowledge_1.KnowledgeScope.Implementer,
    subClassOf: [keeper_1.DocumentKeeper],
    properties: {
        model: keeper_model,
        name: keeper_name,
        cons: keeper_cons,
        loadCondition: keeper_loadCondition,
    }
};
util_1.Util.markBaseConstructor(keeper_1.DocumentKeeper);
//# sourceMappingURL=aspect.keeper.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.migration.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.migration.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MigrationAspectDescriptor = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const migration_name = {
    key: "name",
    requires: [],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const value = ctx.value || ((_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.name);
        const reg = /^[A-Z][a-zA-Z0-9]*Migration*$/;
        if (!reg.test(value)) {
            throw new errors_1.Errors.DesignError(`Migration name '${value}' must capitalized and contains only alphabets and end with Migration`);
        }
        ctx.value = value;
        return value;
    }),
    description: "Name of the migration, should be unique under same namespace, contains only alphabet and number only and must start with capitalized alphabet",
    typeSpec: "Type.Branch.Name.MigrationName"
};
const migration_version = {
    key: "version",
    requires: [],
    input: "optional",
    optional: true,
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _b, _c;
        const value = ctx.value || ((_c = (_b = ctx.runtime) === null || _b === void 0 ? void 0 : _b.inputs) === null || _c === void 0 ? void 0 : _c.version) || null;
        if (!value || typeof value !== "number" || isNaN(value)) {
            throw new errors_1.Errors.DesignError(`Migration version must be a number`);
        }
        if (value < 0) {
            throw new errors_1.Errors.DesignError(`Migration version must be a positive number`);
        }
        if (Math.floor(value) !== value) {
            throw new errors_1.Errors.DesignError(`Migration version must be an integer`);
        }
        ctx.value = value;
        return value;
    }),
    description: "Version the migration is migrating to",
    typeSpec: "Type.Branch.Int"
};
const migration_cons = {
    key: "cons",
    requires: [],
    input: "value",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    description: "Class Constructor of the migration",
    typeSpec: "Constructor<any>"
};
exports.MigrationAspectDescriptor = {
    name: "migration",
    style: "constructor",
    parents: null,
    parentUniqueNameKey: null,
    defaultKnowledge: knowledge_1.KnowledgeScope.Implementer,
    subClassOf: [],
    autoIncludeInDomain: true,
    properties: {
        name: migration_name,
        cons: migration_cons,
        version: migration_version,
    }
};
//# sourceMappingURL=aspect.migration.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.model.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.model.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModelAspectDefinition = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const model_name = {
    key: "name",
    requires: [],
    knowledge: knowledge_1.KnowledgeScope.User,
    input: "optional",
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b, _c, _d;
        const reg = /^[A-Z][a-zA-Z0-9]*$/;
        const value = ctx.value || ((_b = (_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b.name) || ((_d = (_c = ctx.runtime) === null || _c === void 0 ? void 0 : _c.value) === null || _d === void 0 ? void 0 : _d.name);
        if (!reg.test(value)) {
            ctx.error(`Model.name must capitalized and contains only alphabets: ${value}`);
        }
        ctx.value = value;
        return ctx.value;
    }),
    description: "Name of the model, should be unique under same namespace, contains only alphabet and number only and must start with capitalized alphabet",
    typeSpec: "string"
};
const model_uniqueName = {
    key: "uniqueName",
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.User,
    requires: [],
    make(ctx) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const value = ctx.value || ((_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.uniqueName);
            return value;
        });
    },
    typeSpec: "Type.Branch.Name.ModelUniqueName"
};
const model_enable = {
    key: "enable",
    requires: [],
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    input: "optional",
    make: (context) => __awaiter(void 0, void 0, void 0, function* () {
        var _e, _f;
        let value = context.value && Array.isArray(context.value) && context.value || ((_f = (_e = context.runtime) === null || _e === void 0 ? void 0 : _e.inputs) === null || _f === void 0 ? void 0 : _f.enable);
        if (!Array.isArray(value)) {
            value = [];
        }
        context.value = value;
        return value;
    }),
    description: "Feature required in the model",
    typeSpec: `Type.Branch.Spec.ModelFeature[]`
};
const model_disable = {
    key: "disable",
    requires: [],
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    input: "optional",
    make: (context) => __awaiter(void 0, void 0, void 0, function* () {
        var _g, _h;
        let value = context.value && Array.isArray(context.value) && context.value || ((_h = (_g = context.runtime) === null || _g === void 0 ? void 0 : _g.inputs) === null || _h === void 0 ? void 0 : _h.disable);
        if (!Array.isArray(value)) {
            value = [];
        }
        context.value = value;
        return value;
    }),
    description: "Feature disabled in the model",
    typeSpec: `Type.Branch.Spec.ModelFeature[]`
};
const model_displayName = {
    key: "displayName",
    requires: ["@name"],
    knowledge: knowledge_1.KnowledgeScope.UI,
    input: "optional",
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _j, _k;
        const value = ctx.value || ((_k = (_j = ctx.runtime) === null || _j === void 0 ? void 0 : _j.inputs) === null || _k === void 0 ? void 0 : _k.displayName) || ctx.aspect.name;
        ctx.value = value;
        return value;
    }),
    description: "Display name of the model",
    typeSpec: "string"
};
const model_description = {
    key: "description",
    knowledge: knowledge_1.KnowledgeScope.UI,
    requires: [],
    input: "optional",
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _l, _m;
        const value = ctx.value || ((_m = (_l = ctx.runtime) === null || _l === void 0 ? void 0 : _l.inputs) === null || _m === void 0 ? void 0 : _m.description) || "";
        ctx.value = value;
        return value;
    }),
    description: "Description of model",
    typeSpec: "string"
};
const model_fieldInitOrders = {
    key: "fieldInitOrders",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    requires: ["field.dependencies"],
    input: "none",
    optional: false,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        let value = ctx.value || null;
        if (!value) {
            const fields = ctx.context.findAspects("field", {
                modelUniqueName: ctx.aspect.uniqueName
            });
            const deps = new Leaf.DependencyManager();
            for (let field of fields) {
                deps.add(field.key, field.dependencies || []);
            }
            value = deps.resolve();
        }
        ctx.value = value;
        return value;
    }),
    description: "Order of field initialization",
    typeSpec: "string[]"
};
const model_immutable = {
    key: "immutable",
    knowledge: knowledge_1.KnowledgeScope.User,
    requires: [],
    input: "optional",
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _o, _p;
        if (typeof ctx.value == "boolean") {
            return ctx.value;
        }
        const value = ((_p = (_o = ctx.runtime) === null || _o === void 0 ? void 0 : _o.inputs) === null || _p === void 0 ? void 0 : _p.immutable) || false;
        ctx.value = value;
        if (ctx.value && typeof ctx.value !== "boolean") {
            throw new errors_1.Errors.DesignError(`Immutable must be boolean`);
        }
        return value;
    }),
    description: "Is model immutable, if so document won't be able to get updated",
    typeSpec: "boolean"
};
const model_irremovable = {
    key: "irremovable",
    knowledge: knowledge_1.KnowledgeScope.User,
    requires: [],
    input: "optional",
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _q, _r;
        if (typeof ctx.value == "boolean") {
            return ctx.value;
        }
        const value = ((_r = (_q = ctx.runtime) === null || _q === void 0 ? void 0 : _q.inputs) === null || _r === void 0 ? void 0 : _r.irremovable) || false;
        ctx.value = value;
        if (ctx.value && typeof ctx.value !== "boolean") {
            throw new errors_1.Errors.DesignError(`Irremovable must be boolean`);
        }
        return value;
    }),
    description: "Is model irremovable, if so document won't be able to get removed",
    typeSpec: "boolean"
};
const model_single = {
    key: "single",
    knowledge: knowledge_1.KnowledgeScope.User,
    input: "optional",
    requires: [],
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _s, _t;
        if (typeof ctx.value == "boolean" || typeof ctx.value == "object") {
            return ctx.value;
        }
        const value = ((_t = (_s = ctx.runtime) === null || _s === void 0 ? void 0 : _s.inputs) === null || _t === void 0 ? void 0 : _t.single) || false;
        ctx.value = value;
        return value;
    }),
    description: "Is model single, only one document exists for the document, we can provide an object as the initial document value instead of boolean value",
    typeSpec: "boolean | {}"
};
const model_scopes = {
    key: "scopes",
    knowledge: knowledge_1.KnowledgeScope.User,
    requires: [],
    input: "none",
    optional: true,
    make: (context) => __awaiter(void 0, void 0, void 0, function* () {
        return context.value || null;
    }),
    description: "Is model scopes, if so document won't be able to get removed",
    typeSpec: "string[][]"
};
const model_policy = {
    key: "policy",
    knowledge: knowledge_1.KnowledgeScope.User,
    enums: ["root", "user", "custom"],
    requires: [],
    input: "optional",
    make(ctx) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const value = ctx.value || ((_b = (_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b.policy) || "user";
            if (!this.enums.includes(value)) {
                throw new errors_1.Errors.DesignError(`Policy must be one of ${this.enums.join(", ")}`);
            }
            ctx.value = value;
            return value;
        });
    },
    description: "Is so, only root can create/query/update/remove the data, and all knowledge of this model and fields are for implementors only",
};
const model_delegator = {
    key: "delegator",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    requires: [],
    input: "optional",
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _u, _v;
        const value = ctx.value || ((_v = (_u = ctx.runtime) === null || _u === void 0 ? void 0 : _u.inputs) === null || _v === void 0 ? void 0 : _v.delegator) || null;
        ctx.value = value;
        return value;
    }),
    description: "An delegate keeper constructor",
    typeSpec: "Constructor<any>"
};
const model_abstract = {
    key: "abstract",
    knowledge: knowledge_1.KnowledgeScope.User,
    requires: [],
    input: "optional",
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _w, _x, _y, _z;
        let value = ctx.value;
        if (typeof value == "boolean") {
            return value;
        }
        ctx.value = value = (_x = (_w = ctx.runtime) === null || _w === void 0 ? void 0 : _w.inputs) === null || _x === void 0 ? void 0 : _x.abstract;
        if (typeof value == "boolean") {
            return value;
        }
        if ((_z = (_y = ctx.parsed) === null || _y === void 0 ? void 0 : _y.modifiers) === null || _z === void 0 ? void 0 : _z.includes("abstract")) {
            ctx.value = value = true;
            return value;
        }
        return false;
    }),
    description: "If the model is abstract(No underlying repository will be created",
    typeSpec: "boolean"
};
exports.ModelAspectDefinition = {
    name: "model",
    defaultKnowledge: knowledge_1.KnowledgeScope.User,
    parents: null,
    parentUniqueNameKey: null,
    style: "class",
    autoIncludeInDomain: true,
    properties: {
        name: model_name,
        uniqueName: model_uniqueName,
        disable: model_disable,
        enable: model_enable,
        displayName: model_displayName,
        description: model_description,
        immutable: model_immutable,
        irremovable: model_irremovable,
        single: model_single,
        scopes: model_scopes,
        policy: model_policy,
        delegator: model_delegator,
        abstract: model_abstract,
        fieldInitOrders: model_fieldInitOrders,
    }
};
//# sourceMappingURL=aspect.model.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.option.js":
/*!******************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.option.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OptionAspectDescriptor = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const option_name = {
    key: "name",
    requires: [],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const value = ctx.value || ((_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.name);
        const reg = /^[a-z][a-zA-Z0-9]*$/;
        if (!reg.test(value)) {
            throw new errors_1.Errors.DesignError(`Option name '${value}' must uncapitalized and contains only alphabets`);
        }
        ctx.value = value;
        return value;
    }),
    description: "Config option name, uncapitalized",
    typeSpec: "Type.Branch.Name.OptionName"
};
const option_uniqueName = {
    key: "uniqueName",
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.User,
    requires: [],
    make(ctx) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const value = ctx.value || ((_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.uniqueName);
            return value;
        });
    },
    typeSpec: "Type.Branch.Name.OptionUniqueName"
};
const option_description = {
    key: "description",
    knowledge: knowledge_1.KnowledgeScope.UI,
    requires: [],
    input: "optional",
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _b, _c;
        const value = ctx.value || ((_c = (_b = ctx.runtime) === null || _b === void 0 ? void 0 : _b.inputs) === null || _c === void 0 ? void 0 : _c.description) || "";
        ctx.value = value;
        return value;
    }),
    description: "Description of the option",
    typeSpec: "Type.Branch.Text"
};
const option_configUniqueName = {
    key: "configUniqueName",
    knowledge: knowledge_1.KnowledgeScope.User,
    input: "none",
    requires: [],
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        const value = ctx.value || ctx.runtime.parentAcknowledgement.uniqueName;
        ctx.value = value;
        return value;
    }),
    description: "ModelUniqueName of the option",
    typeSpec: "Type.Branch.Name.ConfigUniqueName"
};
const option_enums = {
    key: "enums",
    requires: [],
    input: "optional",
    optional: true,
    knowledge: knowledge_1.KnowledgeScope.User,
    description: `Possible valid name:value of the option `,
    typeSpec: `any[] `
};
const option_default = {
    key: "default",
    requires: ["@name"],
    input: "none",
    optional: true,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _d, _e, _f;
        const value = ctx.value || ((_f = (_e = (_d = ctx.runtime) === null || _d === void 0 ? void 0 : _d.parentAcknowledgement) === null || _e === void 0 ? void 0 : _e.instance) === null || _f === void 0 ? void 0 : _f[ctx.aspect.name]) || ctx.value;
        ctx.value = value;
        return value;
    }),
    knowledge: knowledge_1.KnowledgeScope.User,
    description: `Possible valid name:value of the option `,
    typeSpec: `any[] `
};
const option_tsTypeLiteral = {
    key: "tsTypeLiteral",
    input: "none",
    requires: ["@enums"],
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make: (context) => __awaiter(void 0, void 0, void 0, function* () {
        var _g;
        if (context.value)
            return context.value;
        if (context.aspect.enums) {
            const names = Object.keys(context.aspect.enums);
            const values = names.map(name => context.aspect.enums[name]);
            context.value = values.map(v => JSON.stringify(v)).join(" | ");
            return context.value;
        }
        if (context.parsed) {
            let value = (_g = context.parsed.parsedType) === null || _g === void 0 ? void 0 : _g.value;
            if (value) {
                context.value = value;
                return value;
            }
        }
        context.error(`Option ${context.aspect.name} missing explicit ts type specification`);
    }),
    description: `Type specification of the option of the typescript definination`,
    typeSpec: `string`
};
exports.OptionAspectDescriptor = {
    name: "option",
    style: "property",
    parents: ["config"],
    parentUniqueNameKey: "configUniqueName",
    parentChildKey: "options",
    defaultKnowledge: knowledge_1.KnowledgeScope.Implementer,
    properties: {
        name: option_name,
        uniqueName: option_uniqueName,
        configUniqueName: option_configUniqueName,
        enums: option_enums,
        default: option_default,
        tsTypeLiteral: option_tsTypeLiteral,
        description: option_description,
    }
};
//# sourceMappingURL=aspect.option.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.procedure.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.procedure.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProcedureAspectDescriptor = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const procedure_name = {
    key: "name",
    requires: [],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const value = ctx.value || ((_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.name);
        const reg = /^[A-Z][a-zA-Z0-9]*Procedure*$/;
        if (!reg.test(value)) {
            throw new errors_1.Errors.DesignError(`Procedure name '${value}' must capitalized and contains only alphabets and end with Procedure`);
        }
        ctx.value = value;
        return value;
    }),
    description: "Name of the procedure, should be unique under same namespace, contains only alphabet and number only and must start with capitalized alphabet",
    typeSpec: "string"
};
const procedure_uniqueName = {
    key: "uniqueName",
    requires: ["@name", "@namespace", "@revision"],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        const value = ctx.value || `${ctx.aspect.namespace}.${ctx.aspect.name}:${ctx.aspect.revision}`;
        ctx.value = value;
        return value;
    }),
    description: "UniqueName of the procedure which is {Namespace}.{Name}:{revision} unlike the normal NamespaceLike uniqueName in other aspect. This is because procedure of different revision is considered as different procedure with different uniqueName. We use 'familyName' to represent the uniqueName of the procedure family which is the NamespaceLike uniqueName of the revions of procedure",
    typeSpec: "string"
};
const procedure_familyName = {
    key: "familyName",
    requires: ["@name", "@namespace"],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        const value = ctx.value || `${ctx.aspect.namespace}.${ctx.aspect.name}`;
        ctx.value = value;
        return value;
    }),
    description: "FamilyName of the procedure which is {Namespace}.{Name} like uniqueName for other aspects",
    typeSpec: "string"
};
const procedure_revision = {
    key: "revision",
    requires: [],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _b, _c;
        const value = ctx.value || ((_c = (_b = ctx.runtime) === null || _b === void 0 ? void 0 : _b.inputs) === null || _c === void 0 ? void 0 : _c.revision) || 0;
        if (typeof value !== "number" || Math.floor(value) !== value) {
            ctx.error(`revision: should be int`);
        }
        return value;
    }),
    description: "Revision of the should be integer greater or equal than 0",
    typeSpec: "Type.Branch.Int"
};
const procedure_exclusive = {
    key: "exclusive",
    requires: [],
    input: "optional",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _d, _e;
        const value = ctx.value || ((_e = (_d = ctx.runtime) === null || _d === void 0 ? void 0 : _d.inputs) === null || _e === void 0 ? void 0 : _e.exclusive) || {};
        ctx.value = value;
        return value;
    }),
    description: `The scope of exclusive is always decide by the store, the exclusive here only determine what how do we decide two ask is aquire the same resource. Examples:
Use "subscription/{{contexId}}/{{userId}}" as the exclusive, even we have a different procedure family, as long as it generates the same exclusive in the same store, it won't be created.
>> ["subscription",":contexId",":userId"]
contextId and userId is read from input, if the value is not a string or int, we will throw AbuseError and hang the runner.
Runner becomes "running" state only after the exclusive is ensured.

We have special delcaretive here:
@active: exclusive is revoked after the runner comes to end. Not hang nor panic, which we need external inference to decide whether to revoke the exclusive. Else the exclusive will be kept forever.

Whenever the :param is not a none-empty string or int in TMarks["input"], we will throw abuse.

exclusive array can contain only a single @active and no other item. In that case, no exclusive will be ensured, but the procedure will always be load and run unless reaching an end state.
`,
    typeSpec: `{
        [key:string]: string[]
    }`
};
const procedure_cons = {
    key: "cons",
    requires: [],
    input: "value",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    description: "Class Constructor of the procedure",
    typeSpec: "Constructor<any>"
};
exports.ProcedureAspectDescriptor = {
    name: "procedure",
    style: "constructor",
    parents: null,
    parentUniqueNameKey: null,
    defaultKnowledge: knowledge_1.KnowledgeScope.Implementer,
    makeUniqueName: (ack) => {
        var _a, _b;
        const namespace = ((_a = ack.inputs) === null || _a === void 0 ? void 0 : _a.namespace) || ack.ambientNamespace;
        const revision = ((_b = ack.inputs) === null || _b === void 0 ? void 0 : _b.revision) || 0;
        return `${namespace}.${ack.name}:${revision}`;
    },
    autoIncludeInDomain: true,
    subClassOf: [],
    properties: {
        name: procedure_name,
        uniqueName: procedure_uniqueName,
        familyName: procedure_familyName,
        cons: procedure_cons,
        revision: procedure_revision,
        exclusive: procedure_exclusive,
    }
};
//# sourceMappingURL=aspect.procedure.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.repository.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.repository.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RepositoryAspectDescriptor = void 0;
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const repository_1 = __webpack_require__(/*! ../repository */ "./node_modules/@branch-ts/core/src/repository.js");
const util_1 = __webpack_require__(/*! ../util */ "./node_modules/@branch-ts/core/src/util.js");
const repository_for = {
    key: "for",
    requires: ["model.uniqueName"],
    input: "optional",
    optional: true,
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make(ctx) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const value = ctx.value || ((_b = (_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b.for) || [];
            ctx.value = value;
            return value;
        });
    },
    typeSpec: "Type.Branch.Spec.NamespaceLikeMatcher[]"
};
const repository_priority = {
    key: "priority",
    requires: [],
    input: "optional",
    optional: true,
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make(ctx) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let value = ctx.value || ((_b = (_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b.priority);
            if (typeof value !== "number")
                value = -1;
            ctx.value = value;
            return value;
        });
    },
    typeSpec: "number"
};
const repository_cons = {
    key: "cons",
    requires: [],
    input: "value",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    description: "Class Constructor of the repository",
    typeSpec: "Constructor<any>"
};
exports.RepositoryAspectDescriptor = {
    name: "repository",
    style: "constructor",
    parents: null,
    parentUniqueNameKey: null,
    autoIncludeInDomain: true,
    defaultKnowledge: knowledge_1.KnowledgeScope.Implementer,
    subClassOf: [repository_1.Repository, repository_1.RepositoryProvider],
    properties: {
        for: repository_for,
        cons: repository_cons,
        priority: repository_priority,
    }
};
util_1.Util.markBaseConstructor(repository_1.Repository);
util_1.Util.markBaseConstructor(repository_1.RepositoryProvider);
//# sourceMappingURL=aspect.repository.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.rpc.js":
/*!***************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.rpc.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcAspectDescriptor = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const rpc_name = {
    key: "name",
    requires: [],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.User,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const value = ctx.value || ((_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.name);
        const reg = /^[a-z][a-zA-Z0-9]*$/;
        if (!reg.test(value)) {
            throw new errors_1.Errors.DesignError(`Rpc name ${value} must uncapitalized and contains only alphabets`);
        }
        ctx.value = value;
        return value;
    }),
    description: "Name of the rpc, should be unique under same namespace, contains only alphabet and number only and must start with capitalized alphabet",
    typeSpec: "Type.Branch.Name.RpcName"
};
const rpc_serviceUniqueName = {
    key: "serviceUniqueName",
    knowledge: knowledge_1.KnowledgeScope.User,
    input: "none",
    requires: [],
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        const value = ctx.value || ctx.runtime.parentAcknowledgement.uniqueName;
        ctx.value = value;
        return value;
    }),
    description: "Unique name of service rpc belongs to",
    typeSpec: "Type.Branch.Name.RpcUniqueName"
};
const rpc_roles = {
    key: "roles",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    input: "optional",
    requires: [],
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _b, _c;
        const value = ctx.value || ((_c = (_b = ctx.runtime) === null || _b === void 0 ? void 0 : _b.inputs) === null || _c === void 0 ? void 0 : _c.roles) || [];
        ctx.value = value;
        return value;
    }),
    description: "Roles that can access the rpc",
    typeSpec: "string[]",
};
const rpc_guard = {
    key: "guard",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    input: "optional",
    requires: [],
    description: "Guard function to check for rpc accessibility",
    typeSpec: "Type.Branch.Spec.RpcGuardHandler"
};
const rpc_optionTsTypeLiteral = {
    key: "optionTsTypeLiteral",
    knowledge: knowledge_1.KnowledgeScope.User,
    input: "none",
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _d, _e, _f;
        const value = ctx.value || ((_f = (_e = (_d = ctx.parsed) === null || _d === void 0 ? void 0 : _d.parsedType) === null || _e === void 0 ? void 0 : _e.parameters) === null || _f === void 0 ? void 0 : _f[0]) || "never";
        ctx.value = value;
        return value;
    }),
    requires: [],
    description: "Typescript type literal of the option arguments",
    typeSpec: "string"
};
const rpc_returnTsTypeLiteral = {
    key: "returnTsTypeLiteral",
    knowledge: knowledge_1.KnowledgeScope.User,
    input: "none",
    requires: [],
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _g, _h;
        let value = ctx.value || ((_h = (_g = ctx.parsed) === null || _g === void 0 ? void 0 : _g.parsedType) === null || _h === void 0 ? void 0 : _h.return) || "Promise<void>";
        value = value.trim();
        const reg = /Promise<(.+)>/ig;
        if (reg.test(value)) {
            value = value.slice("Promise<".length, -1);
        }
        ctx.value = value;
        return value;
    }),
    description: "Typescript type literal of rpc return value",
    typeSpec: "string"
};
exports.RpcAspectDescriptor = {
    name: "rpc",
    defaultKnowledge: knowledge_1.KnowledgeScope.User,
    style: "property",
    parents: ["service"],
    parentChildKey: "rpcs",
    parentUniqueNameKey: "serviceUniqueName",
    properties: {
        name: rpc_name,
        serviceUniqueName: rpc_serviceUniqueName,
        roles: rpc_roles,
        guard: rpc_guard,
        optionTsTypeLiteral: rpc_optionTsTypeLiteral,
        returnTsTypeLiteral: rpc_returnTsTypeLiteral,
    }
};
//# sourceMappingURL=aspect.rpc.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.service.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.service.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceAspectDescriptor = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const service_name = {
    key: "name",
    requires: [],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const value = ctx.value || ((_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.name);
        const reg = /^[A-Z][a-zA-Z0-9]*Service*$/;
        if (!reg.test(value)) {
            throw new errors_1.Errors.DesignError(`Service name '${value}' must capitalized and contains only alphabets and end with Service`);
        }
        ctx.value = value;
        return value;
    }),
    description: "Name of the service, should be unique under same namespace, contains only alphabet and number only and must start with capitalized alphabet",
    typeSpec: "string"
};
const service_requires = {
    key: "requires",
    requires: ["service.uniqueName", "@namespace"],
    input: "optional",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make(ctx) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let requires = ctx.value || ((_b = (_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b.requires) || [];
            requires = requires.map(req => {
                const full = ctx.context.builder.codex.namespace.ensureUniqueName(req, ctx.aspect.namespace);
                return full;
            });
            ctx.value = requires;
            return requires;
        });
    },
    description: `ServiceUniqueNames of depending services`,
    typeSpec: "(Type.Branch.Name.ServiceUniqueName | Type.Branch.Name.ServiceName)[]"
};
const service_cons = {
    key: "cons",
    requires: [],
    input: "value",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    description: "Class Constructor of the service",
    typeSpec: "Constructor<any>"
};
exports.ServiceAspectDescriptor = {
    name: "service",
    style: "constructor",
    parents: null,
    parentUniqueNameKey: null,
    defaultKnowledge: knowledge_1.KnowledgeScope.Implementer,
    autoIncludeInDomain: true,
    subClassOf: [],
    properties: {
        name: service_name,
        cons: service_cons,
        requires: service_requires,
    }
};
//# sourceMappingURL=aspect.service.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/aspect.store.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/aspect.store.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StoreAspectDescriptor = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const store_name = {
    key: "name",
    requires: [],
    input: "none",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const value = ctx.value || ((_a = ctx.runtime) === null || _a === void 0 ? void 0 : _a.name);
        const reg = /^[A-Z][a-zA-Z0-9]*Store*$/;
        if (!reg.test(value)) {
            throw new errors_1.Errors.DesignError(`Store name '${value}' must capitalized and contains only alphabets and end with Store`);
        }
        ctx.value = value;
        return value;
    }),
    description: "Name of the store, should be unique under same namespace, contains only alphabet and number only and must start with capitalized alphabet",
    typeSpec: "Type.Branch.Name.StoreName"
};
const store_for = {
    key: "for",
    requires: [],
    input: "optional",
    optional: true,
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    make: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
        var _b, _c;
        const value = ctx.value || ((_c = (_b = ctx.runtime) === null || _b === void 0 ? void 0 : _b.inputs) === null || _c === void 0 ? void 0 : _c.for) || null;
        ctx.value = value;
        return value;
    }),
    description: "For which procedure(s) we would like to use this store",
    typeSpec: "string[]"
};
const store_cons = {
    key: "cons",
    requires: [],
    input: "value",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    description: "Class Constructor of the store",
    typeSpec: "Constructor<any>"
};
exports.StoreAspectDescriptor = {
    name: "store",
    style: "constructor",
    parents: null,
    parentUniqueNameKey: null,
    defaultKnowledge: knowledge_1.KnowledgeScope.Implementer,
    subClassOf: [],
    autoIncludeInDomain: true,
    properties: {
        name: store_name,
        cons: store_cons,
        for: store_for,
    }
};
//# sourceMappingURL=aspect.store.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/design.js":
/*!***********************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/design.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultDesign = exports.builtInAspects = exports.ApplicationInfoModelDescriptor = exports.ApplicationInfoModelFieldDescriptors = exports.migration = exports.store = exports.keeper = exports.procedure = exports.i18n = exports.option = exports.config = exports.repository = exports.hook = exports.access = exports.rpc = exports.service = exports.group = exports.field = exports.model = exports.AspectDefinitions = void 0;
const design_1 = __webpack_require__(/*! ../codex/design */ "./node_modules/@branch-ts/core/src/codex/design.js");
const aspect_model_1 = __webpack_require__(/*! ./aspect.model */ "./node_modules/@branch-ts/core/src/design/aspect.model.js");
const aspect_field_1 = __webpack_require__(/*! ./aspect.field */ "./node_modules/@branch-ts/core/src/design/aspect.field.js");
const aspect_group_1 = __webpack_require__(/*! ./aspect.group */ "./node_modules/@branch-ts/core/src/design/aspect.group.js");
const aspect_service_1 = __webpack_require__(/*! ./aspect.service */ "./node_modules/@branch-ts/core/src/design/aspect.service.js");
const aspect_rpc_1 = __webpack_require__(/*! ./aspect.rpc */ "./node_modules/@branch-ts/core/src/design/aspect.rpc.js");
const aspect_access_1 = __webpack_require__(/*! ./aspect.access */ "./node_modules/@branch-ts/core/src/design/aspect.access.js");
const aspect_hook_1 = __webpack_require__(/*! ./aspect.hook */ "./node_modules/@branch-ts/core/src/design/aspect.hook.js");
const aspect_keeper_1 = __webpack_require__(/*! ./aspect.keeper */ "./node_modules/@branch-ts/core/src/design/aspect.keeper.js");
const aspect_repository_1 = __webpack_require__(/*! ./aspect.repository */ "./node_modules/@branch-ts/core/src/design/aspect.repository.js");
const aspect_config_1 = __webpack_require__(/*! ./aspect.config */ "./node_modules/@branch-ts/core/src/design/aspect.config.js");
const aspect_option_1 = __webpack_require__(/*! ./aspect.option */ "./node_modules/@branch-ts/core/src/design/aspect.option.js");
const aspect_i18n_1 = __webpack_require__(/*! ./aspect.i18n */ "./node_modules/@branch-ts/core/src/design/aspect.i18n.js");
const annotation_1 = __webpack_require__(/*! ../annotation */ "./node_modules/@branch-ts/core/src/annotation.js");
const aspect_procedure_1 = __webpack_require__(/*! ./aspect.procedure */ "./node_modules/@branch-ts/core/src/design/aspect.procedure.js");
const aspect_store_1 = __webpack_require__(/*! ./aspect.store */ "./node_modules/@branch-ts/core/src/design/aspect.store.js");
const aspect_migration_1 = __webpack_require__(/*! ./aspect.migration */ "./node_modules/@branch-ts/core/src/design/aspect.migration.js");
const knowledge_1 = __webpack_require__(/*! ../codex/knowledge */ "./node_modules/@branch-ts/core/src/codex/knowledge.js");
const nanoid_1 = __webpack_require__(/*! nanoid */ "./node_modules/nanoid/index.browser.js");
exports.AspectDefinitions = [
    aspect_model_1.ModelAspectDefinition,
    aspect_field_1.FieldAspectDescriptor,
    aspect_group_1.GroupAspectDescriptor,
    aspect_service_1.ServiceAspectDescriptor,
    aspect_rpc_1.RpcAspectDescriptor,
    aspect_access_1.AccessAspectDescriptor,
    aspect_hook_1.HookAspectDescriptor,
    aspect_repository_1.RepositoryAspectDescriptor,
    aspect_config_1.ConfigAspectDescriptor,
    aspect_option_1.OptionAspectDescriptor,
    aspect_i18n_1.I18nAspectDescriptor,
    aspect_keeper_1.KeeperAspectDescriptor,
    aspect_procedure_1.ProcedureAspectDescriptor,
    aspect_store_1.StoreAspectDescriptor,
    aspect_migration_1.MigrationAspectDescriptor,
];
exports.model = annotation_1.Annotation.decorator(aspect_model_1.ModelAspectDefinition);
exports.field = annotation_1.Annotation.decorator(aspect_field_1.FieldAspectDescriptor);
exports.group = annotation_1.Annotation.decorator(aspect_group_1.GroupAspectDescriptor);
exports.service = annotation_1.Annotation.decorator(aspect_service_1.ServiceAspectDescriptor);
exports.rpc = annotation_1.Annotation.decorator(aspect_rpc_1.RpcAspectDescriptor);
exports.access = annotation_1.Annotation.decorator(aspect_access_1.AccessAspectDescriptor);
exports.hook = annotation_1.Annotation.decorator(aspect_hook_1.HookAspectDescriptor);
exports.repository = annotation_1.Annotation.decorator(aspect_repository_1.RepositoryAspectDescriptor);
exports.config = annotation_1.Annotation.decorator(aspect_config_1.ConfigAspectDescriptor);
exports.option = annotation_1.Annotation.decorator(aspect_option_1.OptionAspectDescriptor);
exports.i18n = annotation_1.Annotation.decorator(aspect_i18n_1.I18nAspectDescriptor);
exports.procedure = annotation_1.Annotation.decorator(aspect_procedure_1.ProcedureAspectDescriptor);
exports.keeper = annotation_1.Annotation.decorator(aspect_keeper_1.KeeperAspectDescriptor);
exports.store = annotation_1.Annotation.decorator(aspect_store_1.StoreAspectDescriptor);
exports.migration = annotation_1.Annotation.decorator(aspect_migration_1.MigrationAspectDescriptor);
exports.ApplicationInfoModelFieldDescriptors = [{
        key: "id",
        generate: function (ctx) {
            return ctx.inputNodeValue || (0, nanoid_1.nanoid)();
        }
    }, {
        key: "name",
    }, {
        key: "version",
        tsTypeLiteral: "Type.Branch.Int",
        type: "int",
    }, {
        key: "description",
        tsTypeLiteral: "Type.Branch.Text",
        type: "text",
    }, {
        key: "createdAt",
        tsTypeLiteral: "Type.Branch.Timestamp",
        type: "timestamp",
        generate: function (ctx) {
            return ctx.originNodeValue || Date.now();
        }
    }, {
        key: "createdAt",
        tsTypeLiteral: "Type.Branch.Timestamp",
        type: "timestamp",
        generate: function (ctx) {
            return ctx.originNodeValue || Date.now();
        }
    }, {
        key: "updatedAt",
        tsTypeLiteral: "Type.Branch.Timestamp",
        type: "timestamp",
        generate: function (ctx) {
            return Date.now();
        }
    }].map((info) => {
    let fieldDescriptor = {
        namespace: "Core",
        hardcoded: true,
        aspectName: "field",
        uniqueName: `Core.ApplicationInfo.${info.key}`,
        modelUniqueName: "Core.ApplicationInfo",
        name: info.key,
        knowledge: knowledge_1.KnowledgeScope.Implementer,
        key: info.key,
        type: info.type || "string",
        textSearch: false,
        optional: true,
        unique: false,
        displayName: info.key,
        description: info.description,
        dependencies: [],
        availability: "store",
        tsTypeLiteral: info.tsTypeLiteral || "string",
        readProtect: false,
        immutable: false,
        designer: "@branch-ts/core",
        access: "private",
        sortable: false,
        generate: info.generate,
        hasGenerate: info.generate ? true : false,
        hasInitValue: undefined
    };
    return fieldDescriptor;
});
exports.ApplicationInfoModelDescriptor = {
    hardcoded: true,
    namespace: "Core",
    aspectName: "model",
    uniqueName: "Core.ApplicationInfo",
    name: "ApplicationInfo",
    knowledge: knowledge_1.KnowledgeScope.Implementer,
    disable: [],
    enable: [],
    displayName: "ApplicationInfo",
    description: "Persisted application infos suchs as version/name",
    immutable: false,
    irremovable: true,
    single: {
        name: "UnnamedApplication",
        version: 0,
    },
    policy: "root",
    delegator: null,
    abstract: false,
    fieldInitOrders: ["id", "name", "version", "description", "createdAt", "updatedAt"],
    fields: exports.ApplicationInfoModelFieldDescriptors,
};
exports.builtInAspects = {
    model: [exports.ApplicationInfoModelDescriptor],
    field: [...exports.ApplicationInfoModelFieldDescriptors]
};
exports.DefaultDesign = new design_1.Design("default", { definitions: exports.AspectDefinitions, builtInAspects: exports.builtInAspects });
//# sourceMappingURL=design.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/parameterRequirement.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/parameterRequirement.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParameterRequirements = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
class ParameterRequirements {
    static build(option) {
        const { template, fields } = option;
        const requires = new ParameterRequirements();
        if (!option.template)
            return requires;
        const ors = template.ors || [];
        for (let or of ors) {
            for (let and of or.ands) {
                if (and.reference) {
                    let strict = false;
                    if (!option.fields[and.path]) {
                        throw new Error(`Invalid condition path ${and.path}: not a valid field key`);
                    }
                    const field = fields[and.path];
                    if (typeof and.value == "undefined") {
                        strict = true;
                        requires.add({
                            name: and.reference,
                            required: true,
                            fieldKey: and.path,
                            literal: field.tsTypeLiteral
                        });
                    }
                    else {
                        requires.add({
                            name: and.reference,
                            required: false,
                            default: and.value,
                            fieldKey: and.path,
                            literal: field.tsTypeLiteral
                        });
                    }
                }
            }
        }
        return requires;
    }
    constructor(requirements = {}) {
        this.requirements = {};
        this.requirements = Leaf.Util.clone(requirements) || {};
    }
    has(key) {
        return !!this.requirements[key];
    }
    add(option) {
        this.requirements[option.name] = {
            name: option.name,
            required: option.required,
            default: option.default,
            literal: option.literal,
            fieldKey: option.fieldKey,
        };
    }
    build(params) {
        const result = {};
        for (let key in this.requirements) {
            const req = this.requirements[key];
            if (Leaf.Util.isEmptyValue(params[key])) {
                result[key] = req.default;
            }
            else {
                result[key] = params[key];
            }
            if (req.required && Leaf.Util.isEmptyValue(result[key])) {
                throw new Error(`${req.name} is required but not provided`);
            }
        }
        return result;
    }
    getParamFieldKey(name) {
        var _a;
        return (_a = this.requirements[name]) === null || _a === void 0 ? void 0 : _a.fieldKey;
    }
    getFirstFieldKeyParam(key) {
        for (let name in this.requirements) {
            const req = this.requirements[name];
            if (req.fieldKey == key)
                return name;
        }
        return null;
    }
    check(params) {
        params = params || {};
        for (let key in this.requirements) {
            const req = this.requirements[key];
            if (!req.required)
                continue;
            if (Leaf.Util.isEmptyValue(params[req.name])) {
                throw new Error(`${req.name} is required but not provided`);
            }
        }
    }
    isValid(params) {
        if (!params)
            return false;
        try {
            this.check(params);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    getSpec() {
        return Leaf.Util.clone(this.requirements);
    }
    getRestrictionLiteral() {
        if (Object.keys(this.requirements).length == 0)
            return "null";
        const literals = [];
        for (let key in this.requirements) {
            const req = this.requirements[key];
            literals.push(`${req.name}${!req.required && "?" || ""}:${req.literal || "any"}`);
        }
        return `{
        ${literals.join("\n")}
}`;
    }
}
exports.ParameterRequirements = ParameterRequirements;
//# sourceMappingURL=parameterRequirement.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/reference.js":
/*!**************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/reference.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Reference = void 0;
const Const = __importStar(__webpack_require__(/*! ../const */ "./node_modules/@branch-ts/core/src/const.js"));
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
var Reference;
(function (Reference) {
    function isCapitalized(name) {
        return /[A-Z]/.test(name[0]);
    }
    function toSharedKey(reference) {
        if (Array.isArray(reference)) {
            reference = reference.join("_");
        }
        return reference[0] + reference.slice(1).replace(/\./g, "_").replace(/\$/g, "deref");
    }
    Reference.toSharedKey = toSharedKey;
    function build(info) {
        return [info.typeModelUniqueName, info.routes.join(".")].filter(item => !!item).join(".");
    }
    Reference.build = build;
    function referenceFromTypeLiteral(literal) {
        const reg = /Type\..+\["[a-z]+"\]$/i;
        if (reg.test(literal)) {
            const begin = literal.lastIndexOf("[");
            const value = literal.slice(begin + 2, -2);
            const before = literal.slice(5, begin);
            return [before, value].join(".");
        }
        return null;
    }
    Reference.referenceFromTypeLiteral = referenceFromTypeLiteral;
    function parse(reference, model) {
        if (!reference) {
            throw new errors_1.Errors.DesignError("Empty reference");
        }
        let scope = false;
        if (reference[0] == "@") {
            reference = reference.slice(1);
            scope = true;
        }
        if (reference[0] == "$") {
            reference = reference.slice(1);
            return {
                typeModelUniqueName: null,
                typeModel: null,
                typeNamespace: null,
                routes: reference.split("."),
                kind: "environment",
                orig: reference,
                base: model,
            };
        }
        const parts = reference.split(".");
        let namespaceParts = [];
        let modelPart = null;
        let routeParts = [];
        let phase = "namespace";
        for (let part of parts) {
            if (isCapitalized(part)) {
                if (phase == "namespace") {
                    namespaceParts.push(part);
                    continue;
                }
                else {
                    throw new errors_1.Errors.DesignError(`Invalid reference: ${reference}`);
                }
            }
            else {
                if (phase == "namespace") {
                    phase = "route";
                    if (namespaceParts.length > 0) {
                        modelPart = namespaceParts.pop();
                    }
                }
                if (isCapitalized(part)) {
                    throw new errors_1.Errors.DesignError(`field key reference can't be capitalized '${part}' in '${reference}'`);
                }
                routeParts.push(part);
            }
        }
        if (namespaceParts.length > 0 && !modelPart) {
            modelPart = namespaceParts.pop();
        }
        const namespace = namespaceParts.join(".") || (model && model.namespace) || Const.DefaultNamespace;
        return {
            typeModel: modelPart || null,
            typeNamespace: modelPart && namespace || null,
            typeModelUniqueName: modelPart && [namespace, modelPart].join(".") || null,
            routes: routeParts,
            kind: modelPart && "type" || "value",
            orig: reference,
            base: model,
            scope,
        };
    }
    Reference.parse = parse;
})(Reference || (exports.Reference = Reference = {}));
//# sourceMappingURL=reference.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/design/scope.js":
/*!**********************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/design/scope.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScopeAnalyzer = exports.ScopeCalculator = void 0;
class ScopeCalculator {
    constructor(candidates) {
        this.candidates = candidates;
        this.candidateMap = {};
        this.rules = {};
        for (let descriptor of candidates) {
            this.candidateMap[descriptor.uniqueName] = {
                descriptor
            };
        }
    }
    addScope(parent, child) {
        this.rules[`${parent}-${child}`] = 1;
        this.rules[`${child}-${parent}`] = -1;
    }
    calculate() {
        const candidates = this.candidates.slice();
        candidates.sort((a, b) => {
            const id = `${a.uniqueName}-${b.uniqueName}`;
            if (this.rules[id]) {
                return -this.rules[id];
            }
            return 0;
        });
        let chains = [];
        for (let i = 0; i < candidates.length; i++) {
            const cand = candidates[i];
            chains.push(...this.proceedChain([cand.uniqueName], candidates.slice(i + 1)));
        }
        chains = chains.filter(chain => chain.length > 1);
        for (let i = 0; i < chains.length; i++) {
            const cur = chains[i];
            for (let j = i + 1; j < chains.length; j++) {
                const sub = chains[j];
                if (cur && sub) {
                    if (this.chainContains(candidates, cur, sub)) {
                        chains.splice(j, 1);
                        j--;
                    }
                }
            }
        }
        return chains;
    }
    proceedChain(chain, candidates) {
        chain = chain.slice();
        candidates = candidates.slice();
        if (candidates.length == 0)
            return [chain];
        const result = [];
        const tail = chain.pop();
        if (!tail) {
            throw new Error(`Missing tail ${[chain]}, likely due to empty uniqueName of model`);
        }
        chain.push(tail);
        while (candidates.length > 0) {
            const cand = candidates.shift();
            const id = this.genId(tail, cand);
            if (this.rules[id] > 0) {
                result.push(...this.proceedChain([...chain, cand.uniqueName], candidates));
            }
        }
        return result;
    }
    genChainCode(candidates, chain) {
        return candidates.map(item => chain.indexOf(item.uniqueName) >= 0 && 1 || 0).join("");
    }
    chainContains(samples, a, b) {
        const aCode = this.genChainCode(samples, a);
        const bCode = this.genChainCode(samples, b);
        for (let i = 0; i < aCode.length; i++) {
            const aChar = aCode[i];
            const bChar = bCode[i];
            if (bChar == "1" && aChar !== "1") {
                return false;
            }
        }
        return true;
    }
    genId(left, right) {
        if (typeof left !== "string") {
            left = left.uniqueName;
        }
        if (typeof right !== "string") {
            right = right.uniqueName;
        }
        return `${left}-${right}`;
    }
}
exports.ScopeCalculator = ScopeCalculator;
class ScopeAnalyzer {
    constructor(option) {
        this.option = option;
    }
    getModelDescriptor(name) {
        throw new Error("Not implemented");
    }
    getSharedScopes(names) {
        const anchor = names[0];
        const rest = names.slice(1);
        const modelDesc = this.getModelDescriptor(anchor);
        if (!modelDesc)
            return [];
        const scopes = modelDesc.scopes || [];
        return scopes.filter(scope => {
            return rest.every(item => {
                return scope.indexOf(item) >= 0;
            });
        });
    }
    isDirectScopeChildOf(option) {
        const scopes = this.getSharedScopes([option.parent, option.child]);
        return scopes.some(scope => {
            return scope[scope.indexOf(option.parent) + 1] === option.child;
        });
    }
    getDirectScopeParentField(option) {
        var _a, _b;
        if (!this.isDirectScopeChildOf(option))
            return null;
        const fields = this.getModelDescriptor(option.child).fields;
        for (let field of fields) {
            if (((_a = field.referenceExplain) === null || _a === void 0 ? void 0 : _a.kind) === "scope" && ((_b = field.referenceExplain) === null || _b === void 0 ? void 0 : _b.referencingModelUniqueName) === option.parent) {
                return field;
            }
        }
        return null;
    }
    getSharedScopeParentField(option) {
        const result = {};
        const anchor = option.names[0];
        const rest = option.names.slice(1);
        const anchorDesc = this.getModelDescriptor(anchor);
        if (!anchor) {
            return result;
        }
        for (let field of this.getModelDescriptor(anchor).fields) {
            if (field.referenceExplain.kind == "scope") {
                const candidates = [];
                const allHas = rest.every(name => {
                    var _a, _b, _c;
                    const checkScopes = this.option.fieldDescriptors.filter(desc => desc.modelUniqueName == name);
                    for (let check of checkScopes) {
                        if (((_a = check.referenceExplain) === null || _a === void 0 ? void 0 : _a.kind) === "scope" && ((_b = check.referenceExplain) === null || _b === void 0 ? void 0 : _b.referencingModelUniqueName) === ((_c = field.referenceExplain) === null || _c === void 0 ? void 0 : _c.referencingModelUniqueName)) {
                            candidates.unshift(check);
                            return true;
                        }
                    }
                    return false;
                });
                if (allHas) {
                    candidates.push(field);
                    result[field.referenceExplain.referencingModelUniqueName] = candidates;
                }
            }
        }
        return result;
    }
}
exports.ScopeAnalyzer = ScopeAnalyzer;
//# sourceMappingURL=scope.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/document.js":
/*!******************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/document.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _DocumentInteraction_dirty, _DocumentInteraction_isRemoved;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentInterface = exports.DocumentMeta = exports.DocumentInteraction = exports.Document = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const aspect_field_1 = __webpack_require__(/*! ./design/aspect.field */ "./node_modules/@branch-ts/core/src/design/aspect.field.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
var Document;
(function (Document) {
    function getBrief(document) {
        const meta = document._meta;
        const inf = meta.documentInterface;
        if (document["name"])
            return document["name"];
        if (document["brief"])
            return document["brief"];
        for (let key in inf.fields) {
            const fd = inf.fields[key];
            if (fd.type == "string") {
                return document[fd.key];
            }
        }
        return document["id"] || "<Unknown>";
    }
    Document.getBrief = getBrief;
})(Document || (exports.Document = Document = {}));
class DocumentInteraction {
    constructor(document) {
        this.document = document;
        this.events = new Leaf.EventEmitter();
        _DocumentInteraction_dirty.set(this, false);
        _DocumentInteraction_isRemoved.set(this, false);
        this.lock = new Leaf.Lock();
        /*
        if (document["toString"]) {
            Object.defineProperty(document, "toString", {
                configurable: false,
                enumerable: false,
                value: () => {
                    return `${this.model?.descriptor?.name}(${document["id"]})`
                }
            })
        }
        */
    }
    get dirty() {
        return __classPrivateFieldGet(this, _DocumentInteraction_dirty, "f");
    }
    get isRemoved() {
        return __classPrivateFieldGet(this, _DocumentInteraction_isRemoved, "f");
    }
    get group() {
        return this.model.getGroup({
            name: this.document._meta.documentInterface.group.name,
            restriction: this.document._meta.documentInterface.restriction
        });
    }
    get model() {
        return this.document._meta.context.getModel(this.document._meta.documentInterface.model.uniqueName);
    }
    refresh() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.group.get({ id: this.document["id"] });
            if (!result) {
                __classPrivateFieldSet(this, _DocumentInteraction_isRemoved, true, "f");
                this.events.emit("remove");
                return;
            }
            let dirty = false;
            for (let key in this.document._meta.documentInterface.fields) {
                if (!Leaf.Util.deepEqual(this.document[key], result[key])) {
                    dirty = true;
                    this.document[key] = result[key];
                }
            }
            __classPrivateFieldSet(this, _DocumentInteraction_dirty, false, "f");
            if (dirty) {
                this.events.emit("change");
                this.events.emit("update");
            }
            return this.document;
        });
    }
    sets(v, markAsClean = false) {
        if (!v)
            return;
        for (let field of this.document._meta.documentInterface.model.fields) {
            if (!(field.key in v))
                continue;
            if (v[field.key] !== this.document[field.key]) {
                this.document[field.key] = v[field.key];
                __classPrivateFieldSet(this, _DocumentInteraction_dirty, true, "f");
            }
        }
        this.events.emit("change");
        if (markAsClean)
            __classPrivateFieldSet(this, _DocumentInteraction_dirty, false, "f");
    }
    update(data) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.lock.lock("update");
            try {
                yield this.group.update({
                    id: this.document["id"],
                    data
                });
                const next = yield this.group.get({ id: this.document["id"] });
                if (!next) {
                    throw new Error(`No longer exists: ${this.model.descriptor.uniqueName}(${this.document["id"]})`);
                }
                for (let key in this.document._meta.documentInterface.fields) {
                    const field = this.document._meta.documentInterface.fields[key];
                    if (field.availability == "virtual" && field.generate)
                        continue;
                    if (this.document[key] !== next[key]) {
                        this.document[key] = next[key];
                    }
                }
                this.events.emit("change");
                this.events.emit("update");
                return next;
            }
            finally {
                this.lock.release("update");
            }
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.group.update({
                id: this.document["id"],
                data: this.document,
            });
            this.events.emit("update");
            return this.document;
        });
    }
    remove() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.group.remove({ id: this.document["id"] });
            __classPrivateFieldSet(this, _DocumentInteraction_isRemoved, true, "f");
            this.events.emit("remove");
            return result;
        });
    }
}
exports.DocumentInteraction = DocumentInteraction;
_DocumentInteraction_dirty = new WeakMap(), _DocumentInteraction_isRemoved = new WeakMap();
class DocumentMeta {
    static make(context, documentInterface, data) {
        const meta = new DocumentMeta(context, documentInterface);
        meta.link(data);
        return data;
    }
    constructor(context, documentInterface) {
        this.context = context;
        this.documentInterface = documentInterface;
    }
    link(document) {
        if (!document)
            return document;
        if (typeof document !== "object")
            return document;
        if (document._) {
            return document;
        }
        Object.defineProperty(document, "_meta", {
            value: this,
            enumerable: false,
            writable: false,
            configurable: false,
        });
        Object.defineProperty(document, "_", {
            value: new DocumentInteraction(document),
            enumerable: false,
            writable: false,
            configurable: false,
        });
        for (let field of this.documentInterface.model.fields) {
            let desc = field;
            const key = field.key;
            if (desc.availability == "virtual" && typeof desc.generate == "function") {
                Object.defineProperty(document, key, {
                    get() {
                        if (!desc.generate) {
                            throw new errors_1.Errors.RuntimeError(`${desc.unique} expect a generate function, target js file may not be included`);
                        }
                        const fn = desc.generate;
                        return fn.call(document);
                    },
                });
            }
        }
        return document;
    }
}
exports.DocumentMeta = DocumentMeta;
var DocumentInterface;
(function (DocumentInterface) {
    function make(option) {
        const fields = option.fields || option.model.fields;
        const kvs = {};
        for (let fd of fields) {
            if (!aspect_field_1.FieldSpecification.OutputableAvailabilities.includes(fd.availability))
                continue;
            kvs[fd.key] = fd;
        }
        return {
            modelUniqueName: option.model.uniqueName,
            model: option.model,
            group: option.group,
            restriction: option.restriction,
            fields: kvs,
        };
    }
    DocumentInterface.make = make;
})(DocumentInterface || (exports.DocumentInterface = DocumentInterface = {}));
//# sourceMappingURL=document.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/domain.js":
/*!****************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/domain.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Projection_session, _Projection_requester, _Domain_all, _Domain_localOnly, _Domain_uses;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Domains = exports.DomainLike = exports.Projection = exports.Domain = void 0;
const context_1 = __webpack_require__(/*! ./context */ "./node_modules/@branch-ts/core/src/context.js");
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const resourceAction_1 = __webpack_require__(/*! ./resourceAction */ "./node_modules/@branch-ts/core/src/resourceAction.js");
const codex_1 = __webpack_require__(/*! ./codex/codex */ "./node_modules/@branch-ts/core/src/codex/codex.js");
const blueprint_1 = __webpack_require__(/*! ./codex/blueprint */ "./node_modules/@branch-ts/core/src/codex/blueprint.js");
const repository_1 = __webpack_require__(/*! ./repository */ "./node_modules/@branch-ts/core/src/repository.js");
const hook_1 = __webpack_require__(/*! ./hook */ "./node_modules/@branch-ts/core/src/hook.js");
const rpc_1 = __webpack_require__(/*! ./rpc */ "./node_modules/@branch-ts/core/src/rpc.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
const Const = __importStar(__webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/const.js"));
const access_1 = __webpack_require__(/*! ./access */ "./node_modules/@branch-ts/core/src/access.js");
const parameterRequirement_1 = __webpack_require__(/*! ./design/parameterRequirement */ "./node_modules/@branch-ts/core/src/design/parameterRequirement.js");
const criteria_1 = __webpack_require__(/*! @root-ts/criteria */ "./node_modules/@root-ts/criteria/index.js");
const config_1 = __webpack_require__(/*! ./config */ "./node_modules/@branch-ts/core/src/config.js");
const service_1 = __webpack_require__(/*! ./service */ "./node_modules/@branch-ts/core/src/service.js");
const i18n_1 = __webpack_require__(/*! ./i18n */ "./node_modules/@branch-ts/core/src/i18n.js");
const log_1 = __webpack_require__(/*! ./log */ "./node_modules/@branch-ts/core/src/log.js");
const manager_1 = __webpack_require__(/*! ./procedure/manager */ "./node_modules/@branch-ts/core/src/procedure/manager.js");
class DomainLike extends service_1.Service {
    constructor() {
        super(...arguments);
        this.locale = "en";
        this.codex = codex_1.Codex.current;
        this.isDebug = false;
    }
    get main() {
        return Domain.main;
    }
}
exports.DomainLike = DomainLike;
class Projection extends DomainLike {
    constructor(material, name = material.name || "projection") {
        super();
        this.material = material;
        this.name = name;
        this.blueprint = new blueprint_1.Blueprint(this.material);
        this.codex = this.blueprint.codex;
        this.kind = "projection";
        _Projection_session.set(this, void 0);
        this.configManager = new config_1.ConfigManager().include(this);
        this.events = new Leaf.EventEmitter();
        _Projection_requester.set(this, void 0);
        this.rpcProxy = new rpc_1.RpcResolveProxyProvider(this);
        this.configManager.setConfig(material.config);
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO
            return null;
        });
    }
    get session() {
        return __classPrivateFieldGet(this, _Projection_session, "f");
    }
    set session(s) {
        __classPrivateFieldSet(this, _Projection_session, s, "f");
    }
    getContext() {
        return new context_1.Context(this, __classPrivateFieldGet(this, _Projection_session, "f"));
    }
    get all() {
        var _a;
        return (_a = this.parent) === null || _a === void 0 ? void 0 : _a.all;
    }
    findAspect(name, match) {
        return this.blueprint.findAspect(name, match);
    }
    findAspects(name, match) {
        return this.blueprint.findAspects(name, match);
    }
    set requester(req) {
        if (__classPrivateFieldGet(this, _Projection_requester, "f"))
            __classPrivateFieldGet(this, _Projection_requester, "f").events.stopListenBy(this);
        __classPrivateFieldSet(this, _Projection_requester, req, "f");
        this.session = __classPrivateFieldGet(this, _Projection_requester, "f").session;
        __classPrivateFieldGet(this, _Projection_requester, "f").events.listenBy(this, "session", (session) => {
            this.session = __classPrivateFieldGet(this, _Projection_requester, "f").session;
        });
    }
    get requester() {
        return __classPrivateFieldGet(this, _Projection_requester, "f");
    }
    requestResourceAction(option) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.requester) {
                throw new errors_1.Errors.RuntimeError("Projection not initialized");
            }
            return yield this.requester.requestResourceAction(option);
        });
    }
    rpcCall(option) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.requester) {
                throw new errors_1.Errors.RuntimeError("Projection not initialized");
            }
            return yield this.requester.rpcCall(option);
        });
    }
    get rpcs() {
        return this.rpcProxy.getProxy();
    }
}
exports.Projection = Projection;
_Projection_session = new WeakMap(), _Projection_requester = new WeakMap();
const Global = Leaf.ensureGlobal("BranchDomainGlobal", () => {
    return {};
});
class Domain extends DomainLike {
    static get main() {
        return Global.main;
    }
    constructor(blueprint, name = "domain") {
        super();
        this.blueprint = blueprint;
        this.name = name;
        _Domain_all.set(this, new Domains());
        this.projections = {};
        _Domain_localOnly.set(this, false);
        this.ready = new Leaf.ReadyBehavior();
        _Domain_uses.set(this, ["*"]);
        this.kind = "domain";
        this.environment = {};
        this.serviceContext = new service_1.DomainServiceContext(this);
        this.services = this.serviceContext.services;
        this.codex = this.blueprint.codex;
        this.accessControl = new access_1.AccessControl(this);
        this.repositoryManager = new repository_1.RepositoryManager(this);
        this.configManager = config_1.GlobalConfigManager.include(this);
        this.i18nManager = i18n_1.GlobalI18nManager.include(this);
        this.procedures = new manager_1.ProcedureManager(this);
        this.hookManager = new hook_1.HookManager(this);
        this.rpc = new rpc_1.RpcDistributer(this);
        __classPrivateFieldGet(this, _Domain_all, "f").include(this);
    }
    asMain() {
        Global.main = this;
    }
    get all() {
        return __classPrivateFieldGet(this, _Domain_all, "f");
    }
    registerProject(projection, name = projection.name) {
        if (this.projections[name]) {
            log_1.Logger.warn("Projection", name, "already exists");
            return;
        }
        this.projections[name] = projection;
        projection.parent = this;
        __classPrivateFieldGet(this, _Domain_all, "f").include(projection);
    }
    local() {
        __classPrivateFieldSet(this, _Domain_localOnly, true, "f");
        return this;
    }
    getProjection(name) {
        return this.projections[name];
    }
    getContext(session) {
        if (__classPrivateFieldGet(this, _Domain_localOnly, "f")) {
            return this.getSystemContext(session);
        }
        return new context_1.Context(this, session);
    }
    getSystemContext(session = Const.DefaultSystemSessionInfo) {
        return new context_1.DomainSystemContext(this, session);
    }
    getAllServices() {
        return this.serviceContext.allServices.slice();
    }
    setupConfig(option) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.blueprint.material.config) {
                this.configManager.setConfig(this.blueprint.material.config);
            }
            if (option.config) {
                this.configManager.setConfig(option.config);
            }
        });
    }
    setupServices(option) {
        return __awaiter(this, void 0, void 0, function* () {
            if (option.uses) {
                this.uses = option.uses;
            }
            this.serviceContext.loadServiceFromDomain(...this.uses);
            yield this.serviceContext.setup();
        });
    }
    mayMigrate(option) {
        return __awaiter(this, void 0, void 0, function* () {
            if (option.migrate) {
                log_1.Logger.log("May migrate");
                let info = yield this.getSystemContext().single("Core.ApplicationInfo");
                let from = (info === null || info === void 0 ? void 0 : info.version) || 0;
                let to = this.blueprint.material.version || 0;
                if (to > from) {
                    yield this.migrateTo({
                        from: (info === null || info === void 0 ? void 0 : info.version) || 0,
                        to: this.blueprint.material.version || 0,
                    });
                    yield info._.update({
                        version: to,
                    });
                }
            }
        });
    }
    setup(option = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setupConfig(option);
            yield this.mayMigrate(option);
            yield this.setupServices(option);
            this.ready.yes();
        });
    }
    set uses(uses) {
        if (uses.length == 0) {
            __classPrivateFieldSet(this, _Domain_uses, ["*"], "f");
        }
        if (typeof uses == "string") {
            __classPrivateFieldSet(this, _Domain_uses, [uses], "f");
        }
        if (!this.uses) {
            __classPrivateFieldSet(this, _Domain_uses, uses, "f");
        }
    }
    get uses() {
        return __classPrivateFieldGet(this, _Domain_uses, "f");
    }
    findAspect(name, match) {
        return this.blueprint.findAspect(name, match);
    }
    findAspects(name, match) {
        return this.blueprint.findAspects(name, match);
    }
    requestResourceAction(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const action = yield this.createResourceAction(option);
            const context = new resourceAction_1.SafeResourceActionContext({
                descriptor: action,
                domain: this
            });
            return yield context.execute();
        });
    }
    createResourceAction(option) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let condition = null;
            const model = this.findAspect("model", { uniqueName: option.descriptor.modelUniqueName });
            if (!model) {
                throw new errors_1.Errors.NotFound(`${option.descriptor.modelUniqueName} not found`);
            }
            const group = this.findAspect("group", {
                modelUniqueName: model.uniqueName,
                name: option.descriptor.groupName || Const.DefaultGroupName
            });
            if (((_b = (_a = group.hardRestrictionTemplate) === null || _a === void 0 ? void 0 : _a.ors) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                const paramRequirements = new parameterRequirement_1.ParameterRequirements(group.hardRestrictionRequirements);
                paramRequirements.check(option.descriptor.restriction);
                const builder = new criteria_1.TemplateBuilder();
                builder.criteria = group.hardRestrictionTemplate;
                condition = builder.build(option.descriptor.restriction);
            }
            const keys = Object.keys(option.descriptor.action);
            const kind = keys[0];
            const arg = option.descriptor.action[kind];
            const action = {
                model,
                group,
                fieldDescriptors: model.fields,
                fieldDescriptorKVs: Object.fromEntries(model.fields.map(field => [field.key, field])),
                condition,
                session: option.session,
                domain: this,
                action: {
                    [kind]: arg
                },
                locale: option.descriptor.locale,
                access: null,
            };
            if (this.accessControl.isSystem(option.session)) {
                action.access = access_1.SystemAccess;
                return action;
            }
            // Pick access available for the model
            let acc = yield this.accessControl.access({
                request: option.descriptor,
                session: option.session,
            });
            action.access = acc;
            return action;
        });
    }
    migrateTo(option) {
        return __awaiter(this, void 0, void 0, function* () {
            let version = option.to;
            let from = option.from || 0;
            let migrates = this.findAspects("migration").filter(desc => {
                return desc.version <= version;
            });
            if (migrates.length == 0) {
                this.version = option.to;
                return;
            }
            migrates.sort((a, b) => a.version - b.version);
            log_1.Logger.log(`Start migrating from ${option.from} to ${version}`);
            let currentVersion = version;
            for (let desc of migrates) {
                let migration = new desc.cons();
                yield migration.upgrade({
                    domain: this,
                    from: from,
                });
                currentVersion = desc.version;
            }
            log_1.Logger.log(`Migrated to ${version}`);
            this.version = option.to;
            return;
        });
    }
}
exports.Domain = Domain;
_Domain_all = new WeakMap(), _Domain_localOnly = new WeakMap(), _Domain_uses = new WeakMap();
class Domains {
    constructor() {
        this.domains = [];
    }
    include(domain) {
        if (this.domains.includes(domain))
            return;
        this.domains.push(domain);
    }
    domainOfAspect(aspect) {
        for (let domain of this.domains) {
            if (domain.findAspect(aspect.aspectName, { uniqueName: aspect.uniqueName }))
                return domain;
        }
    }
    findDomainAspect(name, match) {
        let aspect = null;
        const domain = this.domains.find(domain => aspect = domain.findAspect(name, match));
        if (!aspect)
            return null;
        if (!domain)
            return null;
        return {
            aspect,
            domain
        };
    }
    findAspect(name, match) {
        let result = null;
        this.domains.find(domain => result = domain.findAspect(name, match));
        return result;
    }
    findAspects(name, match) {
        return [].concat(...this.domains.map(domain => domain.findAspects(name, match)));
    }
    requestResourceAction(option) {
        const domain = this.domains.find(domain => domain.findAspect("model", { uniqueName: option.descriptor.modelUniqueName }));
        return domain.requestResourceAction(option);
    }
}
exports.Domains = Domains;
//# sourceMappingURL=domain.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/errors.js":
/*!****************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/errors.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Errors = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
exports.Errors = Leaf.ErrorDoc.build({
    DesignError: {},
    LogicError: {},
    CompatabilityError: {},
    RuntimeError: {},
    NotReady: {},
    ConditionError: {},
    Forbidden: {},
    NotFound: {},
    AlreadyExists: {},
    Expired: {},
    Abort: {},
    AuthorizationFailed: {},
    IllegalUserInputs: {},
    IntegrityError: {},
    UnknownError: {},
    DocumentError: {},
    InvalidParameters: {},
    Timeout: {},
});
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/group.js":
/*!***************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/group.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupRestriction = exports.Group = void 0;
__webpack_require__(/*! @root-ts/criteria */ "./node_modules/@root-ts/criteria/index.js");
const document_1 = __webpack_require__(/*! ./document */ "./node_modules/@branch-ts/core/src/document.js");
const criteria_1 = __webpack_require__(/*! @root-ts/criteria */ "./node_modules/@root-ts/criteria/index.js");
let Group = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _get_meta_decorators;
    return _a = class Group {
            constructor(model, descriptor, restriction) {
                this.model = (__runInitializers(this, _instanceExtraInitializers), model);
                this.descriptor = descriptor;
                this.restriction = restriction;
                this.supportedActions = _a.actions.slice();
            }
            playAction(kind, option = null) {
                return __awaiter(this, void 0, void 0, function* () {
                    const req = {
                        modelUniqueName: this.model.descriptor.uniqueName,
                        groupName: this.descriptor.name,
                        restriction: this.restriction,
                        action: {
                            [kind]: option
                        }
                    };
                    return yield this.model.context.requestResourceAction({
                        descriptor: req
                    });
                });
            }
            count() {
                return __awaiter(this, void 0, void 0, function* () {
                    const res = yield this.playAction("count");
                    return res.result;
                });
            }
            all() {
                return __awaiter(this, void 0, void 0, function* () {
                    const res = yield this.playAction("all");
                    return this.signs(res.result);
                });
            }
            query(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    const res = yield this.playAction("query", option);
                    return this.signs(res.result);
                });
            }
            some(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    const res = yield this.playAction("some", option);
                    return this.signs(res.result);
                });
            }
            gets(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    const criteria = new criteria_1.CriteriaBuilder();
                    for (let key in option) {
                        criteria.path(key).eq(option[key]);
                    }
                    return yield this.query({
                        offset: 0,
                        count: -1,
                        match: criteria.build()
                    });
                });
            }
            get(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    const res = yield this.playAction("get", option);
                    return this.sign(res.result);
                });
            }
            update(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    yield this.playAction("update", option);
                });
            }
            updates(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    yield this.playAction("updates", option);
                });
            }
            remove(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    yield this.playAction("remove", option);
                });
            }
            removes(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    yield this.playAction("removes", option);
                });
            }
            create(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    const res = yield this.playAction("create", option);
                    return this.sign(res.result);
                });
            }
            creates(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    const res = yield this.playAction("creates", option);
                    return this.signs(res.result);
                });
            }
            get meta() {
                return new document_1.DocumentMeta(this.model.context, document_1.DocumentInterface.make({
                    model: this.model.descriptor,
                    group: this.descriptor,
                    restriction: this.restriction
                }));
            }
            sign(data) {
                if (!data)
                    return data;
                const inf = this.meta.documentInterface;
                const result = {};
                for (let key in inf.fields) {
                    const field = inf.fields[key];
                    if (field.readProtect)
                        continue;
                    result[key] = data[key];
                }
                return this.meta.link(result);
            }
            signs(datas) {
                if (!datas)
                    return datas;
                return datas.map(data => {
                    return this.sign(data);
                });
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _get_meta_decorators = [Leaf.cache()];
            __esDecorate(_a, null, _get_meta_decorators, { kind: "getter", name: "meta", static: false, private: false, access: { has: obj => "meta" in obj, get: obj => obj.meta }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a.actions = [
            "count", "all", "query", "some", "get", "update", "updates", "remove", "removes", "create", "creates"
        ],
        _a.actionKind = {
            read: ["count", "all", "query", "some", "get"],
            write: ["update", "updates"],
            create: ["create", "creates"],
            delete: ["remove", "removes"]
        },
        _a;
})();
exports.Group = Group;
var GroupRestriction;
(function (GroupRestriction) {
    function getGroupFullRestriction(option) {
        const softRestriction = option.match && option.match.ors && option.match || null;
        const template = new criteria_1.TemplateBuilder();
        if (option.descriptor.hardRestrictionTemplate && option.descriptor.hardRestrictionTemplate.ors) {
            template.criteria = option.descriptor.hardRestrictionTemplate;
            const hard = template.build(option.restriction);
            return criteria_1.Criteria.and(hard, softRestriction);
        }
        else {
            return Leaf.Util.clone(softRestriction);
        }
    }
    GroupRestriction.getGroupFullRestriction = getGroupFullRestriction;
    function getImpliedRestrictionValues(option) {
        const result = {};
        const params = option.restriction && Leaf.Util.clone(option.restriction) || {};
        let ors = option.descriptor.hardRestrictionTemplate && option.descriptor.hardRestrictionTemplate.ors || [];
        for (let or of ors) {
            for (let and of or.ands) {
                if (and.type == "eq") {
                    result[and.path] = params[and.reference];
                }
            }
        }
        return result;
    }
    GroupRestriction.getImpliedRestrictionValues = getImpliedRestrictionValues;
})(GroupRestriction || (exports.GroupRestriction = GroupRestriction = {}));
//# sourceMappingURL=group.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/hook.js":
/*!**************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/hook.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HookManager = exports.Hook = void 0;
const util_1 = __webpack_require__(/*! ./util */ "./node_modules/@branch-ts/core/src/util.js");
class Hook {
    onBeforeCreate(ctx) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    onCreate(ctx) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    onBeforeUpdate(ctx) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    onUpdate(ctx) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    onBeforeRemove(ctx) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    onRemove(ctx) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
}
exports.Hook = Hook;
class HookManager {
    constructor(domain) {
        this.domain = domain;
    }
    ensureHooks() {
        if (this.hooks)
            return;
        const hooks = this.domain.findAspects("hook");
        this.hooks = hooks.map(hook => {
            const ins = new hook.cons;
            ins.domain = this.domain;
            ins.modelUniqueName = hook.model;
            return ins;
        });
    }
    trigger(modelUniqueName, option) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO
            if (!this.hooks)
                this.ensureHooks();
            const hooks = this.hooks.filter(hook => hook.modelUniqueName === modelUniqueName);
            const handler = option.phase;
            for (let hook of hooks) {
                hook.domain = this.domain;
                if (!Object.getOwnPropertyDescriptor(hook, "context")) {
                    Object.defineProperty(hook, "context", {
                        get: () => {
                            throw new Error("Hook should no longer using this.context using option.context or this.rootContext instead");
                        }
                    });
                }
                if (!hook[handler])
                    continue;
                yield hook[handler](option);
            }
        });
    }
}
exports.HookManager = HookManager;
util_1.Util.markBaseConstructor(Hook);
//# sourceMappingURL=hook.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/i18n.js":
/*!**************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/i18n.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _I18nManager_domains, _I18nManager_defaultLocale, _I18n_locale;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringTemplateTester = exports.I18n = exports.GlobalI18nManager = exports.I18nLocaleMaterial = exports.I18nManager = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const domain_1 = __webpack_require__(/*! ./domain */ "./node_modules/@branch-ts/core/src/domain.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
class I18nManager {
    constructor() {
        _I18nManager_domains.set(this, void 0);
        _I18nManager_defaultLocale.set(this, void 0);
        this.locales = {};
    }
    get domains() {
        return __classPrivateFieldSet(this, _I18nManager_domains, __classPrivateFieldGet(this, _I18nManager_domains, "f") || new domain_1.Domains(), "f");
    }
    decorateToNewConstructor(Cons, context, runtime) {
        const self = this;
        return class extends Cons {
            constructor(...args) {
                super(args);
                this.locale = (locale) => {
                    return self.getProxy(this, runtime, locale);
                };
                return self.getProxy(this, runtime, "default");
            }
        };
    }
    include(domain) {
        this.domains.include(domain);
        return this;
    }
    getProxy(i18n, runtime, locale = "en") {
        var _a;
        const namespace = ((_a = runtime.inputs) === null || _a === void 0 ? void 0 : _a.namespace) || runtime.ambientNamespace;
        const uniqueName = namespace + "." + runtime.name;
        return new Proxy(i18n, {
            get: (target, key) => {
                var _a, _b;
                const blacklist = ["locale", "setLocale"];
                if (blacklist.includes(key)) {
                    return Reflect.get(i18n, key);
                }
                const lang = this.getLocale(locale);
                const ret = (_a = lang[uniqueName]) === null || _a === void 0 ? void 0 : _a.getLead(key);
                if (ret)
                    return ret;
                const result = (_b = this.getLocale("default")[uniqueName]) === null || _b === void 0 ? void 0 : _b.getLead(key);
                if (result)
                    return result;
                return i18n[key];
            },
            set: (target, key) => {
                console.error("settings", key);
                return true;
            }
        });
    }
    generateDefaultLocale() {
        const i18ns = this.domains.findAspects("i18n");
        const material = {};
        for (let i18n of i18ns) {
            material[i18n.uniqueName] = new I18nLocaleMaterial(i18n.material);
        }
        return material;
    }
    generateLocale(materials) {
        materials = materials || {};
        const i18ns = this.domains.findAspects("i18n");
        const result = {};
        const defaults = this.defaultLocale;
        for (let i18n of i18ns) {
            result[i18n.uniqueName] = new I18nLocaleMaterial(materials[i18n.uniqueName] || defaults[i18n.uniqueName].material);
        }
        return result;
    }
    getLocale(locale) {
        if (locale === "default")
            return this.defaultLocale;
        if (this.locales[locale])
            return this.locales[locale];
        return this.defaultLocale;
    }
    setDefaultLocale(locale) {
        __classPrivateFieldSet(this, _I18nManager_defaultLocale, this.locales[locale] || __classPrivateFieldGet(this, _I18nManager_defaultLocale, "f"), "f");
    }
    get defaultLocale() {
        if (!__classPrivateFieldGet(this, _I18nManager_defaultLocale, "f"))
            __classPrivateFieldSet(this, _I18nManager_defaultLocale, this.generateDefaultLocale(), "f");
        return __classPrivateFieldGet(this, _I18nManager_defaultLocale, "f");
    }
}
exports.I18nManager = I18nManager;
_I18nManager_domains = new WeakMap(), _I18nManager_defaultLocale = new WeakMap();
class I18nLocaleMaterial {
    constructor(material) {
        this.material = material;
    }
    getProxy() {
        return new Proxy({}, {
            get: (target, key) => {
                return this.getLead(key);
            }
        });
    }
    getLead(lead) {
        let value = this.material[lead];
        let reg = /{{([a-zA-Z0-9._]+)(:[^}]*)?}}/g;
        if (reg.test(value)) {
            return (data) => {
                return Leaf.renderString(value, data);
            };
        }
        else {
            return value;
        }
    }
    static instanceToMaterial(instance) {
        let blacklist = ["constructor", "locale", "setLocale"];
        let material = {};
        for (let key in instance) {
            if (blacklist.includes(key))
                continue;
            let v = instance[key];
            if (typeof v == "string") {
                material[key] = v;
            }
            else if (typeof v == "function") {
                material[key] = this.renderFunctionToTemplateString(v);
            }
        }
        for (let key of Object.getOwnPropertyNames(instance.constructor.prototype)) {
            if (blacklist.includes(key))
                continue;
            const v = instance[key];
            if (typeof v == "function") {
                material[key] = this.renderFunctionToTemplateString(v);
            }
        }
        return material;
    }
    static renderFunctionToTemplateString(fn) {
        let option = {};
        let reverse = {};
        const detector = new Proxy({}, {
            get: (target, key) => {
                if (!option[key]) {
                    option[key] = `##${Math.random().toString().slice(3)}##`;
                    reverse[option[key]] = key;
                }
                return option[key];
            }
        });
        const result = fn(detector);
        if (typeof result !== "string") {
            throw new errors_1.Errors.DesignError("String template should return string");
        }
        if (Object.keys(option).length == 0)
            return result;
        const reg = new RegExp(Object.keys(option).map(key => "(" + option[key] + ")").join("|"), "g");
        let parts = [];
        let offset = 0;
        while (true) {
            const match = reg.exec(result);
            if (!match) {
                parts.push(result.slice(offset));
                break;
            }
            const key = reverse[match[0]];
            parts.push(result.slice(offset, match.index));
            offset = match.index + match[0].length;
            parts.push(`{{${key}}}`);
        }
        return parts.join("");
    }
}
exports.I18nLocaleMaterial = I18nLocaleMaterial;
exports.GlobalI18nManager = Leaf.ensureGlobal("BranchTsGlobalI18nManager", () => new I18nManager());
class I18n {
    constructor() {
        _I18n_locale.set(this, "en");
    }
    setLocale(locale) {
        __classPrivateFieldSet(this, _I18n_locale, locale, "f");
    }
}
exports.I18n = I18n;
_I18n_locale = new WeakMap();
class StringTemplateTester {
}
exports.StringTemplateTester = StringTemplateTester;
//# sourceMappingURL=i18n.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/keeper.js":
/*!****************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/keeper.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskKeeper = exports.DocumentKeeper = exports.DelegateIntention = exports.DelegatedRepository = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const criteria_1 = __webpack_require__(/*! @root-ts/criteria */ "./node_modules/@root-ts/criteria/index.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
const repository_1 = __webpack_require__(/*! ./repository */ "./node_modules/@branch-ts/core/src/repository.js");
const log_1 = __webpack_require__(/*! ./log */ "./node_modules/@branch-ts/core/src/log.js");
Error.stackTraceLimit = Infinity;
class DelegatedRepository extends repository_1.Repository {
    constructor(option) {
        super(option);
        this.option = option;
        this.keepers = {};
        this.model = this.option.model;
        this.backer = this.option.backer;
        this.ready.yes();
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loads();
        });
    }
    loads() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.option.loadCondition && this.backer) {
                let toLoads;
                if (this.option.loadCondition === true) {
                    const res = yield this.backer.all({});
                    toLoads = res.result;
                }
                else {
                    const res = yield this.backer.all({
                        condition: this.option.loadCondition
                    });
                    toLoads = res.result;
                }
                for (let todo of toLoads) {
                    const keeper = yield this.createKeeper(todo);
                    yield this.handleKeeperLoad(keeper);
                }
            }
        });
    }
    handleKeeperLoad(keeper) {
        return __awaiter(this, void 0, void 0, function* () {
            if (keeper.onLoad) {
                const smartKeeper = yield keeper.onLoad();
                if (smartKeeper) {
                    keeper = smartKeeper;
                }
            }
            this.keepers[keeper.data["id"]] = keeper;
            return keeper;
        });
    }
    createKeeper(data, option = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!data["id"]) {
                throw new Error("Invalid keeper data without id");
            }
            // TODO
            const Cons = this.option.keeper;
            let keeper = new Cons({
                repo: this,
                data,
            });
            if (option.lock) {
                yield keeper.intention.lock.lock(option.lock);
            }
            this.keepers[data["id"]] = keeper;
            return keeper;
        });
    }
    one(option) {
        return __awaiter(this, void 0, void 0, function* () {
            let one = null;
            if (this.backer) {
                const res = yield this.backer.one(option);
                one = res.result;
                if (this.keepers[one["id"]]) {
                    one = this.keepers[one["id"]].data;
                }
            }
            else {
                for (let id in this.keepers) {
                    if (criteria_1.Criteria.test(option.condition, this.keepers[id].data)) {
                        one = this.keepers[id].data;
                        break;
                    }
                }
            }
            return this.success(one);
        });
    }
    some(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.all(option);
        });
    }
    // always remove on only
    remove(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const one = yield this.one(option);
            if (!this.keepers[one["id"]]) {
                if (this.backer) {
                    return yield this.backer.remove(option);
                }
                else {
                    return this.success(0);
                }
            }
            else {
                const keeper = this.keepers[one["id"]];
                if (keeper.onBeforeRemove) {
                    yield keeper.onBeforeRemove();
                }
                delete this.keepers[one["id"]];
                if (this.backer) {
                    yield this.backer.remove(option);
                }
                yield keeper.onRemove();
                return this.success(1);
            }
        });
    }
    count(option) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.backer) {
                return this.backer.count(option);
            }
            const res = yield this.all(option);
            return this.success(res.result.length);
        });
    }
    inserts(option) {
        return __awaiter(this, void 0, void 0, function* () {
            let keepers = [];
            for (let data of option.datas) {
                const id = data["id"];
                if (this.keepers[id]) {
                    continue;
                }
                const keeper = yield this.createKeeper(data, { lock: "create" });
                if (keeper.onBeforeCreate) {
                    yield keeper.onBeforeCreate(data);
                }
                keepers.push(keeper);
            }
            if (this.backer) {
                keepers = yield Promise.all(keepers.map((keeper) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield this.backer.inserts({ datas: [keeper.data] });
                    }
                    catch (e) {
                        return null;
                    }
                    try {
                        return this.handleKeeperLoad(keeper);
                    }
                    catch (e) {
                        return null;
                    }
                })));
            }
            else {
                keepers = yield Promise.all(keepers.map((keeper) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield this.handleKeeperLoad(keeper);
                    }
                    catch (e) {
                        return null;
                    }
                })));
            }
            keepers = keepers.filter(keeper => !!keeper);
            for (let keeper of keepers) {
                keeper.intention.lock.release("create");
            }
            for (let keeper of keepers) {
                this.keepers[keeper.data["id"]] = keeper;
                if (keeper.onCreate) {
                    yield keeper.onCreate();
                }
            }
            return this.success(keepers.map(keeper => keeper.data), keepers.length);
        });
    }
    update(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.one(option);
            const one = res.result;
            if (!one) {
                throw new errors_1.Errors.NotFound();
            }
            let keeper = this.keepers[one["id"]];
            if (!keeper) {
                keeper = yield this.createKeeper(res.result);
            }
            if (keeper.onBeforeUpdate) {
                yield keeper.onBeforeUpdate({ data: option.data });
            }
            if (this.backer) {
                yield this.backer.update(option);
            }
            for (let key in option.data) {
                if (typeof option.data[key] !== "undefined") {
                    keeper.data[key] = option.data[key];
                }
            }
            if (keeper.onUpdate) {
                yield keeper.onUpdate();
            }
            return this.success(null);
        });
    }
    all(option) {
        return __awaiter(this, void 0, void 0, function* () {
            let all = [];
            if (this.backer) {
                const res = yield this.backer.all(option);
                all = res.result.slice();
                all = this.replaceKeepers(all);
            }
            else {
                all = Object.keys(this.keepers).map(id => this.keepers[id].data).filter(item => {
                    if (!option.condition)
                        return true;
                    return criteria_1.Criteria.test(option.condition, item);
                });
                const offset = option.offset || 0;
                if (option.count && option.count > 0) {
                    all = all.slice(option.offset, option.offset + option.count);
                }
                else {
                    all = all.slice(option.offset);
                }
                this.sort({ sort: option.sort, arr: all });
            }
            return this.success(all);
        });
    }
    sort(option) {
        const all = option.arr;
        if (option.sort && Object.keys(option.sort).length > 0) {
            all.sort((a, b) => {
                for (let key in option.sort) {
                    const order = option.sort[key];
                    if (a[key] == b[key])
                        continue;
                    if (a[key] < b[key]) {
                        return order;
                    }
                    else if (a[key] > b[key]) {
                        return -order;
                    }
                }
                return 0;
            });
        }
        return all;
    }
    success(data, count = 0) {
        return {
            modifiedCount: count,
            duration: null,
            result: data
        };
    }
    replaceKeepers(datas) {
        return datas.map(data => {
            if (this.keepers[data["id"]]) {
                return this.keepers[data["id"]].data;
            }
            else {
                return data;
            }
        });
    }
}
exports.DelegatedRepository = DelegatedRepository;
class DelegateIntention {
    constructor(repo, keeper) {
        this.repo = repo;
        this.keeper = keeper;
        this.isDismissed = false;
        this.domain = this.repo.domain;
        this.lock = new Leaf.Lock();
    }
    // Save keeper data to persistent storage.
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.lock.lock();
            try {
                if (!this.repo.backer) {
                    throw new errors_1.Errors.LogicError(`${this.repo.model.uniqueName} has no backend repository specified, thus can't be saved.`);
                }
                const idCondition = new criteria_1.CriteriaBuilder().path("id").eq(this.keeper.data["id"]).build();
                const one = yield this.repo.backer.one({
                    condition: idCondition
                }).catch(e => null);
                if (one) {
                    yield this.repo.backer.update({
                        condition: idCondition,
                        data: this.keeper.data
                    });
                }
                else {
                    yield this.repo.backer.inserts({
                        datas: [this.keeper.data]
                    });
                }
            }
            finally {
                this.lock.release();
            }
        });
    }
    // Disgard what ever in persistent storage,
    // remove keeper from memory
    dismiss() {
        return __awaiter(this, void 0, void 0, function* () {
            delete this.repo.keepers[this.keeper.data["id"]];
        });
    }
}
exports.DelegateIntention = DelegateIntention;
class DocumentKeeper {
    constructor(option) {
        this.option = option;
        this.repo = this.option.repo;
        this.data = this.option.data;
        this.intention = new DelegateIntention(this.repo, this);
        const self = this;
        Object.defineProperty(this, "services", {
            get() {
                return self.domain.services;
            }
        });
    }
    get domain() {
        return this.repo.domain;
    }
}
exports.DocumentKeeper = DocumentKeeper;
class TaskKeeper extends DocumentKeeper {
    constructor() {
        super(...arguments);
        this.lock = new Leaf.Lock();
    }
    onLoad() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.data.state !== "pending")
                return;
            this.execute();
        });
    }
    onUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.data.state == "pending") {
                this.execute();
            }
        });
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.lock.isLock())
                return;
            yield this.lock.lock();
            try {
                this.data.state = "running";
                yield this.intention.save();
                yield this.run();
                this.data.state = "success";
                yield this.intention.save();
            }
            catch (e) {
                this.data.state = "error";
                this.data.error = `${e.name}: ${e.message}`;
                log_1.Logger.error(e);
                yield this.intention.save();
            }
            finally {
                this.lock.release();
            }
        });
    }
}
exports.TaskKeeper = TaskKeeper;
//# sourceMappingURL=keeper.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/log.js":
/*!*************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/log.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = void 0;
exports.Logger = {
    log(...args) {
        return console.log(...args);
    },
    warn(...args) {
        return console.error(...args);
    },
    error(...args) {
        return console.error(...args);
    },
    debug(...args) {
        if (console.debug)
            return console.debug(...args);
        return console.error(...args);
    },
    info(...args) {
        exports.Logger.log(...args);
    }
};
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/mechanism.js":
/*!*******************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/mechanism.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Mechanism = void 0;
let Mechanism = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _access_decorators;
    let _ensure_decorators;
    return _a = class Mechanism {
            static make(factory = () => { return {}; }, name = undefined) {
                return new _a(factory, name);
            }
            constructor(factory, name) {
                this.factory = (__runInitializers(this, _instanceExtraInitializers), factory);
                this.name = name;
                this.symbol = Symbol(this.name);
                if (!this.name)
                    this.name = this.constructor.name;
            }
            access(target) {
                if (!target)
                    return null;
                return target[this.symbol];
            }
            ensure(target) {
                let exists = this.access(target);
                if (!exists) {
                    exists = this.factory(target);
                    target[this.symbol] = exists;
                }
                return exists;
            }
            reset(target) {
                if (!target)
                    return;
                delete target[this.symbol];
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _access_decorators = [Leaf.bound()];
            _ensure_decorators = [Leaf.bound()];
            __esDecorate(_a, null, _access_decorators, { kind: "method", name: "access", static: false, private: false, access: { has: obj => "access" in obj, get: obj => obj.access }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _ensure_decorators, { kind: "method", name: "ensure", static: false, private: false, access: { has: obj => "ensure" in obj, get: obj => obj.ensure }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.Mechanism = Mechanism;
//# sourceMappingURL=mechanism.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/migration.js":
/*!*******************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/migration.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Migration = void 0;
class Migration {
    constructor(version) {
        this.version = version;
    }
}
exports.Migration = Migration;
//# sourceMappingURL=migration.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/model.js":
/*!***************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/model.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Model_fieldKVS;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Model = void 0;
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
const group_1 = __webpack_require__(/*! ./group */ "./node_modules/@branch-ts/core/src/group.js");
class Model {
    constructor(context, descriptor) {
        this.context = context;
        this.descriptor = descriptor;
        _Model_fieldKVS.set(this, void 0);
    }
    getGroup(...args) {
        return this.group(...args);
    }
    group(option = {}) {
        const name = option.name || "defaultGroup";
        const groupDescriptor = this.context.domain.findAspect("group", {
            modelUniqueName: this.descriptor.uniqueName,
            name,
        });
        if (!groupDescriptor) {
            throw new errors_1.Errors.RuntimeError(`Group ${name} not found`);
        }
        const group = new group_1.Group(this, groupDescriptor, option.restriction);
        return group;
    }
    getField(name) {
        return this.fieldKVS[name];
    }
    get fields() { return this.descriptor.fields; }
    get fieldKVS() {
        if (__classPrivateFieldGet(this, _Model_fieldKVS, "f"))
            return __classPrivateFieldGet(this, _Model_fieldKVS, "f");
        const result = {};
        for (let field of this.fields) {
            if (field.availability == "transient")
                continue;
            result[field.key] = field;
        }
        __classPrivateFieldSet(this, _Model_fieldKVS, result, "f");
        return result;
    }
    query(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.group().query(option);
        });
    }
    some(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.group().some(option);
        });
    }
    gets(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.group().gets(option);
        });
    }
    get(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.group().get(option);
        });
    }
    update(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.group().update(option);
        });
    }
    updates(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.group().updates(option);
        });
    }
    remove(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.group().remove(option);
        });
    }
    removes(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.group().removes(option);
        });
    }
    create(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.group().create(option);
        });
    }
    creates(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.group().creates(option);
        });
    }
}
exports.Model = Model;
_Model_fieldKVS = new WeakMap();
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/namespace.js":
/*!*******************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/namespace.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Namespace_namespace;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LeveledNamespaceResolver = exports.ConvenientNamespaceResolver = exports.GlobalNamespace = exports.Namespace = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const Const = __importStar(__webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/const.js"));
const log_1 = __webpack_require__(/*! ./log */ "./node_modules/@branch-ts/core/src/log.js");
class Namespace {
    constructor() {
        _Namespace_namespace.set(this, Const.DefaultNamespace);
    }
    static match(option) {
        const matcher = option.matcher;
        if (Array.isArray(matcher)) {
            return matcher.some(matcher => {
                return Namespace.match(Object.assign(Object.assign({}, option), { matcher }));
            });
        }
        else {
            const name = option.name;
            let regString = (option.head && "^" || "")
                + matcher.replace(/\*/ig, ".*").replace(/\+/ig, ".+")
                + (option.tail && "$" || "");
            const reg = new RegExp(regString);
            return reg.test(name);
        }
    }
    static filterAspects(items, ...matchers) {
        return items.filter(item => {
            return matchers.some(matcher => {
                return Namespace.match({
                    matcher,
                    name: item.uniqueName,
                    head: true,
                    tail: true
                });
            });
        });
    }
    get defaultNamespace() {
        return Const.DefaultNamespace;
    }
    namespace(namespace) {
        __classPrivateFieldSet(this, _Namespace_namespace, namespace, "f");
    }
    get ambientNamespace() {
        return __classPrivateFieldGet(this, _Namespace_namespace, "f");
    }
    getNameUniqueName(option) {
        const namespace = option.namespace || this.defaultNamespace;
        if (!option.name) {
            throw new Error(`Uniquename missing option.name`);
        }
        return [namespace, option.name].join(".");
    }
    ensureUniqueName(name, namespace = this.defaultNamespace) {
        if (/[a-z_-]/.test(name[0]) || !name) {
            throw new Error(`Fail to parse invalid name to model unique name:${name}`);
        }
        if (name.indexOf(".") > 0) {
            return name;
        }
        return [namespace || Const.DefaultNamespace, name].join(".");
    }
    getNamespaceFromName(name) {
        const parts = name.split(".");
        if (parts.length == 1) {
            return null;
        }
        else {
            parts.pop();
            return parts.join(".");
        }
    }
    parseNaming(str, defaultNamespace = this.defaultNamespace) {
        let scope = false;
        if (str[0] == "@") {
            str = str.slice(1);
            scope = true;
        }
        const parts = str.split(".");
        const ns = [];
        while (true) {
            const part = parts.shift();
            if (!part)
                break;
            if (this.isNamespaceLike(part)) {
                ns.push(part);
            }
            else {
                parts.unshift(part);
                break;
            }
        }
        const name = ns.pop();
        const namespace = ns.join(".") || defaultNamespace;
        let uniqueName = [namespace, name].join(".");
        if (!name) {
            uniqueName = null;
        }
        const result = {
            uniqueName: uniqueName,
            name: name,
            path: parts.join(".") || undefined,
            scope,
        };
        return result;
    }
    isNamespaceLike(str) {
        return Leaf.Util.capitalize(str) == str && Leaf.Util.uncapitalize(str) !== str;
    }
    isMatchNameOrFullName(target, nameLike) {
        if (target === nameLike)
            return true;
        const parsed = this.parseNaming(target);
        return parsed.name === nameLike;
    }
}
exports.Namespace = Namespace;
_Namespace_namespace = new WeakMap();
let GlobalNamespace = new Namespace();
exports.GlobalNamespace = GlobalNamespace;
class ConvenientNamespaceResolver {
    constructor(behavior = "error") {
        this.behavior = behavior;
        this.namespace = GlobalNamespace;
        this.storage = {};
        this.convenient = {};
    }
    getProxy() {
        return new Proxy({}, {
            get: (_, key) => {
                return this.get(key);
            }
        });
    }
    add(uniqueName, item) {
        const parsed = this.namespace.parseNaming(uniqueName);
        this.storage[uniqueName] = item;
        if (!this.convenient[parsed.name]) {
            this.convenient[parsed.name] = [];
        }
        this.convenient[parsed.name].push({
            item,
            uniqueName
        });
    }
    // Name or UniqueName
    gets(...matchers) {
        const names = [];
        const result = [];
        for (let uniqueName in this.storage) {
            if (matchers.some(matcher => Namespace.match({
                matcher,
                head: true,
                tail: true,
                name: uniqueName
            }))) {
                result.push(this.storage[uniqueName]);
                names.push(uniqueName);
            }
        }
        for (let name in this.convenient) {
            if (this.convenient[name] && this.convenient[name].length > 0 && matchers.some(matcher => matcher === name)) {
                const items = this.convenient[name];
                for (let item of items) {
                    if (!names.includes(item.uniqueName)) {
                        result.push(item.item);
                        names.push(item.uniqueName);
                    }
                }
            }
        }
        return result;
    }
    get(name) {
        if (this.storage[name])
            return this.storage[name];
        if (this.convenient[name]) {
            if (this.convenient[name].length == 1) {
                return this.convenient[name][0].item;
            }
            if (this.behavior == "error") {
                throw new Error(`Ambiguous name ${name} => ${this.convenient[name].map(item => item.uniqueName).join(", ")}`);
            }
            else if (this.behavior == "warning") {
                log_1.Logger.warn(`Ambiguous name ${name} => ${this.convenient[name].map(item => item.uniqueName).join(", ")}`);
            }
            else {
                return this.convenient[name][0].item;
            }
        }
    }
}
exports.ConvenientNamespaceResolver = ConvenientNamespaceResolver;
class LeveledNamespaceResolver {
    constructor(candidates, progress = []) {
        this.candidates = candidates;
        this.progress = progress;
    }
    getProxy() {
        return new Proxy({}, {
            get: (target, key) => {
                const finals = [...this.progress, key];
                const uniqueName = finals.join(".");
                if (this.candidates[uniqueName]) {
                    return this.candidates[uniqueName];
                }
                for (let name in this.candidates) {
                    if (name.startsWith(uniqueName + ".")) {
                        return new LeveledNamespaceResolver(this.candidates, [...this.progress, key]).getProxy();
                    }
                }
                return null;
            }
        });
    }
}
exports.LeveledNamespaceResolver = LeveledNamespaceResolver;
//# sourceMappingURL=namespace.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/abort.js":
/*!*************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/abort.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbortableBehavior = void 0;
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/procedure/errors.js");
// DesignNote:
// For running
// 1. We can't throw abort, because user logic may catch it. we should
// 2. Prevent future commit()
// 3. Remote all waitings and marks so it won't continue
// 4. Safely do abort behavior
// For restore
// 1. Do the same as running, so at least no state modification possible
// 2. Fake the abort end, just make sure we come to the same state.
let AbortableBehavior = (() => {
    var _a, _AbortableBehavior_isAborting, _AbortableBehavior_pendingAbort;
    let _instanceExtraInitializers = [];
    let _requestAbort_decorators;
    let _requestAbortImmeiate_decorators;
    return _a = class AbortableBehavior {
            constructor(runner) {
                this.runner = (__runInitializers(this, _instanceExtraInitializers), runner);
                _AbortableBehavior_isAborting.set(this, false);
                _AbortableBehavior_pendingAbort.set(this, false);
            }
            get interruptable() {
                return this.runner.interruptable;
            }
            never() {
                return __awaiter(this, void 0, void 0, function* () {
                    yield new Promise((res, rej) => { });
                });
            }
            pass() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (!__classPrivateFieldGet(this, _AbortableBehavior_isAborting, "f")) {
                        return;
                    }
                    return yield this.never();
                });
            }
            reset() {
                __classPrivateFieldSet(this, _AbortableBehavior_isAborting, false, "f");
                __classPrivateFieldSet(this, _AbortableBehavior_pendingAbort, false, "f");
            }
            get isAborting() {
                return __classPrivateFieldGet(this, _AbortableBehavior_isAborting, "f");
            }
            requestAbort(message) {
                if (__classPrivateFieldGet(this, _AbortableBehavior_isAborting, "f"))
                    return;
                // Mark abort so commitable will not be able to commit
                __classPrivateFieldSet(this, _AbortableBehavior_isAborting, true, "f");
                this.interruptable.requestInterrupt(new errors_1.Errors.AbortError(message));
            }
            requestAbortImmeiate(message) {
                if (__classPrivateFieldGet(this, _AbortableBehavior_isAborting, "f"))
                    return;
                // Mark abort so commitable will not be able to commit
                __classPrivateFieldSet(this, _AbortableBehavior_isAborting, true, "f");
                this.interruptable.requestInterrupt(new errors_1.Errors.AbortImmediateError(message));
            }
        },
        _AbortableBehavior_isAborting = new WeakMap(),
        _AbortableBehavior_pendingAbort = new WeakMap(),
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _requestAbort_decorators = [Leaf.bound()];
            _requestAbortImmeiate_decorators = [Leaf.bound()];
            __esDecorate(_a, null, _requestAbort_decorators, { kind: "method", name: "requestAbort", static: false, private: false, access: { has: obj => "requestAbort" in obj, get: obj => obj.requestAbort }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _requestAbortImmeiate_decorators, { kind: "method", name: "requestAbortImmeiate", static: false, private: false, access: { has: obj => "requestAbortImmeiate" in obj, get: obj => obj.requestAbortImmeiate }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.AbortableBehavior = AbortableBehavior;
//# sourceMappingURL=abort.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/checkpoint.js":
/*!******************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/checkpoint.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckpointCapable = void 0;
class CheckpointCapable {
    constructor(runner) {
        this.runner = runner;
    }
}
exports.CheckpointCapable = CheckpointCapable;
//# sourceMappingURL=checkpoint.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/commit.js":
/*!**************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/commit.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Commitable_records, _Commitable_requireRebase, _Commitable_uncriticalRecords, _Commitable_continuePromise, _Commitable_continueResolve, _Commitable_unfinisheCriticalCommitRecords, _Commitable_commitError;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Commitable = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const runner_1 = __webpack_require__(/*! ./runner */ "./node_modules/@branch-ts/core/src/procedure/runner.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/procedure/errors.js");
const log_1 = __webpack_require__(/*! ../log */ "./node_modules/@branch-ts/core/src/log.js");
const const_1 = __webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/procedure/const.js");
class Commitable {
    get store() {
        return this.runner.store;
    }
    get states() {
        return this.runner.states;
    }
    get timeable() {
        return this.runner.timeable;
    }
    constructor(runner) {
        this.runner = runner;
        _Commitable_records.set(this, []);
        _Commitable_requireRebase.set(this, false);
        _Commitable_uncriticalRecords.set(this, []);
        this.lock = new Leaf.Lock();
        this.waitingForClean = 0;
        _Commitable_continuePromise.set(this, void 0);
        _Commitable_continueResolve.set(this, void 0);
        _Commitable_unfinisheCriticalCommitRecords.set(this, void 0);
        _Commitable_commitError.set(this, void 0);
    }
    setRecords(records) {
        __classPrivateFieldSet(this, _Commitable_records, records, "f");
    }
    get records() {
        return __classPrivateFieldGet(this, _Commitable_records, "f").slice();
    }
    get isClean() {
        return !__classPrivateFieldGet(this, _Commitable_unfinisheCriticalCommitRecords, "f");
    }
    cutoff(offset) {
        if (offset > this.records.length) {
            throw new errors_1.Errors.InternalDesignError("Cutoff less than records length");
        }
        if (offset !== this.records.length) {
            __classPrivateFieldSet(this, _Commitable_requireRebase, true, "f");
        }
        __classPrivateFieldSet(this, _Commitable_records, __classPrivateFieldGet(this, _Commitable_records, "f").slice(0, offset), "f");
    }
    begin(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const begin = {
                id: option.id,
                input: option.input,
                time: Date.now(),
            };
            const data = [const_1.Const.RecordType.Begin, begin];
            yield this.lock.wait();
            yield this.store.initProcedureMeta({
                id: option.id,
                name: this.runner.name,
                version: this.runner.version,
                signatures: this.runner.signatures,
                begin
            });
            this.timeable.syncJournableTime(begin.time);
            __classPrivateFieldGet(this, _Commitable_records, "f").push(data);
        });
    }
    end(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const end = {
                ok: option.ok,
                output: option.output,
                error: option.error,
                time: Date.now(),
            };
            yield this.commit();
            yield this.lock.wait();
            yield this.store.archiveProcedureMeta({
                id: this.runner.id,
                position: this.records.length,
                end,
            });
            const data = [const_1.Const.RecordType.End, end];
            this.timeable.syncJournableTime(end.time);
            __classPrivateFieldGet(this, _Commitable_records, "f").push(data);
        });
    }
    add(type, data) {
        if (this.lock.isLock()) {
            throw new errors_1.Errors.AbuseError("Commitable.add() called while commit is running");
        }
        if (!!__classPrivateFieldGet(this, _Commitable_continuePromise, "f")) {
            throw new errors_1.Errors.AbuseError("Commitable.add() called while re-commit is running");
        }
        __classPrivateFieldGet(this, _Commitable_uncriticalRecords, "f").push([type, data]);
        return data;
    }
    // Commit will never throw, it just somehow recovers or hang forever.
    // NEVER throw
    commit(...records) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!!__classPrivateFieldGet(this, _Commitable_continuePromise, "f")) {
                log_1.Logger.error("WARN: Fatal Procedure Logic Flaw, commit overlapse! It's possible but it shouldn't be. If code is invalid, no commit will overlapse. We don't throw here, because we give promise commitable.commit() call will never throw. But it is a critical problem, please check your code.");
            }
            yield this.lock.lock();
            yield this.untilClean();
            try {
                const commitments = [...__classPrivateFieldGet(this, _Commitable_uncriticalRecords, "f"), ...records];
                __classPrivateFieldSet(this, _Commitable_uncriticalRecords, [], "f");
                yield this.commitUnsafe(...commitments);
            }
            finally {
                // When commit unsafe failed, we still release the lock.
                // We will wait an retry at await this.#continuePromise
                this.lock.release();
            }
            yield __classPrivateFieldGet(this, _Commitable_continuePromise, "f");
            __classPrivateFieldSet(this, _Commitable_continuePromise, null, "f");
        });
    }
    commitUnsafe(...commitments) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (commitments.length === 0)
                    return;
                __classPrivateFieldSet(this, _Commitable_unfinisheCriticalCommitRecords, commitments, "f");
                yield this.store.commitRecords({
                    id: this.runner.id,
                    version: this.runner.version,
                    position: this.records.length,
                    commitments,
                    rebase: __classPrivateFieldGet(this, _Commitable_requireRebase, "f"),
                });
                __classPrivateFieldSet(this, _Commitable_requireRebase, false, "f");
                __classPrivateFieldSet(this, _Commitable_uncriticalRecords, [], "f");
                __classPrivateFieldGet(this, _Commitable_records, "f").push(...commitments);
                __classPrivateFieldSet(this, _Commitable_unfinisheCriticalCommitRecords, null, "f");
                __classPrivateFieldSet(this, _Commitable_continuePromise, null, "f");
                __classPrivateFieldSet(this, _Commitable_continueResolve, null, "f");
                __classPrivateFieldSet(this, _Commitable_commitError, null, "f");
            }
            catch (e) {
                this.runner.debug("Commit failed", e);
                __classPrivateFieldSet(this, _Commitable_commitError, e, "f");
                if (!__classPrivateFieldGet(this, _Commitable_continuePromise, "f")) {
                    __classPrivateFieldSet(this, _Commitable_continuePromise, new Promise((resolve) => {
                        // Prevent resolved before this.commit have chance to await this.#continuePromise
                        runner_1.ProcedureRunner.runImmeidate(() => __awaiter(this, void 0, void 0, function* () {
                            __classPrivateFieldSet(this, _Commitable_continueResolve, resolve, "f");
                            this.states.panic();
                        }));
                    }), "f");
                }
            }
        });
    }
    reset() {
        if (!this.isClean) {
            throw new errors_1.Errors.AbuseError("Reset during commit");
        }
        __classPrivateFieldSet(this, _Commitable_records, [], "f");
        __classPrivateFieldSet(this, _Commitable_uncriticalRecords, [], "f");
    }
    untilClean() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!__classPrivateFieldGet(this, _Commitable_continuePromise, "f"))
                return;
            // Wait no pending commit
            this.waitingForClean++;
            yield __classPrivateFieldGet(this, _Commitable_continuePromise, "f");
            this.waitingForClean--;
        });
    }
    hasHangingCommit() {
        return !!__classPrivateFieldGet(this, _Commitable_commitError, "f");
    }
    requestRetryPreviousCommit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.runner.state !== "panic") {
                throw new errors_1.Errors.AbuseError("Can't retry if not panic");
            }
            // Is only possible to call after state turnned into panic(after that we have the #continueResolve)
            if (!__classPrivateFieldGet(this, _Commitable_unfinisheCriticalCommitRecords, "f")) {
                throw new errors_1.Errors.AbuseError("No previous commit");
            }
            const resolve = __classPrivateFieldGet(this, _Commitable_continueResolve, "f");
            yield this.lock.lock();
            try {
                let datas = __classPrivateFieldGet(this, _Commitable_unfinisheCriticalCommitRecords, "f") || [];
                yield this.commitUnsafe(...datas);
            }
            finally {
                this.lock.release();
            }
            this.states.recover();
            resolve();
        });
    }
}
exports.Commitable = Commitable;
_Commitable_records = new WeakMap(), _Commitable_requireRebase = new WeakMap(), _Commitable_uncriticalRecords = new WeakMap(), _Commitable_continuePromise = new WeakMap(), _Commitable_continueResolve = new WeakMap(), _Commitable_unfinisheCriticalCommitRecords = new WeakMap(), _Commitable_commitError = new WeakMap();
//# sourceMappingURL=commit.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/const.js":
/*!*************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/const.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Const = void 0;
var Const;
(function (Const) {
    let RecordType;
    (function (RecordType) {
        RecordType.Id = 1;
        RecordType.Random = 2;
        RecordType.Now = 3;
        RecordType.Journal = 30;
        RecordType.PreJournal = 31;
        //export const Keep: Procedure.RecordType.Keep = 80
        RecordType.Wait = 50;
        RecordType.WaitAny = 51;
        RecordType.WaitAll = 52;
        RecordType.Begin = 100;
        RecordType.End = 101;
    })(RecordType = Const.RecordType || (Const.RecordType = {}));
})(Const || (exports.Const = Const = {}));
//# sourceMappingURL=const.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/display.js":
/*!***************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/display.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisplayableBehavior = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const runner_1 = __webpack_require__(/*! ./runner */ "./node_modules/@branch-ts/core/src/procedure/runner.js");
let DisplayableBehavior = (() => {
    var _a, _DisplayableBehavior_displays;
    let _instanceExtraInitializers = [];
    let _display_decorators;
    let _reset_decorators;
    return _a = class DisplayableBehavior {
            constructor(runner) {
                this.runner = (__runInitializers(this, _instanceExtraInitializers), runner);
                _DisplayableBehavior_displays.set(this, {});
            }
            get displays() {
                return Leaf.Util.clone(Object.assign({}, __classPrivateFieldGet(this, _DisplayableBehavior_displays, "f")));
            }
            get journalable() {
                return this.runner.journalable;
            }
            display(name, value) {
                runner_1.ProcedureRunner.runImmeidate(() => __awaiter(this, void 0, void 0, function* () {
                    this.runner.events.emit(`display/${name.toString()}`, value);
                    this.runner.events.emit("display", {
                        name,
                        value
                    });
                }));
                this.runner.debug("Display", name, value);
                return __classPrivateFieldGet(this, _DisplayableBehavior_displays, "f")[name] = value;
            }
            reset() {
                __classPrivateFieldSet(this, _DisplayableBehavior_displays, {}, "f");
            }
        },
        _DisplayableBehavior_displays = new WeakMap(),
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _display_decorators = [Leaf.bound()];
            _reset_decorators = [Leaf.bound()];
            __esDecorate(_a, null, _display_decorators, { kind: "method", name: "display", static: false, private: false, access: { has: obj => "display" in obj, get: obj => obj.display }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _reset_decorators, { kind: "method", name: "reset", static: false, private: false, access: { has: obj => "reset" in obj, get: obj => obj.reset }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.DisplayableBehavior = DisplayableBehavior;
//# sourceMappingURL=display.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/errors.js":
/*!**************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/errors.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ErrorSpec = exports.Errors = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
exports.Errors = Leaf.ErrorDoc.build({
    // Version mismatch or version matches but replay failed due to data corruption
    ConflictError: {},
    // Action failed internally, like mark executed but failed to saved the data && etc
    InternalRuntimeError: {},
    // Expected internal state reached
    InternalDesignError: {},
    // User is likely abusing the api
    AbuseError: {},
    AbortError: {},
    AbortImmediateError: {},
    // Fail to ensure exclusive of the procedure
    ExclusiveError: {},
    AssertError: {},
    NotImplemented: {},
    DesignError: {},
    AlreadyFinished: {},
});
var ErrorSpec;
(function (ErrorSpec) {
    function createErrorChecker(errorName, Cons) {
        return function (error) {
            if (!error)
                return false;
            if (error instanceof Cons)
                return true;
            if (typeof error == "string" && error === errorName)
                return true;
            if (error["name"] && error["name"] === errorName)
                return true;
            return false;
        };
    }
    ErrorSpec.createErrorChecker = createErrorChecker;
    ErrorSpec.isConflictError = createErrorChecker("ConflictError", exports.Errors.ConflictError);
    ErrorSpec.isInternalRuntimeError = createErrorChecker("InternalRuntimeError", exports.Errors.InternalRuntimeError);
    ErrorSpec.isInternalDesignError = createErrorChecker("InternalDesignError", exports.Errors.InternalDesignError);
    ErrorSpec.isAbuseError = createErrorChecker("AbuseError", exports.Errors.AbuseError);
    ErrorSpec.isAbortError = createErrorChecker("AbortError", exports.Errors.AbortError);
    ErrorSpec.isExclusiveError = createErrorChecker("ExclusiveError", exports.Errors.ExclusiveError);
    ErrorSpec.isAssertError = createErrorChecker("AssertError", exports.Errors.AssertError);
    ErrorSpec.isAbortImmediateError = createErrorChecker("AbortImmediateError", exports.Errors.AbortImmediateError);
    ErrorSpec.from = (e) => {
        if (typeof e === "string") {
            return ErrorSpec.fromName(e);
        }
        else if (e.name) {
            return ErrorSpec.fromName(e.name, e.message);
        }
        if (e instanceof Error)
            return e;
    };
    ErrorSpec.fromName = (name, message) => {
        if (exports.Errors[name]) {
            return new exports.Errors[name](message);
        }
        const error = new Error(message);
        error.name = name;
        return error;
    };
    ErrorSpec.isLikelySameError = (el1, el2) => {
        const e1 = ErrorSpec.from(el1);
        const e2 = ErrorSpec.from(el2);
        return (e1 === null || e1 === void 0 ? void 0 : e1.name) === (e2 === null || e2 === void 0 ? void 0 : e2.name);
    };
    ErrorSpec.isLikelySameErrorStrict = (el1, el2) => {
        const e1 = ErrorSpec.from(el1);
        const e2 = ErrorSpec.from(el2);
        return (e1 === null || e1 === void 0 ? void 0 : e1.name) === (e2 === null || e2 === void 0 ? void 0 : e2.name) && (e1 === null || e1 === void 0 ? void 0 : e1.message) == (e2 === null || e2 === void 0 ? void 0 : e2.message);
    };
    ErrorSpec.toErrorLike = (e) => {
        const ex = ErrorSpec.from(e);
        return {
            name: ex.name,
            message: ex.message,
        };
    };
})(ErrorSpec || (exports.ErrorSpec = ErrorSpec = {}));
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/fork.js":
/*!************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/fork.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _WhenPromise_res, _WhenPromise_rej, _WhenPromise_results, _WhenPromise_errors, _WhenPromise_considers, _WhenPromise_considerEnds, _WhenPromise_isReturnned;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AllPromise = exports.MaybePromise = exports.WhenPromise = exports.ForkableBehavior = void 0;
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/procedure/errors.js");
const runner_1 = __webpack_require__(/*! ./runner */ "./node_modules/@branch-ts/core/src/procedure/runner.js");
// After each fold end, all pending mark/wait will be cleared
class ForkableBehavior {
    constructor(runner) {
        this.runner = runner;
        this.current = null;
    }
    get journalable() {
        return this.runner.journalable;
    }
    get waitable() {
        return this.runner.waitable;
    }
    guardSingleFork() {
        if (this.current) {
            throw new errors_1.Errors.AbuseError(`${this.runner.name}:${this.runner.version} has unfinished forking #${this.current.type}`);
        }
    }
    when() {
        this.guardSingleFork();
        this.current = new WhenPromise((rej, res) => { });
        this.current.forkable = this;
        return this.current;
    }
    maybe() {
        this.guardSingleFork();
        this.current = new MaybePromise(((rej, res) => { }));
        this.current.forkable = this;
        return this.current;
    }
    all() {
        this.guardSingleFork();
        this.current = new AllPromise((rej, res) => { });
        this.current.forkable = this;
        return this.current;
    }
    clear() {
        this.current = null;
    }
}
exports.ForkableBehavior = ForkableBehavior;
class WhenPromise extends Promise {
    get considers() {
        return __classPrivateFieldGet(this, _WhenPromise_considers, "f").slice();
    }
    constructor(fn) {
        let _res;
        let _rej;
        super(function (res, rej) {
            _res = res;
            _rej = rej;
            fn(res, rej);
        });
        this.type = "when";
        _WhenPromise_res.set(this, void 0);
        _WhenPromise_rej.set(this, void 0);
        _WhenPromise_results.set(this, {});
        _WhenPromise_errors.set(this, {});
        _WhenPromise_considers.set(this, []);
        _WhenPromise_considerEnds.set(this, []);
        _WhenPromise_isReturnned.set(this, false);
        __classPrivateFieldSet(this, _WhenPromise_res, _res, "f");
        __classPrivateFieldSet(this, _WhenPromise_rej, _rej, "f");
    }
    // [TODO]: Relying on  nodejs runtime behaviors, we assume no outside async injection(such as feed for wait), bewteen execution of runImmediate considers. If some consider return s before check, we may throw. So use carefully.
    consider(name, provider) {
        if (__classPrivateFieldGet(this, _WhenPromise_considers, "f").includes(name)) {
            throw new errors_1.Errors.AbuseError(`Duplicated consider option ${name.toString()}`);
        }
        __classPrivateFieldGet(this, _WhenPromise_considers, "f").push(name);
        runner_1.ProcedureRunner.runImmeidate(() => __awaiter(this, void 0, void 0, function* () {
            let data;
            let error;
            try {
                data = yield provider();
            }
            catch (e) {
                error = e;
            }
            if (__classPrivateFieldGet(this, _WhenPromise_considerEnds, "f").includes(name)) {
                // already return
                return;
            }
            __classPrivateFieldGet(this, _WhenPromise_considerEnds, "f").push(name);
            __classPrivateFieldGet(this, _WhenPromise_errors, "f")[name] = error;
            __classPrivateFieldGet(this, _WhenPromise_results, "f")[name] = data;
            this._see();
        }));
        return this;
    }
    static isAccepteCheckResult(result) {
        if (result === null)
            return false;
        if (typeof result == "undefined")
            return false;
        return true;
    }
    cleanUp() {
        this.forkable.clear();
    }
    res(result) {
        if (__classPrivateFieldGet(this, _WhenPromise_isReturnned, "f"))
            return;
        __classPrivateFieldSet(this, _WhenPromise_isReturnned, true, "f");
        this.cleanUp();
        __classPrivateFieldGet(this, _WhenPromise_res, "f").call(this, result);
    }
    rej(error) {
        if (__classPrivateFieldGet(this, _WhenPromise_isReturnned, "f"))
            return;
        __classPrivateFieldSet(this, _WhenPromise_isReturnned, true, "f");
        this.cleanUp();
        __classPrivateFieldGet(this, _WhenPromise_rej, "f").call(this, error);
    }
    _see() {
        if (__classPrivateFieldGet(this, _WhenPromise_isReturnned, "f"))
            return;
        if (!this.checker) {
            this.rej(new Error("ProcedureRunner.WhenPromise.see() is not provided"));
            return;
        }
        let result;
        try {
            result = this.checker({
                results: __classPrivateFieldGet(this, _WhenPromise_results, "f"),
                errors: __classPrivateFieldGet(this, _WhenPromise_errors, "f"),
                keys: __classPrivateFieldGet(this, _WhenPromise_considerEnds, "f").slice(),
            });
        }
        catch (e) {
            this.rej(e);
            return;
        }
        if (result instanceof Promise) {
            this.rej(new Error("ProcedureRunner.WhenPromise.see() should not return a promise"));
            return;
        }
        if (WhenPromise.isAccepteCheckResult(result)) {
            this.res(result);
        }
        else {
            if (__classPrivateFieldGet(this, _WhenPromise_considerEnds, "f").length == __classPrivateFieldGet(this, _WhenPromise_considers, "f").length) {
                this.rej(new errors_1.Errors.AbuseError("ProcedureRunner.WhenPromise.see() doesn't return accept result,but all consider options are returned"));
            }
        }
    }
    see(fn) {
        this.checker = (info) => {
            return fn(info);
        };
        return this;
    }
}
exports.WhenPromise = WhenPromise;
_WhenPromise_res = new WeakMap(), _WhenPromise_rej = new WeakMap(), _WhenPromise_results = new WeakMap(), _WhenPromise_errors = new WeakMap(), _WhenPromise_considers = new WeakMap(), _WhenPromise_considerEnds = new WeakMap(), _WhenPromise_isReturnned = new WeakMap();
class MaybePromise extends WhenPromise {
    constructor() {
        super(...arguments);
        this.type = "maybe";
        this.checker = (info) => {
            if (info.keys.length !== 1)
                return;
            const key = info.keys[0];
            const result = info.results[key];
            const error = info.errors[key];
            if (error) {
                throw error;
            }
            const ret = {
                what: key,
                result,
            };
            const comprehension = [key, result];
            ret[Symbol.iterator] = comprehension[Symbol.iterator].bind(comprehension);
            return ret;
        };
    }
    consider(name, provider) {
        return super.consider(name, provider);
    }
}
exports.MaybePromise = MaybePromise;
class AllPromise extends WhenPromise {
    constructor() {
        super(...arguments);
        this.type = "all";
        this.checker = (info) => {
            for (let key of info.keys) {
                if (info.errors[key]) {
                    throw info.errors[key];
                }
            }
            if (info.keys.length !== this.considers.length)
                return;
            return info.results;
        };
    }
    consider(name, provider) {
        return super.consider(name, provider);
    }
}
exports.AllPromise = AllPromise;
//# sourceMappingURL=fork.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/implement.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/implement.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Implementable = void 0;
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/procedure/errors.js");
let Implementable = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _mock_decorators;
    return _a = class Implementable {
            constructor() {
                this.mode = (__runInitializers(this, _instanceExtraInitializers), "production");
                this.implementations = {};
            }
            mock(brief, args, mock) {
                return __awaiter(this, void 0, void 0, function* () {
                    let implementation = this.implementations[brief];
                    if (this.mode === "mock-only") {
                        if (mock) {
                            return mock(args);
                        }
                        else {
                            throw new errors_1.Errors.NotImplemented(`Force mock not available: ${brief}`);
                        }
                    }
                    else if (this.mode == "production") {
                        if (implementation) {
                            return implementation(args);
                        }
                        else {
                            throw new errors_1.Errors.NotImplemented(`TODO: ${brief}`);
                        }
                    }
                    else {
                        if (implementation) {
                            return implementation(args);
                        }
                        else if (mock) {
                            return mock(args);
                        }
                        else {
                            throw new errors_1.Errors.NotImplemented(`TODO: ${brief}`);
                        }
                    }
                });
            }
            implement(brief, impl) {
                this.implementations[brief] = impl;
            }
            implements(impls) {
                for (let key in impls) {
                    this.implementations[key] = impls[key];
                }
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _mock_decorators = [Leaf.bound()];
            __esDecorate(_a, null, _mock_decorators, { kind: "method", name: "mock", static: false, private: false, access: { has: obj => "mock" in obj, get: obj => obj.mock }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.Implementable = Implementable;
//# sourceMappingURL=implement.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/interrupt.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/interrupt.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Interruptable = void 0;
const const_1 = __webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/procedure/const.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/procedure/errors.js");
let Interruptable = (() => {
    var _a, _Interruptable_rej, _Interruptable_promise, _Interruptable_requestInterruptingError, _Interruptable_thrownError, _Interruptable_isInterrupted;
    let _instanceExtraInitializers = [];
    let _guardInterrupt_decorators;
    return _a = class Interruptable {
            constructor(runner) {
                this.runner = (__runInitializers(this, _instanceExtraInitializers), runner);
                _Interruptable_rej.set(this, void 0);
                _Interruptable_promise.set(this, new Promise((res, rej) => {
                    __classPrivateFieldSet(this, _Interruptable_rej, rej, "f");
                }));
                _Interruptable_requestInterruptingError.set(this, null);
                _Interruptable_thrownError.set(this, null);
                _Interruptable_isInterrupted.set(this, false);
            }
            get routine() {
                return this.runner.routine;
            }
            reset() {
                __classPrivateFieldSet(this, _Interruptable_promise, new Promise((res, rej) => {
                    __classPrivateFieldSet(this, _Interruptable_rej, rej, "f");
                }), "f");
                __classPrivateFieldSet(this, _Interruptable_thrownError, null, "f");
                __classPrivateFieldSet(this, _Interruptable_requestInterruptingError, null, "f");
            }
            get promise() {
                return __classPrivateFieldGet(this, _Interruptable_promise, "f");
            }
            get restorable() {
                return this.runner.restorable;
            }
            get isInterrupting() {
                return !!__classPrivateFieldGet(this, _Interruptable_requestInterruptingError, "f");
            }
            get isInterrupted() {
                return !!__classPrivateFieldGet(this, _Interruptable_thrownError, "f");
            }
            pass() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (__classPrivateFieldGet(this, _Interruptable_requestInterruptingError, "f")) {
                        yield this.never();
                    }
                });
            }
            finalCheckpoint() {
                return __awaiter(this, void 0, void 0, function* () {
                    this.mayThrowRequestingError();
                });
            }
            mayThrowRequestingError() {
                if (!__classPrivateFieldGet(this, _Interruptable_requestInterruptingError, "f"))
                    return;
                if (__classPrivateFieldGet(this, _Interruptable_thrownError, "f"))
                    return;
                __classPrivateFieldSet(this, _Interruptable_thrownError, __classPrivateFieldGet(this, _Interruptable_requestInterruptingError, "f"), "f");
                throw __classPrivateFieldGet(this, _Interruptable_thrownError, "f");
            }
            mayRejectRequestingError() {
                if (!__classPrivateFieldGet(this, _Interruptable_requestInterruptingError, "f"))
                    return;
                if (__classPrivateFieldGet(this, _Interruptable_thrownError, "f"))
                    return;
                __classPrivateFieldSet(this, _Interruptable_thrownError, __classPrivateFieldGet(this, _Interruptable_requestInterruptingError, "f"), "f");
                __classPrivateFieldGet(this, _Interruptable_rej, "f").call(this, __classPrivateFieldGet(this, _Interruptable_thrownError, "f"));
            }
            checkpoint() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.runner.state == "restoring") {
                        if (this.restorable.next[0] == const_1.Const.RecordType.End) {
                            const end = this.restorable.next[1];
                            if (errors_1.ErrorSpec.isAbortError(end.error)) {
                                this.requestInterrupt(errors_1.ErrorSpec.from(end.error));
                            }
                            this.mayRejectRequestingError();
                            yield this.pass();
                        }
                    }
                    else {
                        // If has thrown error, we hang forever
                        if (__classPrivateFieldGet(this, _Interruptable_thrownError, "f")) {
                            yield this.never();
                        }
                        if (__classPrivateFieldGet(this, _Interruptable_requestInterruptingError, "f")) {
                            __classPrivateFieldGet(this, _Interruptable_rej, "f").call(this, __classPrivateFieldGet(this, _Interruptable_requestInterruptingError, "f"));
                            this.mayRejectRequestingError();
                            yield this.never();
                        }
                    }
                });
            }
            never() {
                return __awaiter(this, void 0, void 0, function* () {
                    yield new Promise((res, rej) => { });
                });
            }
            guardInterrupt(e) {
                if (this.isInterruptError(e)) {
                    throw e;
                }
            }
            isInterruptError(el) {
                if (errors_1.ErrorSpec.isAbortError(el)) {
                    return true;
                }
                if (errors_1.ErrorSpec.isAbuseError(el)) {
                    return true;
                }
                if (errors_1.ErrorSpec.isConflictError(el)) {
                    return true;
                }
                if (errors_1.ErrorSpec.isInternalDesignError(el)) {
                    return true;
                }
                if (errors_1.ErrorSpec.isInternalRuntimeError(el)) {
                    return true;
                }
                if (errors_1.ErrorSpec.isAbortImmediateError(el)) {
                    return true;
                }
                if (errors_1.ErrorSpec.isAssertError(el)) {
                    return true;
                }
                if (errors_1.ErrorSpec.isExclusiveError(el)) {
                    return true;
                }
                return false;
            }
            markInterrupt(e) {
                __classPrivateFieldSet(this, _Interruptable_requestInterruptingError, e, "f");
                __classPrivateFieldSet(this, _Interruptable_thrownError, e, "f");
            }
            requestInterrupt(e) {
                if (this.isInterrupting) {
                    // We use the previous interrupt, latter interrupt is ignored
                    return;
                }
                __classPrivateFieldSet(this, _Interruptable_requestInterruptingError, e || new errors_1.Errors.InternalDesignError("Interrupting without empty"), "f");
                this.mayRejectRequestingError();
            }
            abuseError(message) {
                throw new errors_1.Errors.AbuseError(`${this.runner.version}@${this.runner.id}: ${message || "AbuseError"}`);
            }
        },
        _Interruptable_rej = new WeakMap(),
        _Interruptable_promise = new WeakMap(),
        _Interruptable_requestInterruptingError = new WeakMap(),
        _Interruptable_thrownError = new WeakMap(),
        _Interruptable_isInterrupted = new WeakMap(),
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _guardInterrupt_decorators = [Leaf.bound()];
            __esDecorate(_a, null, _guardInterrupt_decorators, { kind: "method", name: "guardInterrupt", static: false, private: false, access: { has: obj => "guardInterrupt" in obj, get: obj => obj.guardInterrupt }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.Interruptable = Interruptable;
//# sourceMappingURL=interrupt.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/journal.js":
/*!***************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/journal.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JournalableBehavior = exports.Journaling = exports.JournalResult = void 0;
const const_1 = __webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/procedure/const.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/procedure/errors.js");
const runner_1 = __webpack_require__(/*! ./runner */ "./node_modules/@branch-ts/core/src/procedure/runner.js");
var JournalResult;
(function (JournalResult) {
    function from(data) {
        const arr = [data.result, data.error];
        const result = {
            value: data.result,
            error: data.error,
            0: data.result,
            1: data.error,
        };
        result[Symbol.iterator] = arr[Symbol.iterator].bind(arr);
        return result;
    }
    JournalResult.from = from;
})(JournalResult || (exports.JournalResult = JournalResult = {}));
class Journaling {
    constructor(journalable, todo) {
        this.journalable = journalable;
        this.todo = todo;
        this.isReturn = false;
        this.callback = Leaf.SharedCallbacks.create();
        this.promise = this.callback.promise();
        runner_1.ProcedureRunner.runImmeidate(() => __awaiter(this, void 0, void 0, function* () {
            let result;
            try {
                yield this.journalable.commitable.commit();
                yield this.journalable.interruptable.checkpoint();
                result = yield todo();
                result = runner_1.ProcedureRunner.purify(result);
                const time = this.journalable.timeable.syncJournableTime(Date.now());
                this.journalable.commitable.add(const_1.Const.RecordType.Journal, {
                    data: runner_1.ProcedureRunner.purify(result),
                    time,
                });
                yield this.journalable.commitable.commit();
                yield this.journalable.interruptable.checkpoint();
            }
            catch (e) {
                yield this.error(e);
                return;
            }
            //
            yield this.journalable.interruptable.checkpoint();
            this.handle(result);
        }));
    }
    handle(v) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isReturn)
                return;
            this.isReturn = true;
            try {
                yield this.journalable.commitable.commit();
            }
            catch (e) {
                this.callback(e);
                return;
            }
            this.callback(null, v);
        });
    }
    error(e) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isReturn)
                return;
            this.isReturn = true;
            this.journalable.commitable.add(const_1.Const.RecordType.Journal, {
                error: errors_1.ErrorSpec.toErrorLike(e)
            });
            yield this.journalable.commitable.commit();
            this.callback(e);
        });
    }
}
exports.Journaling = Journaling;
let JournalableBehavior = (() => {
    var _a, _JournalableBehavior_isJournaling;
    let _instanceExtraInitializers = [];
    let _guard_decorators;
    let _journal_decorators;
    return _a = class JournalableBehavior {
            constructor(runner) {
                this.runner = (__runInitializers(this, _instanceExtraInitializers), runner);
                _JournalableBehavior_isJournaling.set(this, false);
            }
            get timeable() {
                return this.runner.timeable;
            }
            get commitable() {
                return this.runner.commitable;
            }
            get interruptable() {
                return this.runner.interruptable;
            }
            get isJournaling() {
                return __classPrivateFieldGet(this, _JournalableBehavior_isJournaling, "f");
            }
            get waitable() {
                return this.runner.waitable;
            }
            guard() {
                if (this.isJournaling) {
                    throw new errors_1.Errors.AbuseError("Can't call interact with context(like wait,makeId,random,sleep,rollback) during journal");
                }
            }
            result(value, error) {
                return [value, error];
            }
            journal(todo) {
                return __awaiter(this, void 0, void 0, function* () {
                    this.runner.debug("Journalling", todo);
                    this.guard();
                    this.waitable.guard();
                    __classPrivateFieldSet(this, _JournalableBehavior_isJournaling, true, "f");
                    try {
                        let result;
                        if (this.runner.state == "running") {
                            result = yield this.journalRunning(todo);
                        }
                        else if (this.runner.state == "restoring") {
                            result = yield this.journalRestore();
                        }
                        else {
                            this.interruptable.markInterrupt(new errors_1.Errors.AbuseError("Can't journal in state " + this.runner.state));
                            yield this.interruptable.checkpoint();
                        }
                        this.runner.debug("Journal return", result);
                        return JournalResult.from({
                            result: result,
                            error: null
                        });
                    }
                    catch (e) {
                        this.runner.debug("Journal error", e);
                        return JournalResult.from({
                            result: null,
                            error: e,
                        });
                    }
                    finally {
                        this.runner.debug("Journal over");
                        __classPrivateFieldSet(this, _JournalableBehavior_isJournaling, false, "f");
                    }
                });
            }
            journalRunning(todo) {
                return __awaiter(this, void 0, void 0, function* () {
                    const journaling = new Journaling(this, todo);
                    const result = yield journaling.promise;
                    return result;
                });
            }
            // ([post-W,I?][pre-M,I?,post-M,tE?,I?](Sn+,tE?,I?)+)+
            journalRestore() {
                return __awaiter(this, void 0, void 0, function* () {
                    __classPrivateFieldSet(this, _JournalableBehavior_isJournaling, true, "f");
                    yield this.interruptable.checkpoint();
                    const journal = this.runner.restorable.expect(const_1.Const.RecordType.Journal);
                    this.timeable.syncJournableTime(journal.time);
                    yield this.interruptable.checkpoint();
                    if (journal.error) {
                        throw errors_1.ErrorSpec.from(journal.error);
                    }
                    __classPrivateFieldSet(this, _JournalableBehavior_isJournaling, false, "f");
                    return journal.data;
                });
            }
        },
        _JournalableBehavior_isJournaling = new WeakMap(),
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _guard_decorators = [Leaf.bound()];
            _journal_decorators = [Leaf.bound()];
            __esDecorate(_a, null, _guard_decorators, { kind: "method", name: "guard", static: false, private: false, access: { has: obj => "guard" in obj, get: obj => obj.guard }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _journal_decorators, { kind: "method", name: "journal", static: false, private: false, access: { has: obj => "journal" in obj, get: obj => obj.journal }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.JournalableBehavior = JournalableBehavior;
//# sourceMappingURL=journal.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/manager.js":
/*!***************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/manager.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProcedureStoreManager = exports.ProcedureManager = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const store_1 = __webpack_require__(/*! ./store */ "./node_modules/@branch-ts/core/src/procedure/store.js");
const runner_1 = __webpack_require__(/*! ./runner */ "./node_modules/@branch-ts/core/src/procedure/runner.js");
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const nanoid = __importStar(__webpack_require__(/*! nanoid */ "./node_modules/nanoid/index.browser.js"));
let ProcedureManager = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _prepare_decorators;
    return _a = class ProcedureManager {
            constructor(domain) {
                this.domain = (__runInitializers(this, _instanceExtraInitializers), domain);
                this.stores = new ProcedureStoreManager(this);
                this.nameMapOfHighestRevision = {};
                this.familyNameMapOfHighestRevision = {};
                this.uniqueNameMap = {};
                this.isInitialized = false;
                this.runners = {};
                this.signatureSplitter = ":";
            }
            feed(id, name, data) {
                return __awaiter(this, void 0, void 0, function* () {
                    const runner = yield this.get({
                        id
                    });
                    if (!runner) {
                        return;
                    }
                    runner.waitable.feed(name, data);
                });
            }
            idFromHandle(option) {
                const proc = this.procedureDescriptorFromName(({ name: option.name }));
                if (!proc) {
                    throw new errors_1.Errors.NotFound(`Procedure ${option.name} not found`);
                }
                return `${proc.uniqueName}:${option.handle}`;
            }
            prepare() {
                var _b;
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.isInitialized)
                        return;
                    const procedures = this.domain.findAspects("procedure");
                    for (let proc of procedures) {
                        if (!this.familyNameMapOfHighestRevision[proc.familyName]) {
                            this.familyNameMapOfHighestRevision[proc.familyName] = proc;
                        }
                        else if (((_b = this.familyNameMapOfHighestRevision[proc.familyName]) === null || _b === void 0 ? void 0 : _b.revision) < proc.revision) {
                            this.familyNameMapOfHighestRevision[proc.familyName] = proc;
                        }
                        this.uniqueNameMap[proc.uniqueName] = proc;
                        if (!this.nameMapOfHighestRevision[proc.name]) {
                            this.nameMapOfHighestRevision[proc.name] = proc;
                        }
                        else if (this.nameMapOfHighestRevision[proc.name].familyName == proc.familyName && proc.revision > this.nameMapOfHighestRevision[proc.name].revision) {
                            this.nameMapOfHighestRevision[proc.name] = proc;
                        }
                    }
                    this.isInitialized = true;
                });
            }
            attach(runner) {
                this.runners[runner.id] = runner;
            }
            isValidId(id) {
                if (!id)
                    return false;
                const parts = id.split(":");
                const name = parts[0];
                const after = parts.slice(1).join(":");
                if (!after)
                    return false;
                return true;
            }
            ensure(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    yield this.prepare();
                    let id;
                    let proc;
                    if (option.id) {
                        const uniqueName = option.id.split(":")[0];
                        proc = this.procedureDescriptorFromName({ name: uniqueName });
                        id = option.id;
                    }
                    else if (option.name) {
                        proc = this.procedureDescriptorFromName({ name: option.name });
                    }
                    let idByHandle;
                    if (option.name && option.handle) {
                        idByHandle = `${proc.uniqueName}:${option.handle}`;
                    }
                    if (id && idByHandle && id !== idByHandle) {
                        throw new errors_1.Errors.DesignError(`Procedure ensure with handle and id mismatch`);
                    }
                    id = id || idByHandle;
                    if (!id) {
                        id = `${proc.uniqueName}:${nanoid.nanoid()}`;
                    }
                    if (this.runners[id]) {
                        const runner = this.runners[id];
                        if (typeof option.debug == "boolean") {
                            runner.isDebug = option.debug;
                        }
                        return runner;
                    }
                    const runner = yield this.restoreFromStore({
                        id,
                        input: option.input,
                        implement: option.implement,
                        debug: option.debug,
                    });
                    if (runner)
                        return runner;
                    return this.create(option);
                });
            }
            create(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    yield this.prepare();
                    let proc = this.procedureDescriptorFromName({ name: option.name });
                    const store = yield this.stores.getStoreForProcedure(proc);
                    if (!store) {
                        throw new errors_1.Errors.LogicError(`No store found for procedure ${proc.uniqueName}`);
                    }
                    if (!proc.cons) {
                        throw new errors_1.Errors.DesignError(`${proc.uniqueName} has no constructor defined, likely code is not included`);
                    }
                    const obj = new proc.cons(this.domain);
                    let id;
                    if (option.id) {
                        id = option.id;
                    }
                    else if (option.handle) {
                        id = `${proc.uniqueName}:${option.handle}`;
                    }
                    else {
                        id = option.id || `${proc.uniqueName}:${nanoid.nanoid()}`;
                    }
                    if (!this.isValidId(id)) {
                        throw new errors_1.Errors.InvalidParameters(`Invalid id ${id}`);
                    }
                    if (this.runners[id]) {
                        throw new errors_1.Errors.AlreadyExists();
                    }
                    const meta = yield store.getProcedureMeta(id);
                    if (meta) {
                        throw new errors_1.Errors.AlreadyExists();
                    }
                    const signatures = [];
                    if (proc.exclusive) {
                        for (let prefix in proc.exclusive) {
                            const keys = proc.exclusive[prefix];
                            const values = keys.map(key => {
                                const value = option.input[key];
                                if (typeof value == "string") {
                                    if (!value) {
                                        throw new errors_1.Errors.DesignError(`Exclusive key ${prefix}=>input.${key} must be an integer or none empty string`);
                                    }
                                    return value;
                                }
                                if (typeof value == "number") {
                                    if (Math.floor(value) === value) {
                                        return value;
                                    }
                                }
                                throw new errors_1.Errors.DesignError(`Exclusive key ${prefix}=>input.${key} must be an integer or string`);
                            });
                            const signature = [prefix, ...values].join(this.signatureSplitter);
                            signatures.push(signature);
                        }
                    }
                    const runner = new runner_1.ProcedureRunner({
                        domain: this.domain,
                        id,
                        name: proc.familyName,
                        revision: proc.revision || 0,
                        version: proc.uniqueName,
                        main: obj.main.bind(obj),
                        signatures,
                        store,
                        implement: option.implement,
                        debug: option.debug,
                    });
                    this.attach(runner);
                    yield runner.run(option.input);
                    return runner;
                });
            }
            restoreFromStore(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    yield this.prepare();
                    if (this.runners[option.id]) {
                        const runner = this.runners[option.id];
                        if (typeof option.debug == "boolean") {
                            runner.isDebug = option.debug;
                        }
                        return runner;
                    }
                    const uniqueName = option.id.split(":")[0];
                    let proc;
                    if (option.fromVersion) {
                        proc = this.procedureDescriptorFromVersion(option.fromVersion);
                    }
                    else {
                        proc = this.procedureDescriptorFromName({ name: uniqueName });
                    }
                    proc = this.procedureDescriptorFromName({ name: uniqueName });
                    const store = yield this.stores.getStoreForProcedure(proc);
                    //const store = await this.stores.getStoreForProcedure(proc)
                    //const obj = new proc.cons(this.domain)
                    const meta = yield store.getProcedureMeta({ id: option.id });
                    if (!meta) {
                        return null;
                    }
                    const records = yield store.getRecords({
                        id: option.id,
                        version: option.storedVersion || meta.version,
                    });
                    if (!records) {
                        throw new errors_1.Errors.NotFound();
                    }
                    const obj = new proc.cons(this.domain);
                    const runner = new runner_1.ProcedureRunner({
                        domain: this.domain,
                        id: option.id,
                        name: proc.familyName,
                        revision: proc.revision || 0,
                        version: `${proc.uniqueName}:${proc.revision || 0}`,
                        main: obj.main.bind(obj),
                        store,
                        implement: option.implement,
                    });
                    yield runner.restoreAndRun(option.input, records);
                    if (meta.phase == "indexed") {
                        this.attach(runner);
                    }
                    yield runner.until("restored");
                    return runner;
                });
            }
            get(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    yield this.prepare();
                    let id;
                    if (option.id) {
                        id = option.id;
                    }
                    else if (option.name && option.handle) {
                        const proc = this.procedureDescriptorFromName({ name: option.name });
                        id = `${proc.uniqueName}:${option.handle}`;
                    }
                    else {
                        throw new errors_1.Errors.InvalidParameters(`Get runner require option.id or option.name and option.handle`);
                    }
                    if (this.runners[id]) {
                        return this.runners[id];
                    }
                    return this.restoreFromStore({
                        id,
                        fromVersion: option.fromVersion,
                        storedVersion: option.storedVersion,
                    });
                });
            }
            procedureDescriptorFromName(option) {
                let proc;
                proc = this.uniqueNameMap[option.name];
                if (!proc) {
                    proc = this.familyNameMapOfHighestRevision[option.name];
                }
                if (!proc) {
                    proc = this.nameMapOfHighestRevision[option.name];
                }
                if (!proc) {
                    throw new errors_1.Errors.NotFound(`Procedure ${option.name} not found`);
                }
                return proc;
            }
            procedureDescriptorFromVersion(targetVersion) {
                const procedures = this.domain.findAspects("procedure");
                for (let proc of procedures) {
                    const version = `${proc.uniqueName}:${proc.revision || 0}`;
                    if (version == targetVersion)
                        return proc;
                }
                return null;
            }
            remove(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    yield this.prepare();
                    let proc = this.procedureDescriptorFromName({ name: option.name });
                    if (this.runners[option.id]) {
                        const runner = this.runners[option.id];
                        runner.abortable.requestAbortImmeiate();
                        yield runner.until("fin");
                    }
                    const store = yield this.stores.getStoreForProcedure(proc);
                    if (!store) {
                        throw new errors_1.Errors.LogicError(`No store found for procedure ${proc.uniqueName}`);
                    }
                    yield store.removeProcedureMeta({ id: option.id });
                });
            }
            getSituationOf(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    yield this.prepare();
                    if (option.id) {
                        if (this.runners[option.id]) {
                            return this.runners[option.id].situation;
                        }
                    }
                    if (option.handle && option.name) {
                        const id = this.idFromHandle(option);
                        if (this.runners[option.id]) {
                            return this.runners[option.id].situation;
                        }
                    }
                    return null;
                });
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _prepare_decorators = [Leaf.lock("prepare")];
            __esDecorate(_a, null, _prepare_decorators, { kind: "method", name: "prepare", static: false, private: false, access: { has: obj => "prepare" in obj, get: obj => obj.prepare }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.ProcedureManager = ProcedureManager;
let ProcedureStoreManager = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _getStore_decorators;
    let _getStoreForProcedure_decorators;
    let _get_descriptors_decorators;
    return _a = class ProcedureStoreManager {
            constructor(manager) {
                this.manager = (__runInitializers(this, _instanceExtraInitializers), manager);
                this.stores = {};
                this.defaultInMemoryStore = new store_1.InMemoryProcedureStore();
            }
            getStore(uniqueName) {
                return __awaiter(this, void 0, void 0, function* () {
                    const desc = this.descriptors.find(item => item.uniqueName == uniqueName);
                    if (!desc) {
                        return this.defaultInMemoryStore;
                    }
                    if (this.stores[desc.uniqueName]) {
                        return this.stores[desc.uniqueName];
                    }
                    const store = new desc.cons(this.manager.domain);
                    yield store.cleanStaleProcedureMetas();
                    return this.stores[desc.uniqueName] = store;
                });
            }
            getStoreForProcedure(descriptor) {
                return __awaiter(this, void 0, void 0, function* () {
                    let candidates = [];
                    for (let desc of this.descriptors) {
                        if (!this.match({
                            store: desc,
                            procedure: descriptor
                        }))
                            continue;
                        candidates.push(desc);
                    }
                    // For now we use the first match, we may add priorities in future, but I'm coutious about adding more property for any aspect unless needed.
                    const desc = candidates[0];
                    if (!desc) {
                        return this.defaultInMemoryStore;
                    }
                    if (this.stores[desc.uniqueName]) {
                        return this.stores[desc.uniqueName];
                    }
                    const store = new desc.cons(this.manager.domain);
                    yield store.cleanStaleProcedureMetas();
                    return this.stores[desc.uniqueName] = store;
                });
            }
            get descriptors() {
                const stores = this.manager.domain.findAspects("store");
                return stores;
            }
            match(option) {
                if (!option.store.for)
                    return true;
                if (Array.isArray(option.store.for) && option.store.for.length == 0)
                    return true;
                if (!Array.isArray(option.store.for)) {
                    throw new errors_1.Errors.DesignError(`${option.store.uniqueName}.for must be an array of string`);
                }
                for (let matcher of option.store.for) {
                    if (matcher === option.procedure.uniqueName)
                        return true;
                    let isMatch = this.manager.domain.codex.namespace.isMatchNameOrFullName(option.procedure.familyName, matcher);
                    if (isMatch)
                        return true;
                }
                return false;
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _getStore_decorators = [Leaf.lock()];
            _getStoreForProcedure_decorators = [Leaf.lock()];
            _get_descriptors_decorators = [Leaf.cache()];
            __esDecorate(_a, null, _getStore_decorators, { kind: "method", name: "getStore", static: false, private: false, access: { has: obj => "getStore" in obj, get: obj => obj.getStore }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _getStoreForProcedure_decorators, { kind: "method", name: "getStoreForProcedure", static: false, private: false, access: { has: obj => "getStoreForProcedure" in obj, get: obj => obj.getStoreForProcedure }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _get_descriptors_decorators, { kind: "getter", name: "descriptors", static: false, private: false, access: { has: obj => "descriptors" in obj, get: obj => obj.descriptors }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.ProcedureStoreManager = ProcedureStoreManager;
//# sourceMappingURL=manager.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/procedure.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/procedure.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Design rules:
// 1. No journal inside journal, No wait inside journal.
// 2. No write datas outside the journal during async journal(You can read).
// 3. No write cache, sync action should have no error, async action shold be inside journal which return error as part of journal result.
// 4. No async action out side the journal, except for `await ctx.xxx`.
// 5. Async fn journal should interact with one external resource at one journal
// 6. Async fn journal should have 2 clauses,
//    a) if one clause for check resource already expected and return journal value
//    b) else another clause for modify resource as expected and return journal value
//    both should return identical result. In these manner we won't cause duplication during restore.
// 7. Sync action shouldn't read/write variables/states outside the function body.
// 8. Async fn journal better not be a long running work. If we need to interact with a long running work
//    just use journal to initiate the work and return the work id, then use wait to wait for the work to finish,
//    and get notified by wait/feed api set.(So when interrupt happens during journal,
//    we will wait the journal to be finished before we fully interrupt, since it's not long running work,
//    the waiting time should be reasonable), and we have the running result recorded, which is great.
//    So only if we have pre-journal and missing journal, we will have to run the check clause to test current
//    situation precisely. That is we intend to have more journal stored before interrupted instead.
// 9. Do not start procedure and feed a wait immeiately, if it can be decided at beginning, pass it or the relative information as input.
// 10. All time-heavy work be it sync or async should be done in journal.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Procedure = void 0;
class Procedure {
}
exports.Procedure = Procedure;
//# sourceMappingURL=procedure.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/restore.js":
/*!***************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/restore.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _RestorableBehavior_offset, _RestorableBehavior_pendingRecords;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RestorableBehavior = void 0;
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/procedure/errors.js");
// possible restore sequence is
// [Begin(id,Input)]([post-W,dI?][pre-M,dI?,post-M,dI?,tE?](Sn*,tE?,I?)+)+[End(E?|Output)]
class RestorableBehavior {
    constructor(runner) {
        this.runner = runner;
        _RestorableBehavior_offset.set(this, 0);
        _RestorableBehavior_pendingRecords.set(this, void 0);
    }
    get interruptable() {
        return this.runner.interruptable;
    }
    setPendingRecords(records) {
        __classPrivateFieldSet(this, _RestorableBehavior_pendingRecords, records.slice(), "f");
        __classPrivateFieldSet(this, _RestorableBehavior_offset, 0, "f");
    }
    get rollbackable() {
        return this.runner.rollbackable;
    }
    get states() {
        return this.runner.states;
    }
    get events() {
        return this.runner.events;
    }
    reset() {
        __classPrivateFieldSet(this, _RestorableBehavior_offset, 0, "f");
        __classPrivateFieldSet(this, _RestorableBehavior_pendingRecords, [], "f");
    }
    get next() {
        return __classPrivateFieldGet(this, _RestorableBehavior_pendingRecords, "f")[0];
    }
    cutoff() {
        __classPrivateFieldSet(this, _RestorableBehavior_pendingRecords, [], "f");
        this.states.set("running");
        this.runner.events.emit("restored");
        return __classPrivateFieldGet(this, _RestorableBehavior_offset, "f");
    }
    expect(type) {
        if (this.runner.state !== "restoring") {
            throw new errors_1.Errors.InternalDesignError("ProcedureRunner.expect() called outside of restore");
        }
        if (!this.next) {
            throw new errors_1.Errors.InternalDesignError("ProcedureRunner.expect() called with no more data");
        }
        if (this.next[0] !== type) {
            throw new errors_1.Errors.ConflictError(`ProcedureRunner.expect() called with wrong type ${type} given ${this.next[0]}`);
        }
        // We use #offset to track how many step we go.
        // When cutoff, we can provide this information, so
        // we can cutoff the commitable at the same place
        __classPrivateFieldSet(this, _RestorableBehavior_offset, __classPrivateFieldGet(this, _RestorableBehavior_offset, "f") + 1, "f");
        const rec = __classPrivateFieldGet(this, _RestorableBehavior_pendingRecords, "f").shift();
        if (!this.next) {
            this.rollbackable.guardNotRollback();
            this.states.set("running");
            this.runner.events.emit("restored");
        }
        return rec[1];
    }
}
exports.RestorableBehavior = RestorableBehavior;
_RestorableBehavior_offset = new WeakMap(), _RestorableBehavior_pendingRecords = new WeakMap();
//# sourceMappingURL=restore.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/rollback.js":
/*!****************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/rollback.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RollbackableBehavior = exports.StartCheckpointSymbol = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/procedure/errors.js");
exports.StartCheckpointSymbol = Leaf.ensureGlobal("BranchTsStartCheckPointSymbol", () => Symbol("BranchTsStartCheckPointSymbol"));
let RollbackableBehavior = (() => {
    var _a, _RollbackableBehavior_counter, _RollbackableBehavior_checkpoints, _RollbackableBehavior_isDuringRollback, _RollbackableBehavior_rollbackTarget;
    let _instanceExtraInitializers = [];
    let _rollback_decorators;
    let _checkpoint_decorators;
    return _a = class RollbackableBehavior {
            get store() {
                return this.runner.store;
            }
            get journalable() {
                return this.runner.journalable;
            }
            get waitable() {
                return this.runner.waitable;
            }
            get states() {
                return this.runner.states;
            }
            get restorable() {
                return this.runner.restorable;
            }
            get timeable() {
                return this.runner.timeable;
            }
            get commitable() {
                return this.runner.commitable;
            }
            get interruptable() {
                return this.runner.interruptable;
            }
            get counter() {
                return __classPrivateFieldGet(this, _RollbackableBehavior_counter, "f");
            }
            get maxRollback() {
                return 1000;
            }
            constructor(runner) {
                this.runner = (__runInitializers(this, _instanceExtraInitializers), runner);
                _RollbackableBehavior_counter.set(this, 0);
                _RollbackableBehavior_checkpoints.set(this, []);
                _RollbackableBehavior_isDuringRollback.set(this, false);
                _RollbackableBehavior_rollbackTarget.set(this, null);
            }
            never() {
                return __awaiter(this, void 0, void 0, function* () {
                    return new Promise((res, rej) => {
                        // never call anything
                    });
                });
            }
            rollback(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    let target;
                    let feeds = [];
                    if (__classPrivateFieldGet(this, _RollbackableBehavior_isDuringRollback, "f")) {
                        throw new errors_1.Errors.AbuseError("Can't rollback when already rollback");
                    }
                    if (typeof option == "string" || typeof option == "symbol") {
                        target = option;
                    }
                    else if (typeof option == "object" && !!option) {
                        target = option.target || null;
                        feeds = option.feeds || [];
                    }
                    if (this.states.state == "restoring") {
                        throw new errors_1.Errors.AbuseError("Try rollback while restoring");
                    }
                    if (this.maxRollback <= this.counter) {
                        throw new errors_1.Errors.AbuseError(`Can't rollback more than maxRollback ${this.maxRollback}`);
                    }
                    if (target && !this.checkpoints.includes(target)) {
                        throw new errors_1.Errors.AbuseError(`Checkpoint ${JSON.stringify(target)} is not happened`);
                    }
                    if (!this.commitable.isClean) {
                        throw new errors_1.Errors.AbuseError("Rollback when commit is not clean");
                    }
                    this.journalable.guard();
                    this.waitable.guard();
                    this.waitable.dropPendingData();
                    if (!target)
                        target = this.checkpoints.at(-1);
                    // rollback NoCheckPointSymbol
                    if (!target) {
                        __classPrivateFieldSet(this, _RollbackableBehavior_rollbackTarget, exports.StartCheckpointSymbol, "f");
                    }
                    else {
                        __classPrivateFieldSet(this, _RollbackableBehavior_rollbackTarget, target, "f");
                    }
                    this.interruptable.reset();
                    __classPrivateFieldGet(this, _RollbackableBehavior_checkpoints, "f").length = 0;
                    __classPrivateFieldSet(this, _RollbackableBehavior_counter, __classPrivateFieldGet(this, _RollbackableBehavior_counter, "f") + 1, "f");
                    __classPrivateFieldSet(this, _RollbackableBehavior_isDuringRollback, true, "f");
                    const records = this.commitable.records.slice();
                    const input = this.runner.routine.input;
                    this.runner.displayable.reset();
                    this.runner.routine.reset();
                    this.runner.interruptable.reset();
                    this.runner.abortable.reset();
                    this.runner.restorable.reset();
                    this.runner.commitable.reset();
                    this.runner.events.emit("reset");
                    this.states.rollback();
                    this.restorable.setPendingRecords(records);
                    this.commitable.setRecords(records);
                    this.runner.routine.begin(input);
                    if (feeds.length > 0) {
                        for (let rec of feeds) {
                            if (!Array.isArray(rec))
                                continue;
                            const [name, data] = rec;
                            this.runner.waitable.feed(name, data);
                        }
                    }
                    return yield this.never();
                });
            }
            get checkpoints() {
                return __classPrivateFieldGet(this, _RollbackableBehavior_checkpoints, "f").slice();
            }
            checkpoint(identifier) {
                let match = () => {
                    if (typeof __classPrivateFieldGet(this, _RollbackableBehavior_rollbackTarget, "f") == "function") {
                        return __classPrivateFieldGet(this, _RollbackableBehavior_rollbackTarget, "f").call(this, identifier);
                    }
                    else {
                        return __classPrivateFieldGet(this, _RollbackableBehavior_rollbackTarget, "f") === identifier;
                    }
                };
                if (__classPrivateFieldGet(this, _RollbackableBehavior_isDuringRollback, "f") && match()) {
                    const pos = this.restorable.cutoff();
                    this.commitable.cutoff(pos);
                    __classPrivateFieldSet(this, _RollbackableBehavior_isDuringRollback, false, "f");
                }
                if (this.checkpoints.includes(identifier)) {
                    throw new errors_1.Errors.AbuseError(`Duplicate checkpoint of ${identifier.toString()}, repatitive checkpoint is not allowed`);
                }
                __classPrivateFieldGet(this, _RollbackableBehavior_checkpoints, "f").push(identifier);
            }
            reset() {
            }
            get isRollback() {
                return __classPrivateFieldGet(this, _RollbackableBehavior_isDuringRollback, "f");
            }
            guardNotRollback() {
                var _b;
                if (this.isRollback) {
                    throw new errors_1.Errors.AbuseError(`Rollback to unavailable state ${(_b = __classPrivateFieldGet(this, _RollbackableBehavior_rollbackTarget, "f")) === null || _b === void 0 ? void 0 : _b.toString()}`);
                }
            }
        },
        _RollbackableBehavior_counter = new WeakMap(),
        _RollbackableBehavior_checkpoints = new WeakMap(),
        _RollbackableBehavior_isDuringRollback = new WeakMap(),
        _RollbackableBehavior_rollbackTarget = new WeakMap(),
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _rollback_decorators = [Leaf.bound()];
            _checkpoint_decorators = [Leaf.bound()];
            __esDecorate(_a, null, _rollback_decorators, { kind: "method", name: "rollback", static: false, private: false, access: { has: obj => "rollback" in obj, get: obj => obj.rollback }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _checkpoint_decorators, { kind: "method", name: "checkpoint", static: false, private: false, access: { has: obj => "checkpoint" in obj, get: obj => obj.checkpoint }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.RollbackableBehavior = RollbackableBehavior;
//# sourceMappingURL=rollback.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/runner.js":
/*!**************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/runner.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Routine_isStarted, _Routine_input, _Routine_error, _Routine_output;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Routine = exports.ProcedureRunner = void 0;
const commit_1 = __webpack_require__(/*! ./commit */ "./node_modules/@branch-ts/core/src/procedure/commit.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/procedure/errors.js");
const restore_1 = __webpack_require__(/*! ./restore */ "./node_modules/@branch-ts/core/src/procedure/restore.js");
const store_1 = __webpack_require__(/*! ./store */ "./node_modules/@branch-ts/core/src/procedure/store.js");
const util_1 = __webpack_require__(/*! ./util */ "./node_modules/@branch-ts/core/src/procedure/util.js");
const wait_1 = __webpack_require__(/*! ./wait */ "./node_modules/@branch-ts/core/src/procedure/wait.js");
const states_1 = __webpack_require__(/*! ./states */ "./node_modules/@branch-ts/core/src/procedure/states.js");
const abort_1 = __webpack_require__(/*! ./abort */ "./node_modules/@branch-ts/core/src/procedure/abort.js");
const const_1 = __webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/procedure/const.js");
const interrupt_1 = __webpack_require__(/*! ./interrupt */ "./node_modules/@branch-ts/core/src/procedure/interrupt.js");
const log_1 = __webpack_require__(/*! ../log */ "./node_modules/@branch-ts/core/src/log.js");
const checkpoint_1 = __webpack_require__(/*! ./checkpoint */ "./node_modules/@branch-ts/core/src/procedure/checkpoint.js");
const journal_1 = __webpack_require__(/*! ./journal */ "./node_modules/@branch-ts/core/src/procedure/journal.js");
const display_1 = __webpack_require__(/*! ./display */ "./node_modules/@branch-ts/core/src/procedure/display.js");
const implement_1 = __webpack_require__(/*! ./implement */ "./node_modules/@branch-ts/core/src/procedure/implement.js");
const time_1 = __webpack_require__(/*! ./time */ "./node_modules/@branch-ts/core/src/procedure/time.js");
const rollback_1 = __webpack_require__(/*! ./rollback */ "./node_modules/@branch-ts/core/src/procedure/rollback.js");
let ProcedureRunner = (() => {
    var _a, _ProcedureRunner_flags, _ProcedureRunner_id, _ProcedureRunner_version, _ProcedureRunner_name, _ProcedureRunner_revision, _ProcedureRunner_store, _ProcedureRunner_main, _ProcedureRunner_signatures;
    let _instanceExtraInitializers = [];
    let _run_decorators;
    let _restoreAndRun_decorators;
    return _a = class ProcedureRunner {
            debug(...infos) {
                var _b;
                if (!this.isDebug && !((_b = this.domain) === null || _b === void 0 ? void 0 : _b.isDebug))
                    return;
                log_1.Logger.debug(this.name, ...infos);
            }
            get context() {
                const self = this;
                return {
                    get id() {
                        return self.id;
                    },
                    get revision() {
                        return self.revision;
                    },
                    get name() {
                        return self.name;
                    },
                    get version() {
                        return self.version;
                    },
                    get domain() {
                        return self.domain;
                    },
                    assert(v, message) {
                        if (!!v)
                            return;
                        throw new errors_1.Errors.AssertError(`${self.version}[${self.id}]: ${message}`);
                    },
                    now: this.timeable.now,
                    sleep: this.timeable.sleep,
                    makeId: this.util.makeId,
                    random: this.util.random,
                    journal: this.journalable.journal,
                    display: this.displayable.display,
                    wait: this.waitable.wait,
                    waitAny: this.waitable.waitAny,
                    waitAll: this.waitable.waitAll,
                    guardInterrupt: this.interruptable.guardInterrupt,
                    abort(message) {
                        throw new errors_1.Errors.AbortError(message);
                    },
                    checkpoint: this.rollbackable.checkpoint,
                    rollback: this.rollbackable.rollback,
                    implement: this.implementable.mock,
                    locale: this.locale,
                };
            }
            until(target, timeout) {
                return __awaiter(this, void 0, void 0, function* () {
                    const wait = () => __awaiter(this, void 0, void 0, function* () {
                        if (target == "end") {
                            if (this.state == "end") {
                                return;
                            }
                            else {
                                return yield this.events.wait("end");
                            }
                        }
                        else if (target == "hang") {
                            if (this.state === "hang") {
                                return;
                            }
                            else {
                                return yield this.events.wait("hang");
                            }
                        }
                        else if (target == "restored") {
                            if (this.state == "restoring") {
                                return yield this.events.wait("restored");
                            }
                            else {
                                return;
                            }
                        }
                        else if (target == "output") {
                            if (this.routine.output)
                                return;
                            if (this.state == "end") {
                                if (this.routine.error) {
                                    yield this.interruptable.never();
                                }
                                return;
                            }
                            else {
                                return yield this.events.wait("output");
                            }
                        }
                        else if (target == "error") {
                            if (this.routine.error)
                                return;
                            if (this.state == "end") {
                                if (this.routine.error) {
                                    return;
                                }
                                else {
                                    yield this.interruptable.never();
                                }
                            }
                            else {
                                return yield this.events.wait("error");
                            }
                        }
                        else if (target == "fin") {
                            return yield _a.raceIgnorance([this.until("end"), this.until("hang")]);
                        }
                    });
                    const todos = [];
                    let timer;
                    if (timeout > 0) {
                        todos.push(new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
                            timer = setTimeout(() => {
                                rej(new Error("Timeout"));
                            }, timeout);
                        })));
                    }
                    todos.push(wait());
                    const result = yield _a.raceIgnorance(todos);
                    if (timer) {
                        clearTimeout(timer);
                    }
                    return result;
                });
            }
            get used() {
                return this.routine.isStarted;
            }
            run(input) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.used) {
                        throw new errors_1.Errors.AbuseError("Already running");
                    }
                    this.states.set("running");
                    yield this.routine.begin(input);
                    return this;
                });
            }
            restoreAndRun(input, records) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.used) {
                        throw new errors_1.Errors.AbuseError("Already run");
                    }
                    this.states.set("restoring");
                    if (!records) {
                        const history = yield this.store.getRecords({ id: this.id, version: this.version });
                        if (history) {
                            records = history;
                        }
                    }
                    if (!records || records.length == 0) {
                        throw new errors_1.Errors.AbuseError(`Procedure no records given and not found in store ${this.version}:${this.id}`);
                    }
                    else {
                        this.restorable.setPendingRecords(records);
                        this.commitable.setRecords(records);
                        yield this.routine.begin(input);
                        return this;
                    }
                });
            }
            get flags() {
                return Object.assign(Object.assign({}, __classPrivateFieldGet(this, _ProcedureRunner_flags, "f")), { end: this.state === "end", hang: this.state === "hang", conflict: errors_1.ErrorSpec.isConflictError(this.routine.error), abuse: errors_1.ErrorSpec.isAbuseError(this.routine.error), aborted: errors_1.ErrorSpec.isAbortError(this.routine.error), aborting: errors_1.ErrorSpec.isAbortError(this.routine.error) || this.abortable.isAborting, interrupted: this.interruptable.isInterrupted, interrupting: this.interruptable.isInterrupting, fin: ["end", "hang"].includes(this.state) });
            }
            setFlag(name, v) {
                __classPrivateFieldGet(this, _ProcedureRunner_flags, "f")[name] = v;
            }
            see(name) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (typeof this.displayable.displays[name] !== "undefined") {
                        return this.displayable.displays[name];
                    }
                    return new Promise((res, rej) => {
                        this.events.once(`display/${name.toString()}`, (v) => {
                            res(v);
                        });
                        this.until("fin").then(() => {
                            if (this.routine.error) {
                                rej(this.routine.error);
                            }
                            else {
                                rej(new errors_1.Errors.DesignError("Procedure ended before display" + name.toString()));
                            }
                        });
                    });
                });
            }
            get state() {
                return this.states.state;
            }
            get situation() {
                const stateNotPartOfRun = ["void", "restoring"];
                if (stateNotPartOfRun.includes(this.state)) {
                    return {
                        id: this.id,
                        name: this.name,
                        revision: this.revision,
                        version: this.version,
                        state: this.state,
                        display: {},
                        waitings: [],
                    };
                }
                return {
                    id: this.id,
                    name: this.name,
                    revision: this.revision,
                    version: this.version,
                    state: this.state,
                    waitings: this.waitable.waits.slice(),
                    display: this.displayable.displays,
                    flags: this.flags,
                    output: this.routine.output,
                    error: this.routine.error,
                };
            }
            get id() {
                return __classPrivateFieldGet(this, _ProcedureRunner_id, "f");
            }
            get revision() {
                return __classPrivateFieldGet(this, _ProcedureRunner_revision, "f") || 0;
            }
            get name() {
                return __classPrivateFieldGet(this, _ProcedureRunner_name, "f");
            }
            get version() {
                return __classPrivateFieldGet(this, _ProcedureRunner_version, "f") || [this.name, this.revision].join(":");
            }
            get store() {
                return __classPrivateFieldGet(this, _ProcedureRunner_store, "f");
            }
            get main() {
                return __classPrivateFieldGet(this, _ProcedureRunner_main, "f");
            }
            get signatures() {
                return __classPrivateFieldGet(this, _ProcedureRunner_signatures, "f");
            }
            fin() {
                return __awaiter(this, void 0, void 0, function* () {
                    yield this.until("fin");
                    if (this.routine.error) {
                        throw this.routine.error;
                    }
                    else {
                        return this.routine.output;
                    }
                });
            }
            constructor(option) {
                this.option = (__runInitializers(this, _instanceExtraInitializers), option);
                this.events = new Leaf.EventEmitter();
                this.commitable = new commit_1.Commitable(this);
                this.routine = new Routine(this);
                this.util = new util_1.UtilCapable(this);
                this.journalable = new journal_1.JournalableBehavior(this);
                this.waitable = new wait_1.WaitableBehavior(this);
                this.displayable = new display_1.DisplayableBehavior(this);
                this.interruptable = new interrupt_1.Interruptable(this);
                this.abortable = new abort_1.AbortableBehavior(this);
                this.checkpointable = new checkpoint_1.CheckpointCapable(this);
                this.restorable = new restore_1.RestorableBehavior(this);
                this.rollbackable = new rollback_1.RollbackableBehavior(this);
                this.implementable = new implement_1.Implementable();
                this.timeable = new time_1.Timeable(this);
                this.states = new states_1.States(this);
                this.isDebug = false;
                _ProcedureRunner_flags.set(this, {
                    archive: false,
                    restore: false,
                    conflict: false,
                    end: false
                });
                _ProcedureRunner_id.set(this, void 0);
                _ProcedureRunner_version.set(this, void 0);
                _ProcedureRunner_name.set(this, void 0);
                _ProcedureRunner_revision.set(this, void 0);
                _ProcedureRunner_store.set(this, void 0);
                _ProcedureRunner_main.set(this, void 0);
                _ProcedureRunner_signatures.set(this, []);
                this.locale = this.option.locale || "en";
                this.domain = option.domain;
                __classPrivateFieldSet(this, _ProcedureRunner_id, option.id || this.domain.codex.generateId(), "f");
                __classPrivateFieldSet(this, _ProcedureRunner_name, option.name, "f");
                __classPrivateFieldSet(this, _ProcedureRunner_revision, option.revision || 0, "f");
                __classPrivateFieldSet(this, _ProcedureRunner_version, option.version || null, "f");
                __classPrivateFieldSet(this, _ProcedureRunner_main, option.main, "f");
                __classPrivateFieldSet(this, _ProcedureRunner_store, option.store || new store_1.InMemoryProcedureStore(), "f");
                __classPrivateFieldSet(this, _ProcedureRunner_signatures, option.signatures || [], "f");
                this.implementable.implements(option.implement || {});
                this.isDebug = option.debug || false;
            }
            // [TODO] safe guard async fns about abort
            static purify(v) {
                if (v === null)
                    return v;
                if (typeof v == "undefined")
                    return v;
                return JSON.parse(JSON.stringify(v));
            }
            static returnImmediate(value) {
                return __awaiter(this, void 0, void 0, function* () {
                    return new Promise((resolve, reject) => {
                        this.runImmeidate(() => __awaiter(this, void 0, void 0, function* () {
                            resolve(yield value);
                        }));
                    });
                });
            }
            static runImmeidate(fn) {
                return __awaiter(this, void 0, void 0, function* () {
                    return new Promise((resolve, reject) => {
                        // Set timeout 0 should be enough for now.
                        setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                            let result;
                            try {
                                result = yield fn();
                            }
                            catch (e) {
                                reject(e);
                                return;
                            }
                            resolve(result);
                        }), 0);
                    });
                });
            }
            static raceIgnorance(ps) {
                let done = false;
                return new Promise((res, rej) => {
                    for (let p of ps) {
                        p.then((result) => {
                            if (done)
                                return;
                            done = true;
                            res(result);
                        }).catch(e => {
                            if (done)
                                return;
                            done = true;
                            rej(e);
                        });
                    }
                });
            }
        },
        _ProcedureRunner_flags = new WeakMap(),
        _ProcedureRunner_id = new WeakMap(),
        _ProcedureRunner_version = new WeakMap(),
        _ProcedureRunner_name = new WeakMap(),
        _ProcedureRunner_revision = new WeakMap(),
        _ProcedureRunner_store = new WeakMap(),
        _ProcedureRunner_main = new WeakMap(),
        _ProcedureRunner_signatures = new WeakMap(),
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _run_decorators = [Leaf.lock("run")];
            _restoreAndRun_decorators = [Leaf.lock("run")];
            __esDecorate(_a, null, _run_decorators, { kind: "method", name: "run", static: false, private: false, access: { has: obj => "run" in obj, get: obj => obj.run }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _restoreAndRun_decorators, { kind: "method", name: "restoreAndRun", static: false, private: false, access: { has: obj => "restoreAndRun" in obj, get: obj => obj.restoreAndRun }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.ProcedureRunner = ProcedureRunner;
class Routine {
    constructor(runner) {
        this.runner = runner;
        _Routine_isStarted.set(this, false);
        _Routine_input.set(this, void 0);
        _Routine_error.set(this, void 0);
        _Routine_output.set(this, void 0);
    }
    get commitable() {
        return this.runner.commitable;
    }
    get restorable() {
        return this.runner.restorable;
    }
    get states() {
        return this.runner.states;
    }
    get events() {
        return this.runner.events;
    }
    get abortable() {
        return this.abortable;
    }
    waitRestoreToLatestOrUnexpected() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.runner.state == "restoring") {
                return yield Promise.race([this.events.wait("restored"), this.events.wait("hang")]);
            }
            if (this.runner.state == "end") {
                return;
            }
            if (this.runner.state == "void") {
                throw new errors_1.Errors.AbuseError("Routine.begin() not called before wait fin");
            }
            throw new errors_1.Errors.AbuseError(`Routine.waitRestoreToLatestOrUnexpected() called in wrong state ${this.runner.state}`);
        });
    }
    get isStarted() {
        return __classPrivateFieldGet(this, _Routine_isStarted, "f");
    }
    reset() {
        __classPrivateFieldSet(this, _Routine_isStarted, false, "f");
        __classPrivateFieldSet(this, _Routine_input, null, "f");
        __classPrivateFieldSet(this, _Routine_error, null, "f");
        __classPrivateFieldSet(this, _Routine_output, null, "f");
    }
    get input() {
        return __classPrivateFieldGet(this, _Routine_input, "f");
    }
    begin(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (__classPrivateFieldGet(this, _Routine_isStarted, "f")) {
                throw new errors_1.Errors.AbuseError("Routine.begin() called while routine is running, it can only be caused once");
            }
            __classPrivateFieldSet(this, _Routine_isStarted, true, "f");
            __classPrivateFieldSet(this, _Routine_input, input, "f");
            if (this.runner.state == "restoring") {
                return yield this.beginRestore(input);
            }
            else if (this.runner.state == "running") {
                return yield this.beginRunning(input);
            }
        });
    }
    beginRunning(input) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.commitable.begin({
                    id: this.runner.id,
                    input
                });
            }
            catch (e) {
                this.finByHangWithError(new errors_1.Errors.InternalRuntimeError(`Begin failed with error ${e}`));
                throw e;
            }
            this.events.emit("begin");
            this._main(input);
        });
    }
    beginRestore(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const begin = this.restorable.expect(const_1.Const.RecordType.Begin);
            this.runner.timeable.syncJournableTime(begin.time);
            // Maybe we should check begin in future
            if (begin.id !== this.runner.id) {
                this.finByHangWithError(new errors_1.Errors.ConflictError(`Restore begin id conflict, expect ${this.runner.id} but got ${begin.id}`));
                return;
            }
            this.events.emit("begin");
            this._main(begin.input);
        });
    }
    _main(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const main = this.runner.main;
            this.runner.rollbackable.checkpoint(rollback_1.StartCheckpointSymbol);
            const mainPromise = ProcedureRunner.runImmeidate(() => __awaiter(this, void 0, void 0, function* () {
                return yield main(this.runner.context, input);
            }));
            let result;
            let error;
            try {
                result = (yield ProcedureRunner.raceIgnorance([mainPromise, this.interruptable.promise]));
            }
            catch (e) {
                error = e;
            }
            if (error) {
                yield this.withError(error);
            }
            else {
                yield this.withResult(result);
            }
        });
    }
    get output() {
        return __classPrivateFieldGet(this, _Routine_output, "f");
    }
    set output(output) {
        __classPrivateFieldSet(this, _Routine_output, output, "f");
        this.events.emit("output");
    }
    get error() {
        return __classPrivateFieldGet(this, _Routine_error, "f");
    }
    setError(e) {
        __classPrivateFieldSet(this, _Routine_error, e, "f");
        this.events.emit("error", e);
    }
    get interruptable() {
        return this.runner.interruptable;
    }
    // NEVER throw during withErrorXXX and withResultXXX
    withErrorRunning(e) {
        return __awaiter(this, void 0, void 0, function* () {
            // 1. Abort end with abort an commit
            // 2. InterruptError other than abort, we hang
            // 3. Other error we end with error and commit
            if (errors_1.ErrorSpec.isAbortError(e) || !this.interruptable.isInterruptError(e)) {
                yield this.commitable.end({
                    ok: false,
                    error: e
                });
                this.finWithError(e);
            }
            else {
                return this.finByHangWithError(e);
            }
        });
    }
    withErrorRestoring(el) {
        return __awaiter(this, void 0, void 0, function* () {
            const e = errors_1.ErrorSpec.from(el);
            if (this.interruptable.isInterruptError(e) && !errors_1.ErrorSpec.isAbortError(e)) {
                // => 3.
                // Interrupt error is impossible to derive from record, it must be invaliate code
                this.finByHangWithError(e);
                return;
            }
            const end = this.restorable.expect(const_1.Const.RecordType.End);
            // 1. Check previous end with error
            // 2. Abort check end with abort.
            // 3. InterruptError other than end => hang, no need to check state
            // 4. Other error check end with exact error.
            // 5. => normally end with error
            if (!end.error) {
                // => 1.
                this.finByHangWithError(new errors_1.Errors.ConflictError(`Restore end error conflict, expect correct return but got error ${e}`));
                return;
            }
            else {
                if (!errors_1.ErrorSpec.isLikelySameError(e, end.error)) {
                    // => 2. && 4. is the same
                    const expect = errors_1.ErrorSpec.from(end.error);
                    this.finByHangWithError(new errors_1.Errors.ConflictError(`Restore end error conflict, expect error ${expect} return but got error ${e}`));
                    return;
                }
                else {
                    if (this.runner.state !== "running") {
                        // After last End rec popped, we should be in running state (set by restorable.expect)
                        log_1.Logger.error(`End should be the last record of replay, but we still have unsolved record, and this is an system bug, please report.`);
                    }
                    // Fullly restored
                    this.runner.setFlag("archive", true);
                    this.finWithError(e);
                    return;
                }
            }
        });
    }
    withError(e) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.runner.state == "running") {
                return yield this.withErrorRunning(e);
            }
            else if (this.runner.state == "restoring") {
                return yield this.withErrorRestoring(e);
            }
        });
    }
    // NEVER throw
    withResult(result) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.runner.state == "running") {
                return yield this.withResultRunning(result);
            }
            else if (this.runner.state == "restoring") {
                return yield this.withResultRestoring(result);
            }
        });
    }
    withResultRunning(result) {
        return __awaiter(this, void 0, void 0, function* () {
            // End with result and commit
            yield this.commitable.end({
                ok: true,
                output: result,
                error: null,
            });
            this.finWithResult(result);
        });
    }
    withResultRestoring(result) {
        return __awaiter(this, void 0, void 0, function* () {
            // Expect correct end
            // Fullly restored
            const end = this.restorable.expect(const_1.Const.RecordType.End);
            this.output = result;
            if (end.error) {
                this.finByHangWithError(new errors_1.Errors.ConflictError(`Restore end error conflict, expect error ${errors_1.ErrorSpec.from(end.error)} return but are clean return`));
                return;
            }
            if (!Leaf.Util.deepEqual(end.output, result)) {
                this.finByHangWithError(new errors_1.Errors.ConflictError(`Restore end has different result than previous run`));
                return;
            }
            this.runner.setFlag("archive", true);
            this.finWithResult(result);
        });
    }
    finWithResult(result) {
        this.runner.debug("Fin with result", result);
        this.output = result;
        this.states.set("end");
    }
    finWithError(e) {
        __classPrivateFieldSet(this, _Routine_error, errors_1.ErrorSpec.from(e), "f");
        this.runner.debug("Fin with error", e);
        if (errors_1.ErrorSpec.isAbortError(e)) {
            this.interruptable.markInterrupt(__classPrivateFieldGet(this, _Routine_error, "f"));
        }
        this.states.set("end");
        this.events.emit("error", __classPrivateFieldGet(this, _Routine_error, "f"));
    }
    finByHangWithError(e) {
        this.runner.debug("Hang with error", e);
        __classPrivateFieldSet(this, _Routine_error, errors_1.ErrorSpec.from(e), "f");
        this.interruptable.markInterrupt(__classPrivateFieldGet(this, _Routine_error, "f"));
        this.states.hang();
        this.events.emit("error", __classPrivateFieldGet(this, _Routine_error, "f"));
    }
}
exports.Routine = Routine;
_Routine_isStarted = new WeakMap(), _Routine_input = new WeakMap(), _Routine_error = new WeakMap(), _Routine_output = new WeakMap();
//# sourceMappingURL=runner.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/states.js":
/*!**************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/states.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _States_state;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.States = void 0;
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/procedure/errors.js");
const StateOrders = ["void", "restoring", "running", "end", "panic", "hang"];
class States {
    constructor(runner) {
        this.runner = runner;
        _States_state.set(this, "void");
    }
    get events() {
        return this.runner.events;
    }
    set(state) {
        if (__classPrivateFieldGet(this, _States_state, "f") == "hang") {
            throw new errors_1.Errors.InternalDesignError("Shouldn't change state when hang");
        }
        if (state === "panic") {
            throw new errors_1.Errors.InternalDesignError("Shouldn't change state to panic");
        }
        if (!StateOrders.includes(state)) {
            throw new errors_1.Errors.InternalDesignError(`Set invalid state ${state}`);
        }
        if (state === __classPrivateFieldGet(this, _States_state, "f")) {
            throw new errors_1.Errors.InternalDesignError(`Set same state ${state}`);
        }
        if (StateOrders.indexOf(state) < StateOrders.indexOf(__classPrivateFieldGet(this, _States_state, "f"))) {
            throw new errors_1.Errors.InternalDesignError(`State is forward only: ${__classPrivateFieldGet(this, _States_state, "f")} -> ${state}`);
        }
        __classPrivateFieldSet(this, _States_state, state, "f");
        if (state == "restoring") {
            this.runner.setFlag("restore", true);
        }
        if (state == "end") {
            this.events.emit("end");
        }
    }
    get state() {
        return __classPrivateFieldGet(this, _States_state, "f");
    }
    hang() {
        __classPrivateFieldSet(this, _States_state, "hang", "f");
        this.events.emit("hang");
    }
    panic() {
        if (__classPrivateFieldGet(this, _States_state, "f") !== "running") {
            throw new errors_1.Errors.InternalDesignError(`Panic when not running`);
        }
        __classPrivateFieldSet(this, _States_state, "panic", "f");
        this.events.emit("panic");
    }
    recover() {
        if (__classPrivateFieldGet(this, _States_state, "f") !== "panic") {
            throw new errors_1.Errors.InternalDesignError(`Recover when not panic`);
        }
        __classPrivateFieldSet(this, _States_state, "running", "f");
        this.events.emit("recover");
    }
    rollback() {
        if (this.state !== "running") {
            throw new errors_1.Errors.InternalDesignError(`Can't rollback in none running mode`);
        }
        __classPrivateFieldSet(this, _States_state, "restoring", "f");
    }
}
exports.States = States;
_States_state = new WeakMap();
//# sourceMappingURL=states.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/store.js":
/*!*************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/store.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InMemoryProcedureStore = exports.PlaceholderProcedureStore = exports.ProcedureStore = void 0;
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/procedure/errors.js");
const errors_2 = __webpack_require__(/*! ../errors */ "./node_modules/@branch-ts/core/src/errors.js");
const const_1 = __webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/procedure/const.js");
let ProcedureStore = (() => {
    var _a, _ProcedureStore_isCuring;
    let _instanceExtraInitializers = [];
    let _cleanStaleProcedureMetas_decorators;
    let _archiveProcedureMeta_decorators;
    let _commitRecords_decorators;
    return _a = class ProcedureStore {
            constructor() {
                _ProcedureStore_isCuring.set(this, (__runInitializers(this, _instanceExtraInitializers), false));
            }
            get isCuring() {
                return __classPrivateFieldGet(this, _ProcedureStore_isCuring, "f");
            }
            cleanStaleProcedureMetas() {
                return __awaiter(this, void 0, void 0, function* () {
                    __classPrivateFieldSet(this, _ProcedureStore_isCuring, true, "f");
                    // 1. clean pendings
                    // 2. clean archivings
                    while (true) {
                        const pendingMetas = yield this.getPendingProcedureMetas();
                        if (!pendingMetas || pendingMetas.length == 0) {
                            break;
                        }
                        for (let meta of pendingMetas) {
                            yield this.revokeBrokenMeta(meta);
                        }
                    }
                    while (true) {
                        const archivingMetas = yield this.getArchivingProcedureMetas();
                        if (!archivingMetas || archivingMetas.length == 0) {
                            break;
                        }
                        for (let meta of archivingMetas) {
                            yield this.revokeBrokenMeta(meta);
                        }
                    }
                    __classPrivateFieldSet(this, _ProcedureStore_isCuring, false, "f");
                });
            }
            revokeBrokenMeta(meta) {
                var _b;
                return __awaiter(this, void 0, void 0, function* () {
                    const brokenPhase = ["init", "archiving"];
                    if (brokenPhase.includes(meta.phase)) {
                        throw new errors_1.Errors.AbuseError(`Can't revoke broken meta in phase ${meta.phase}`);
                    }
                    const signatures = ((_b = meta.signatures) === null || _b === void 0 ? void 0 : _b.slice()) || [];
                    signatures.sort();
                    const toRevokes = [];
                    for (let signature of signatures) {
                        // Safe it procedureId not match or exclusive not exists
                        const exclusive = yield this.getExclusive({
                            signature
                        });
                        if (exclusive && exclusive.procedureId != meta.id) {
                            // If previous exclusive is not belong to current task, the after exclusive will not be as well, since we applied by the same order
                            break;
                        }
                        toRevokes.push(signature);
                    }
                    toRevokes.reverse();
                    // We revoke by reverse order, to garrentee that is current signature is revoked, all signature is garrentee to be revoked.
                    for (let signature of toRevokes) {
                        yield this.revokeExclusive({
                            procedureId: meta.id,
                            signature
                        });
                    }
                    if (meta.phase == "init") {
                        yield this.updateProcedureMeta({
                            id: meta.id,
                            phase: "crash",
                        });
                    }
                    else if (meta.phase == "archiving") {
                        yield this.updateProcedureMeta({
                            id: meta.id,
                            phase: "archived",
                        });
                    }
                    return;
                });
            }
            initProcedureMeta(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.isCuring)
                        throw new errors_2.Errors.NotReady("Still curing");
                    const lockedExclusive = [];
                    const revokeExclusive = [];
                    let failure;
                    if (!Array.isArray(option.signatures) || option.signatures.length == 0) {
                        yield this.createProcedureMeta(Object.assign(Object.assign({}, option), { signatures: [], phase: "indexed" }));
                    }
                    else {
                        yield this.createProcedureMeta(Object.assign(Object.assign({}, option), { signatures: option.signatures || [], phase: "init" }));
                        let order = 0;
                        let reason;
                        for (let signature of option.signatures) {
                            try {
                                yield this.createExclusive({
                                    procedureId: option.id,
                                    name: option.name,
                                    version: option.version,
                                    signature,
                                    order: order++,
                                });
                                lockedExclusive.push(signature);
                            }
                            catch (e) {
                                reason = e;
                                failure = signature;
                                revokeExclusive.push(...lockedExclusive);
                                revokeExclusive.reverse();
                                break;
                            }
                        }
                        if (failure) {
                            for (let signature of revokeExclusive) {
                                yield this.revokeExclusive({
                                    procedureId: option.id,
                                    signature
                                });
                            }
                            yield this.updateProcedureMeta({
                                id: option.id,
                                phase: "failed"
                            });
                            throw new errors_1.Errors.ExclusiveError(`Fail to create exclusive of ${failure}:${reason}`);
                        }
                        yield this.updateProcedureMeta({
                            id: option.id,
                            phase: "indexed"
                        });
                    }
                });
            }
            archiveProcedureMeta(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.isCuring)
                        throw new errors_2.Errors.NotReady("Still curing");
                    const storage = yield this.getProcedureMeta(option.id);
                    if (storage.phase == "indexed") {
                        yield this.updateProcedureMeta({
                            id: option.id,
                            end: option.end,
                            phase: "archiving",
                        });
                    }
                    else if (storage.phase !== "archiving") {
                        throw new errors_1.Errors.AbuseError(`Can't archive procedure storage in phase ${storage.phase}`);
                    }
                    const signatures = storage.signatures.slice();
                    // Don't check signature here
                    const toRevokes = [...signatures];
                    /*
                    for (let signature of signatures) {
                        const exclusive = await this.getExclusive({
                            signature
                        })
                        if (!exclusive || exclusive.procedureId !== option.id) {
                            break
                        }
                        toRevokes.push(exclusive.signature)
                    }*/
                    toRevokes.reverse();
                    for (let signature of toRevokes) {
                        yield this.revokeExclusive({
                            procedureId: option.id,
                            signature
                        });
                    }
                    yield this.updateProcedureMeta({
                        id: option.id,
                        phase: "archived"
                    });
                });
            }
            // Should fail in storage is not in indexed phase
            // 1. commitments refuse to include record with RecordData.Begin(should be in the Meta.begin)
            // 2. commitments refuse to include record with RecordData.End(should be in the Meta.end)
            // 3. positoin should be all record's position including begin. So for the first none begin record, it should be 1.
            commitRecords(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.isCuring)
                        throw new errors_2.Errors.NotReady("Still curing");
                    const storage = yield this.getProcedureMeta(option.id);
                    if (storage.phase !== "indexed") {
                        throw new errors_1.Errors.InternalRuntimeError(`Can't commit records in phase ${storage.phase}`);
                    }
                    for (let data of option.commitments) {
                        const code = data[0];
                        if (code === const_1.Const.RecordType.Begin) {
                            throw new errors_1.Errors.InternalDesignError("Can't commit begin record");
                        }
                        if (code == const_1.Const.RecordType.End) {
                            throw new errors_1.Errors.InternalDesignError("Can't commit end record");
                        }
                    }
                    if (option.version && option.version !== storage.version) {
                        throw new errors_1.Errors.AbuseError("Version mismatch");
                    }
                    if (option.rebase) {
                        yield this.cutoffRecords({
                            id: option.id,
                            version: option.version,
                            position: option.position,
                        });
                    }
                    yield this.appendRecords({
                        id: option.id,
                        version: option.version,
                        position: option.position,
                        commitments: option.commitments,
                    });
                });
            }
        },
        _ProcedureStore_isCuring = new WeakMap(),
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _cleanStaleProcedureMetas_decorators = [Leaf.lock()];
            _archiveProcedureMeta_decorators = [Leaf.lockByOption("storage", "id")];
            _commitRecords_decorators = [Leaf.lockByOption("storage", "id")];
            __esDecorate(_a, null, _cleanStaleProcedureMetas_decorators, { kind: "method", name: "cleanStaleProcedureMetas", static: false, private: false, access: { has: obj => "cleanStaleProcedureMetas" in obj, get: obj => obj.cleanStaleProcedureMetas }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _archiveProcedureMeta_decorators, { kind: "method", name: "archiveProcedureMeta", static: false, private: false, access: { has: obj => "archiveProcedureMeta" in obj, get: obj => obj.archiveProcedureMeta }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _commitRecords_decorators, { kind: "method", name: "commitRecords", static: false, private: false, access: { has: obj => "commitRecords" in obj, get: obj => obj.commitRecords }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.ProcedureStore = ProcedureStore;
class PlaceholderProcedureStore extends ProcedureStore {
    createProcedureMeta(option) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    getPendingProcedureMetas() {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    getArchivingProcedureMetas() {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    getProcedureMeta(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return null;
        });
    }
    updateProcedureMeta(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    appendRecords(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    removeProcedureMeta(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    getRecords(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    getExclusive(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return null;
        });
    }
    createExclusive(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    revokeExclusive(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    cutoffRecords(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
}
exports.PlaceholderProcedureStore = PlaceholderProcedureStore;
class InMemoryProcedureStore extends ProcedureStore {
    constructor() {
        super(...arguments);
        this.repo = {};
        this.signatures = new Map();
    }
    createProcedureMeta(option) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.repo[option.id]) {
                throw new errors_2.Errors.AlreadyExists(`Procedure ${option.id} already exists`);
            }
            this.repo[option.id] = {
                id: option.id,
                name: option.name,
                version: option.version,
                signatures: option.signatures,
                phase: option.phase || "init",
                begin: option.begin,
                histories: [],
                position: 1,
                createdAt: Date.now(),
                updatedAt: Date.now(),
            };
            return;
        });
    }
    cutoffRecords(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const storage = this.repo[option.id];
            if (!storage) {
                throw new errors_2.Errors.NotFound(`Procedure ${option.id} not found`);
            }
            if (option.version && storage.version !== option.version) {
                throw new errors_2.Errors.NotFound(`Procedure ${option.id} version not match`);
            }
            if (storage.position < option.position) {
                throw new errors_2.Errors.NotFound(`Procedure ${option.id} position cutoff length exceed`);
            }
            storage.histories = storage.histories.slice(0, option.position - 1);
            storage.position = storage.histories.length + 1;
            return;
        });
    }
    getPendingProcedureMetas() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            for (let id in this.repo) {
                const item = this.repo[id];
                if (item.phase == "init") {
                    result.push(item);
                }
            }
            return result;
        });
    }
    getArchivingProcedureMetas() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            for (let id in this.repo) {
                const item = this.repo[id];
                if (item.phase == "archiving") {
                    result.push(item);
                }
            }
            return result;
        });
    }
    getProcedureMeta(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.repo[id];
        });
    }
    updateProcedureMeta(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const repo = this.repo[option.id];
            if (!repo) {
                throw new errors_2.Errors.NotFound(`Procedure ${option.id} not found`);
            }
            if (option.end)
                repo.end = option.end;
            if (option.phase)
                repo.phase = option.phase;
            return;
        });
    }
    appendRecords(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const storage = this.repo[option.id];
            if (!this.repo[option.id]) {
                throw new errors_1.Errors.InternalRuntimeError("InMemoryProcedureStore.appendRecords() failed, storage not found");
            }
            const position = storage.position;
            if (position !== option.position) {
                throw new errors_1.Errors.InternalRuntimeError("InMemoryProcedureStore.appendRecords() failed, position not match");
            }
            if (option.version && option.version !== storage.version) {
                throw new errors_1.Errors.InternalRuntimeError("InMemoryProcedureStore.commitRecords() failed, version not match");
            }
            storage.histories.push(...option.commitments);
            storage.position = storage.histories.length + 1;
            // Do nothing
            return;
        });
    }
    removeProcedureMeta(option) {
        return __awaiter(this, void 0, void 0, function* () {
            delete this.repo[option.id];
            return;
        });
    }
    getRecords(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = this.repo[option.id];
            if (!info)
                return null;
            if (option.version && info.version !== option.version)
                return null;
            const result = [[const_1.Const.RecordType.Begin, info.begin], ...info.histories];
            if (info.end) {
                result.push([const_1.Const.RecordType.End, info.end]);
            }
            return result;
        });
    }
    getExclusive(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.signatures.get(option.signature);
        });
    }
    createExclusive(option) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.signatures.has(option.signature)) {
                throw new errors_2.Errors.AlreadyExists(`Exclusive ${option.signature} already exists`);
            }
            this.signatures.set(option.signature, {
                procedureId: option.procedureId,
                name: option.name,
                version: option.version,
                order: option.order,
                signature: option.signature,
                createdAt: Date.now(),
            });
            return;
        });
    }
    revokeExclusive(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const uni = this.signatures.get(option.signature);
            if (!uni) {
                throw new errors_2.Errors.NotFound(`Exclusive ${option.signature} not found`);
            }
            if (uni.procedureId !== option.procedureId) {
                throw new errors_2.Errors.NotFound(`Exclusive ${option.signature} exists but not for ${option.procedureId}`);
            }
            this.signatures.delete(option.signature);
            return;
        });
    }
}
exports.InMemoryProcedureStore = InMemoryProcedureStore;
//# sourceMappingURL=store.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/time.js":
/*!************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/time.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Timeable = void 0;
const const_1 = __webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/procedure/const.js");
let Timeable = (() => {
    var _a, _Timeable_journableTime;
    let _instanceExtraInitializers = [];
    let _now_decorators;
    let _sleep_decorators;
    return _a = class Timeable {
            constructor(runner) {
                this.runner = (__runInitializers(this, _instanceExtraInitializers), runner);
                _Timeable_journableTime.set(this, 0);
            }
            setJournableTime(time) {
                __classPrivateFieldSet(this, _Timeable_journableTime, time, "f");
            }
            syncJournableTime(time) {
                __classPrivateFieldSet(this, _Timeable_journableTime, time || Date.now(), "f");
                return __classPrivateFieldGet(this, _Timeable_journableTime, "f");
            }
            get journableTime() {
                return __classPrivateFieldGet(this, _Timeable_journableTime, "f");
            }
            get commitable() {
                return this.runner.commitable;
            }
            get restorable() {
                return this.runner.restorable;
            }
            get journalable() {
                return this.runner.journalable;
            }
            now() {
                this.journalable.guard();
                if (this.runner.state === "restoring") {
                    return this.nowRestore();
                }
                else {
                    return this.nowRunning();
                }
            }
            nowRunning() {
                return this.commitable.add(const_1.Const.RecordType.Now, this.journableTime);
            }
            nowRestore() {
                return this.restorable.expect(const_1.Const.RecordType.Now);
            }
            sleep(time) {
                return __awaiter(this, void 0, void 0, function* () {
                    this.journalable.guard();
                    if (time <= 0)
                        return;
                    if (this.runner.state === "restoring") {
                        yield this.sleepRestore(time);
                    }
                    else {
                        yield this.sleepRunning(time);
                    }
                    return;
                });
            }
            sleepRunning(time) {
                return __awaiter(this, void 0, void 0, function* () {
                    const deadline = this.journableTime + time;
                    const interval = deadline - Date.now();
                    if (interval > 0) {
                        yield Leaf.Util.sleep(interval);
                    }
                    this.syncJournableTime(deadline);
                    return;
                });
            }
            sleepRestore(time) {
                return __awaiter(this, void 0, void 0, function* () {
                    this.syncJournableTime(this.journableTime + time);
                    return;
                });
            }
        },
        _Timeable_journableTime = new WeakMap(),
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _now_decorators = [Leaf.bound()];
            _sleep_decorators = [Leaf.bound()];
            __esDecorate(_a, null, _now_decorators, { kind: "method", name: "now", static: false, private: false, access: { has: obj => "now" in obj, get: obj => obj.now }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _sleep_decorators, { kind: "method", name: "sleep", static: false, private: false, access: { has: obj => "sleep" in obj, get: obj => obj.sleep }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.Timeable = Timeable;
//# sourceMappingURL=time.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/util.js":
/*!************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/util.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UtilCapable = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const const_1 = __webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/procedure/const.js");
let UtilCapable = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _makeId_decorators;
    let _random_decorators;
    return _a = class UtilCapable {
            constructor(runner) {
                this.runner = (__runInitializers(this, _instanceExtraInitializers), runner);
            }
            get commitable() {
                return this.runner.commitable;
            }
            get restorable() {
                return this.runner.restorable;
            }
            get journalable() {
                return this.runner.journalable;
            }
            makeId() {
                this.journalable.guard();
                if (this.runner.state === "restoring") {
                    return this.idRestore();
                }
                else {
                    return this.idRunning();
                }
            }
            idRunning() {
                const id = this.runner.domain.codex.generateId();
                return this.commitable.add(const_1.Const.RecordType.Id, id);
            }
            idRestore() {
                return this.restorable.expect(const_1.Const.RecordType.Id);
            }
            random() {
                this.journalable.guard();
                if (this.runner.state === "restoring") {
                    return this.randomRestore();
                }
                else {
                    return this.randomRunning();
                }
            }
            randomRunning() {
                const random = this.runner.domain.codex.random();
                return this.commitable.add(const_1.Const.RecordType.Random, random);
            }
            randomRestore() {
                return this.restorable.expect(const_1.Const.RecordType.Random);
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _makeId_decorators = [Leaf.bound()];
            _random_decorators = [Leaf.bound()];
            __esDecorate(_a, null, _makeId_decorators, { kind: "method", name: "makeId", static: false, private: false, access: { has: obj => "makeId" in obj, get: obj => obj.makeId }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _random_decorators, { kind: "method", name: "random", static: false, private: false, access: { has: obj => "random" in obj, get: obj => obj.random }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.UtilCapable = UtilCapable;
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/procedure/wait.js":
/*!************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/procedure/wait.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WaitAnyTimeoutCapable = exports.WaitOneTimeoutCapable = exports.WaitableBehavior = exports.WhatResult = void 0;
const const_1 = __webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/procedure/const.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/procedure/errors.js");
const fork_1 = __webpack_require__(/*! ./fork */ "./node_modules/@branch-ts/core/src/procedure/fork.js");
const runner_1 = __webpack_require__(/*! ./runner */ "./node_modules/@branch-ts/core/src/procedure/runner.js");
var WhatResult;
(function (WhatResult) {
    function from(data) {
        const arr = [data.what, data.result];
        const result = {
            what: data.what,
            result: data.result,
        };
        result[Symbol.iterator] = arr[Symbol.iterator].bind(arr);
        return result;
    }
    WhatResult.from = from;
})(WhatResult || (exports.WhatResult = WhatResult = {}));
let WaitableBehavior = (() => {
    var _a, _WaitableBehavior_rev, _WaitableBehavior_waits;
    let _instanceExtraInitializers = [];
    let _guard_decorators;
    let _wait_decorators;
    let _waitAny_decorators;
    let _waitAll_decorators;
    let _feed_decorators;
    return _a = class WaitableBehavior {
            constructor(runner) {
                this.runner = (__runInitializers(this, _instanceExtraInitializers), runner);
                _WaitableBehavior_rev.set(this, 0);
                this.forkable = new fork_1.ForkableBehavior(this.runner);
                _WaitableBehavior_waits.set(this, {});
            }
            get commitable() {
                return this.runner.commitable;
            }
            get restorable() {
                return this.runner.restorable;
            }
            get interruptable() {
                return this.runner.interruptable;
            }
            get journalable() {
                return this.runner.journalable;
            }
            get timeable() {
                return this.runner.timeable;
            }
            get isWaiting() {
                var _b;
                for (let name in __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")) {
                    if ((_b = __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name]) === null || _b === void 0 ? void 0 : _b.notify) {
                        return true;
                    }
                }
                return false;
            }
            get rev() {
                return __classPrivateFieldGet(this, _WaitableBehavior_rev, "f");
            }
            clear() {
                var _b;
                __classPrivateFieldSet(this, _WaitableBehavior_rev, __classPrivateFieldGet(this, _WaitableBehavior_rev, "f") + 1, "f");
                // No body can call the callbacks of previous signals and all
                for (let name in __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")) {
                    // Only clear empty wait
                    if ((_b = __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name]) === null || _b === void 0 ? void 0 : _b.notify) {
                        __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name].notify = null;
                    }
                }
            }
            dropPendingData() {
                for (let name in __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")) {
                    if (__classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name]) {
                        __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name].queue = [];
                    }
                }
            }
            guard() {
                if (this.isWaiting) {
                    throw new errors_1.Errors.AbuseError("Parralel wait is impossible please check your code");
                }
            }
            wait(name) {
                this.runner.debug(`Wait ${name.toString()}`);
                this.journalable.guard();
                this.guard();
                if (this.isWaiting) {
                    throw new errors_1.Errors.AbuseError("Parralel wait is impossible please check your code");
                }
                let promise;
                if (this.runner.state == "restoring") {
                    promise = this.waitRestore(name);
                }
                else if (this.runner.state == "running") {
                    promise = this.waitRunning(name);
                }
                if (promise) {
                    const waitable = new WaitOneTimeoutCapable(this, name, promise);
                    return promise;
                }
                throw new errors_1.Errors.AbuseError("Wait out side retoring/running state");
            }
            waitAny(...names) {
                this.runner.debug(`WaitAny ${names.join(",")}`);
                this.journalable.guard();
                this.guard();
                let promise;
                if (this.runner.state == "restoring") {
                    promise = this.waitAnyRestore(...names);
                }
                else if (this.runner.state == "running") {
                    promise = this.waitAnyRunning(...names);
                }
                if (promise) {
                    const waitable = new WaitAnyTimeoutCapable(this, promise);
                    return promise;
                }
                throw new errors_1.Errors.AbuseError("WaitAny out side retoring/running state");
            }
            waitAll(...names) {
                return __awaiter(this, void 0, void 0, function* () {
                    this.runner.debug(`WaitAll ${names.join(",")}`);
                    this.journalable.guard();
                    this.guard();
                    if (this.runner.state == "restoring") {
                        return yield this.waitAllRestore(...names);
                    }
                    else if (this.runner.state == "running") {
                        return yield this.waitAllRunning(...names);
                    }
                    throw new errors_1.Errors.AbuseError("WaitAll out side retoring/running state");
                });
            }
            waitRestore(name) {
                return __awaiter(this, void 0, void 0, function* () {
                    const wait = yield this.restorable.expect(const_1.Const.RecordType.Wait);
                    if (wait.name !== name) {
                        throw new errors_1.Errors.ConflictError(`Wait for ${name.toString()} but got ${wait.name.toString()} `);
                    }
                    this.timeable.syncJournableTime(wait.time);
                    this.clear();
                    yield this.interruptable.checkpoint();
                    return wait.data;
                });
            }
            waitAnyRestore(...names) {
                return __awaiter(this, void 0, void 0, function* () {
                    const waitAny = yield this.restorable.expect(const_1.Const.RecordType.WaitAny);
                    if (names.includes(waitAny.name) == false) {
                        throw new errors_1.Errors.ConflictError(`WaitAny expect ${names.toString()} but got ${waitAny.name.toString()}`);
                    }
                    this.timeable.syncJournableTime(waitAny.time);
                    this.clear();
                    yield this.interruptable.checkpoint();
                    return WhatResult.from({
                        what: waitAny.name,
                        result: waitAny.data
                    });
                });
            }
            waitAllRestore(...names) {
                return __awaiter(this, void 0, void 0, function* () {
                    const waitAll = yield this.restorable.expect(const_1.Const.RecordType.WaitAll);
                    const getNames = Object.keys(waitAll.result);
                    if (getNames.length !== names.length) {
                        throw new errors_1.Errors.ConflictError(`WaitAll mismatch ${names.toString()} but got ${getNames.toString()}`);
                    }
                    const diff = Leaf.Util.arrayDiff(getNames, names);
                    if (diff.intersect.length !== names.length) {
                        throw new errors_1.Errors.ConflictError(`WaitAll mismatch ${names.toString()} but got ${getNames.toString()}`);
                    }
                    this.timeable.syncJournableTime(waitAll.time);
                    this.clear();
                    yield this.interruptable.checkpoint();
                    return waitAll.result;
                });
            }
            waitRunning(name) {
                return __awaiter(this, void 0, void 0, function* () {
                    runner_1.ProcedureRunner.runImmeidate(() => __awaiter(this, void 0, void 0, function* () {
                        this.runner.events.emit("wait", [name.toString()]);
                    }));
                    const value = runner_1.ProcedureRunner.purify(yield this.waitSignal(name, __classPrivateFieldGet(this, _WaitableBehavior_rev, "f")));
                    this.clear();
                    const time = this.timeable.syncJournableTime(Date.now());
                    this.commitable.add(const_1.Const.RecordType.Wait, {
                        name: name.toString(),
                        data: runner_1.ProcedureRunner.purify(value),
                        time,
                    });
                    yield this.commitable.commit();
                    yield this.interruptable.checkpoint();
                    return value;
                });
            }
            waitAnyRunning(...names) {
                return __awaiter(this, void 0, void 0, function* () {
                    const maybe = this.forkable.maybe();
                    for (let name of names) {
                        maybe.consider(name.toString(), this.waitSignal.bind(this, name, __classPrivateFieldGet(this, _WaitableBehavior_rev, "f")));
                    }
                    runner_1.ProcedureRunner.runImmeidate(() => __awaiter(this, void 0, void 0, function* () {
                        this.runner.events.emit("wait", names);
                    }));
                    const [what, result] = yield maybe;
                    this.clear();
                    const time = this.timeable.syncJournableTime(Date.now());
                    this.commitable.add(const_1.Const.RecordType.WaitAny, {
                        name: what,
                        data: runner_1.ProcedureRunner.purify(result),
                        time
                    });
                    yield this.commitable.commit();
                    yield this.interruptable.checkpoint();
                    return WhatResult.from({ what, result });
                });
            }
            waitAllRunning(...names) {
                return __awaiter(this, void 0, void 0, function* () {
                    const all = this.forkable.all();
                    for (let name of names) {
                        all.consider(name.toString(), this.waitSignal.bind(this, name, __classPrivateFieldGet(this, _WaitableBehavior_rev, "f")));
                    }
                    runner_1.ProcedureRunner.runImmeidate(() => __awaiter(this, void 0, void 0, function* () {
                        this.runner.events.emit("wait", names);
                    }));
                    const result = runner_1.ProcedureRunner.purify(yield all);
                    const time = this.timeable.syncJournableTime(Date.now());
                    this.commitable.add(const_1.Const.RecordType.WaitAll, {
                        data: runner_1.ProcedureRunner.purify(result),
                        time,
                    });
                    yield this.commitable.commit();
                    yield this.interruptable.checkpoint();
                    this.clear();
                    return result;
                });
            }
            waitSignal(name, rev) {
                var _b;
                return __awaiter(this, void 0, void 0, function* () {
                    if (rev !== __classPrivateFieldGet(this, _WaitableBehavior_rev, "f"))
                        yield this.never();
                    if ((_b = __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name]) === null || _b === void 0 ? void 0 : _b.notify) {
                        throw new errors_1.Errors.AbuseError(`Duplicated wait for ${name.toString()}`);
                    }
                    if (__classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name]) {
                        const fed = __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name];
                        if (fed.queue.length > 0) {
                            return fed.queue.shift();
                        }
                    }
                    const _callback = Leaf.SharedCallbacks.create();
                    let returnned = false;
                    const callback = (err, result) => __awaiter(this, void 0, void 0, function* () {
                        if (returnned)
                            return;
                        returnned = true;
                        _callback(null, result);
                    });
                    const info = __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name] = {
                        queue: [],
                        notify: callback
                    };
                    const promise = _callback.promise();
                    return yield promise;
                });
            }
            never() {
                return __awaiter(this, void 0, void 0, function* () {
                    return yield new Promise(() => { });
                });
            }
            get waits() {
                return Object.keys(__classPrivateFieldGet(this, _WaitableBehavior_waits, "f"));
            }
            isWaitingFor(name) {
                var _b;
                return !!((_b = __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name]) === null || _b === void 0 ? void 0 : _b.notify);
            }
            // [Next]: There are multiple possible policy for feed/wait
            // We only hold at most one last value for each mark.
            // If multiple data is fed to the marks, the last one will be used. Previous is discarded.
            // May may allow user to define the exact behavior in future, possible behaviors maybe:
            // 1. Queue: hold all data, and return them in order, If no data then wait for it.
            // 2. Last: hold only the last data, and return it. If no data, wait for it.
            // 3. NowOrNull: sync return the queued data, if no data, return null.
            // We only support 2.Last behavior.
            feed(name, value) {
                var _b;
                if ((_b = __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name]) === null || _b === void 0 ? void 0 : _b.notify) {
                    const notify = __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name].notify;
                    __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name].notify = null;
                    notify(null, value);
                }
                else {
                    // no callback or no waits, we just overwrite the previous fed value.
                    const info = __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name] = __classPrivateFieldGet(this, _WaitableBehavior_waits, "f")[name] || {
                        queue: [],
                    };
                    info.queue.push(value);
                }
                return;
            }
        },
        _WaitableBehavior_rev = new WeakMap(),
        _WaitableBehavior_waits = new WeakMap(),
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _guard_decorators = [Leaf.bound()];
            _wait_decorators = [Leaf.bound()];
            _waitAny_decorators = [Leaf.bound()];
            _waitAll_decorators = [Leaf.bound()];
            _feed_decorators = [Leaf.bound()];
            __esDecorate(_a, null, _guard_decorators, { kind: "method", name: "guard", static: false, private: false, access: { has: obj => "guard" in obj, get: obj => obj.guard }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _wait_decorators, { kind: "method", name: "wait", static: false, private: false, access: { has: obj => "wait" in obj, get: obj => obj.wait }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _waitAny_decorators, { kind: "method", name: "waitAny", static: false, private: false, access: { has: obj => "waitAny" in obj, get: obj => obj.waitAny }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _waitAll_decorators, { kind: "method", name: "waitAll", static: false, private: false, access: { has: obj => "waitAll" in obj, get: obj => obj.waitAll }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _feed_decorators, { kind: "method", name: "feed", static: false, private: false, access: { has: obj => "feed" in obj, get: obj => obj.feed }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.WaitableBehavior = WaitableBehavior;
let WaitOneTimeoutCapable = (() => {
    var _a, _WaitOneTimeoutCapable_timeoutTime, _WaitOneTimeoutCapable_timeoutValue;
    let _instanceExtraInitializers = [];
    let _timeout_decorators;
    let _deadline_decorators;
    return _a = class WaitOneTimeoutCapable {
            constructor(wait, name, timeoutable) {
                this.wait = (__runInitializers(this, _instanceExtraInitializers), wait);
                this.name = name;
                this.timeoutable = timeoutable;
                _WaitOneTimeoutCapable_timeoutTime.set(this, void 0);
                _WaitOneTimeoutCapable_timeoutValue.set(this, void 0);
                this.timeoutable["timeout"] = this.timeout;
                this.timeoutable["deadline"] = this.deadline;
            }
            timeout(time, value) {
                var _b;
                if (this.wait.runner.state !== "running")
                    return this.timeoutable;
                if (__classPrivateFieldGet(this, _WaitOneTimeoutCapable_timeoutTime, "f")) {
                    throw new errors_1.Errors.AbuseError("Timeout already set");
                }
                __classPrivateFieldSet(this, _WaitOneTimeoutCapable_timeoutTime, time, "f");
                __classPrivateFieldSet(this, _WaitOneTimeoutCapable_timeoutValue, value, "f");
                const deadline = this.wait.timeable.journableTime + time;
                const interval = Math.max(deadline - Date.now(), 0);
                const rev = this.wait.rev;
                const timer = setTimeout(() => {
                    if (rev == this.wait.rev) {
                        this.wait.feed(this.name, __classPrivateFieldGet(this, _WaitOneTimeoutCapable_timeoutValue, "f"));
                    }
                }, interval);
                (_b = timer === null || timer === void 0 ? void 0 : timer.unref) === null || _b === void 0 ? void 0 : _b.call(timer);
                return this.timeoutable;
            }
            deadline(time, value) {
                return this.timeout(Math.max(0, time - this.wait.timeable.journableTime), value);
            }
        },
        _WaitOneTimeoutCapable_timeoutTime = new WeakMap(),
        _WaitOneTimeoutCapable_timeoutValue = new WeakMap(),
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _timeout_decorators = [Leaf.bound()];
            _deadline_decorators = [Leaf.bound()];
            __esDecorate(_a, null, _timeout_decorators, { kind: "method", name: "timeout", static: false, private: false, access: { has: obj => "timeout" in obj, get: obj => obj.timeout }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _deadline_decorators, { kind: "method", name: "deadline", static: false, private: false, access: { has: obj => "deadline" in obj, get: obj => obj.deadline }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.WaitOneTimeoutCapable = WaitOneTimeoutCapable;
let WaitAnyTimeoutCapable = (() => {
    var _a, _WaitAnyTimeoutCapable_timeoutTime, _WaitAnyTimeoutCapable_timeoutValue;
    let _instanceExtraInitializers = [];
    let _timeout_decorators;
    let _deadline_decorators;
    return _a = class WaitAnyTimeoutCapable {
            constructor(wait, timeoutable) {
                this.wait = (__runInitializers(this, _instanceExtraInitializers), wait);
                this.timeoutable = timeoutable;
                _WaitAnyTimeoutCapable_timeoutTime.set(this, void 0);
                _WaitAnyTimeoutCapable_timeoutValue.set(this, void 0);
                this.timeoutable["timeout"] = this.timeout;
                this.timeoutable["deadline"] = this.deadline;
            }
            timeout(time, name, value) {
                var _b;
                if (this.wait.runner.state !== "running")
                    return this.timeoutable;
                if (__classPrivateFieldGet(this, _WaitAnyTimeoutCapable_timeoutTime, "f")) {
                    throw new errors_1.Errors.AbuseError("Timeout already set");
                }
                __classPrivateFieldSet(this, _WaitAnyTimeoutCapable_timeoutTime, time, "f");
                __classPrivateFieldSet(this, _WaitAnyTimeoutCapable_timeoutValue, value, "f");
                this.name = name || "timeout";
                const deadline = this.wait.timeable.journableTime + time;
                const interval = Math.max(deadline - Date.now(), 0);
                const rev = this.wait.rev;
                const timer = setTimeout(() => {
                    if (rev == this.wait.rev) {
                        this.wait.feed(this.name, __classPrivateFieldGet(this, _WaitAnyTimeoutCapable_timeoutValue, "f"));
                    }
                }, interval);
                (_b = timer === null || timer === void 0 ? void 0 : timer.unref) === null || _b === void 0 ? void 0 : _b.call(timer);
                return this.timeoutable;
            }
            deadline(time, name, value) {
                return this.timeout(Math.max(0, time - this.wait.timeable.journableTime), name, value);
            }
        },
        _WaitAnyTimeoutCapable_timeoutTime = new WeakMap(),
        _WaitAnyTimeoutCapable_timeoutValue = new WeakMap(),
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _timeout_decorators = [Leaf.bound()];
            _deadline_decorators = [Leaf.bound()];
            __esDecorate(_a, null, _timeout_decorators, { kind: "method", name: "timeout", static: false, private: false, access: { has: obj => "timeout" in obj, get: obj => obj.timeout }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _deadline_decorators, { kind: "method", name: "deadline", static: false, private: false, access: { has: obj => "deadline" in obj, get: obj => obj.deadline }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.WaitAnyTimeoutCapable = WaitAnyTimeoutCapable;
//# sourceMappingURL=wait.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/repository.js":
/*!********************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/repository.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SavableInMemoryRepositoryProvider = exports.SavableInMemoryRepository = exports.InMemoryRepositoryProvider = exports.InMemoryRepository = exports.ArrayRepository = exports.DummyRepository = exports.RepositoryProvider = exports.Repository = exports.RepositoryManager = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const criteria_1 = __webpack_require__(/*! @root-ts/criteria */ "./node_modules/@root-ts/criteria/index.js");
const namespace_1 = __webpack_require__(/*! ./namespace */ "./node_modules/@branch-ts/core/src/namespace.js");
const Const = __importStar(__webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/const.js"));
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
const keeper_1 = __webpack_require__(/*! ./keeper */ "./node_modules/@branch-ts/core/src/keeper.js");
const util_1 = __webpack_require__(/*! ./util */ "./node_modules/@branch-ts/core/src/util.js");
const log_1 = __webpack_require__(/*! ./log */ "./node_modules/@branch-ts/core/src/log.js");
const typeSystem_1 = __webpack_require__(/*! ./typeSystem */ "./node_modules/@branch-ts/core/src/typeSystem.js");
let RepositoryManager = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _getModelRepository_decorators;
    return _a = class RepositoryManager {
            constructor(domain) {
                this.domain = (__runInitializers(this, _instanceExtraInitializers), domain);
                this.modelRepositories = {};
                this.delegatedRepositories = {};
                this.repositoryProviders = {};
                this.lock = new Leaf.Lock();
            }
            initialize() {
                return __awaiter(this, void 0, void 0, function* () {
                });
            }
            getModelRepository(model) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (model.abstract)
                        return null;
                    if (this.delegatedRepositories[model.uniqueName])
                        return this.delegatedRepositories[model.uniqueName];
                    if (this.modelRepositories[model.uniqueName])
                        return this.modelRepositories[model.uniqueName];
                    const repo = yield this.createModelRepository(model);
                    this.modelRepositories[model.uniqueName] = repo;
                    log_1.Logger.info(`${model.uniqueName} repository created using ${repo.constructor.name}`);
                    const keeperDescriptor = this.domain.findAspect("keeper", {
                        model: model.uniqueName
                    });
                    if (!repo && !keeperDescriptor) {
                        throw new errors_1.Errors.DesignError(`No repository for ${model.uniqueName} available`);
                    }
                    if (keeperDescriptor) {
                        const delegator = new keeper_1.DelegatedRepository({
                            domain: this.domain,
                            model,
                            backer: repo,
                            loadCondition: keeperDescriptor.loadCondition,
                            keeper: keeperDescriptor.cons
                        });
                        this.delegatedRepositories[model.uniqueName] = delegator;
                        yield delegator.initialize();
                        return delegator;
                    }
                    return repo;
                });
            }
            createModelRepository(model) {
                return __awaiter(this, void 0, void 0, function* () {
                    yield this.lock.lock();
                    try {
                        const descs = this.domain.findAspects("repository");
                        const candidates = descs.filter(desc => {
                            return desc.for.some(matcher => {
                                return namespace_1.Namespace.match({
                                    matcher,
                                    name: model.uniqueName,
                                });
                            });
                        });
                        const exacts = candidates.filter(cand => {
                            return cand.for.some(matcher => matcher === model.uniqueName);
                        });
                        if (exacts.length > 1) {
                            throw new errors_1.Errors.DesignError(`Multiple repository provider exactly match the for statement of ${model.uniqueName}`);
                        }
                        exacts.sort((a, b) => b.priority - a.priority);
                        candidates.sort((a, b) => {
                            return b.priority - a.priority;
                        });
                        let todos;
                        if (exacts.length > 0)
                            todos = exacts;
                        else
                            todos = candidates;
                        for (let desc of todos) {
                            const repo = yield this.createRepositoryFromDescriptor({
                                descriptor: desc,
                                model,
                            });
                            yield repo.initialize();
                            return repo;
                        }
                        return null;
                    }
                    catch (e) {
                        throw e;
                    }
                    finally {
                        this.lock.release();
                    }
                });
            }
            createRepositoryFromDescriptor(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (!this.lock.isLock())
                        throw new errors_1.Errors.LogicError("Creating repository should during lock");
                    if (!option.descriptor.cons) {
                        log_1.Logger.error(option.descriptor);
                        throw new errors_1.Errors.RuntimeError(`Repository ${option.descriptor.uniqueName} constructor not available, code may not be included`);
                    }
                    if (util_1.Util.isConstructorOfBase(option.descriptor.cons, Repository)) {
                        const repository = new option.descriptor.cons({
                            domain: this.domain,
                            model: option.model,
                        });
                        return repository;
                    }
                    else if (util_1.Util.isConstructorOfBase(option.descriptor.cons, RepositoryProvider)) {
                        const provider = yield this.ensureRepositoryProvider(option);
                        const repository = provider.provide({
                            model: option.model
                        });
                        return repository;
                    }
                    else {
                        throw new errors_1.Errors.DesignError(`Invalid @repository ${option.descriptor.uniqueName}: repository need to be instanceof Repository or RepositoryProvider`);
                    }
                });
            }
            ensureRepositoryProvider(option) {
                return __awaiter(this, void 0, void 0, function* () {
                    const uniqueName = option.descriptor.uniqueName;
                    if (this.repositoryProviders[uniqueName])
                        return this.repositoryProviders[uniqueName];
                    const provider = this.repositoryProviders[uniqueName] = new option.descriptor.cons({
                        domain: this.domain
                    });
                    yield provider.initialize();
                    return provider;
                });
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _getModelRepository_decorators = [Leaf.lock("getRepository")];
            __esDecorate(_a, null, _getModelRepository_decorators, { kind: "method", name: "getModelRepository", static: false, private: false, access: { has: obj => "getModelRepository" in obj, get: obj => obj.getModelRepository }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.RepositoryManager = RepositoryManager;
class Repository {
    constructor(option) {
        this.option = option;
        this.model = this.option.model;
        this.domain = this.option.domain;
        this.ready = new Leaf.ReadyBehavior();
    }
}
exports.Repository = Repository;
class RepositoryProvider {
    constructor(option) {
        this.option = option;
        this.default = false;
        this.domain = this.option.domain;
        this.name = this.constructor.name;
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
}
exports.RepositoryProvider = RepositoryProvider;
class DummyRepository extends Repository {
    success(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                modifiedCount: null,
                duration: null,
                result: data
            };
        });
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.ready.yes();
        });
    }
    one(option) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("not implemented");
        });
    }
    some(option) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("not implemented");
        });
    }
    // always remove on only
    remove(option) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("not implemented");
        });
    }
    count(option) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("not implemented");
        });
    }
    inserts(option) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("not implemented");
        });
    }
    update(option) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("not implemented");
        });
    }
    all(option) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("not implemented");
        });
    }
}
exports.DummyRepository = DummyRepository;
class ArrayRepository extends DummyRepository {
    constructor(option) {
        super(option);
        this.option = option;
        this.model = this.option.model;
        this.domain = this.option.domain;
        this.uniqueFields = this.model.fields.filter(item => item.unique);
    }
    get items() {
        return this.option.items;
    }
    success(data, modifiedCount = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                modifiedCount: modifiedCount,
                duration: null,
                result: data
            };
        });
    }
    one(option) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!option.condition) {
                const result = this.items[0];
                return this.success(result);
            }
            if (option.condition.ors.length == 0) {
                return this.success(null);
            }
            for (let item of this.items) {
                if (criteria_1.Criteria.test(option.condition, item)) {
                    return this.success(item);
                }
            }
            return this.success(null);
        });
    }
    some(option) {
        return __awaiter(this, void 0, void 0, function* () {
            let left = option.count || null;
            let toSkip = option.offset || 0;
            let results = [];
            for (let item of this.items) {
                if (left === 0) {
                    break;
                }
                const match = criteria_1.Criteria.test(option.condition, item);
                if (match) {
                    if (toSkip > 0) {
                        toSkip -= 1;
                        continue;
                    }
                    if (left !== null)
                        left -= 1;
                    results.push(item);
                }
            }
            if (option.sort) {
                this.sort({
                    sort: option.sort,
                    results
                });
            }
            return this.success(results);
        });
    }
    sort(option) {
        const results = option.results;
        /* c8 ignore start */
        if (option.sort) {
            results.sort((a, b) => {
                for (let key in option.sort) {
                    let cmp = 0;
                    let sort = option.sort[key] || 1;
                    if (a[key] > b[key]) {
                        cmp = 1;
                    }
                    else if (a[key] < b[key]) {
                        cmp = -1;
                    }
                    cmp = cmp * sort;
                    if (cmp !== 0)
                        return cmp;
                }
                return 0;
            });
        }
        /* c8 ignore stop */
        return results;
    }
    all(option = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            option = option || {};
            let results = this.items.slice();
            if (option.condition) {
                results = results.filter(item => {
                    return criteria_1.Criteria.test(option.condition, item);
                });
            }
            if (option.sort) {
                this.sort({
                    sort: option.sort,
                    results
                });
            }
            if (option.offset > 0) {
                results = results.slice(option.offset);
            }
            if (option.count > 0) {
                results = results.slice(0, option.count);
            }
            return this.success(results);
        });
    }
}
exports.ArrayRepository = ArrayRepository;
class InMemoryRepository extends Repository {
    constructor(option) {
        super(option);
        this.option = option;
        this.model = this.option.model;
        this.domain = this.option.domain;
        this.uniqueFields = this.model.fields.filter(item => item.unique);
        this.data = {};
        this.defaultCount = Const.DefaultGroupSomeCount;
        this.ensureData();
        if (option.data) {
            this.load(option.data);
        }
        this.ready.yes();
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    ensureData() {
        if (!this.data)
            this.data = {};
        if (!this.data.items)
            this.data.items = [];
    }
    success(data, modifiedCount = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                modifiedCount: modifiedCount,
                duration: null,
                result: data
            };
        });
    }
    load(data) {
        this.data = data;
        this.ensureData();
    }
    addDocumentsWithoutCheck(datas) {
        this.ensureData();
        this.data.items.push(...datas);
    }
    toJSON() {
        return this.data;
    }
    one(option) {
        return __awaiter(this, void 0, void 0, function* () {
            this.ensureData();
            if (!option.condition) {
                const result = this.data.items[0];
                return this.success(result);
            }
            if (option.condition.ors.length == 0) {
                return this.success(null);
            }
            for (let item of this.data.items) {
                if (criteria_1.Criteria.test(option.condition, item)) {
                    return this.success(item);
                }
            }
            return this.success(null);
        });
    }
    some(option) {
        return __awaiter(this, void 0, void 0, function* () {
            this.ensureData();
            let left = option.count || null;
            let toSkip = option.offset || 0;
            let results = [];
            for (let item of this.data.items) {
                if (left === 0) {
                    break;
                }
                const match = criteria_1.Criteria.test(option.condition, item);
                if (match) {
                    if (toSkip > 0) {
                        toSkip -= 1;
                        continue;
                    }
                    if (left !== null)
                        left -= 1;
                    results.push(item);
                }
            }
            if (option.sort) {
                this.sort({
                    sort: option.sort,
                    results
                });
            }
            return this.success(results);
        });
    }
    sort(option) {
        const results = option.results;
        /* c8 ignore start */
        if (option.sort) {
            results.sort((a, b) => {
                for (let key in option.sort) {
                    let cmp = 0;
                    let sort = option.sort[key] || 1;
                    if (a[key] > b[key]) {
                        cmp = 1;
                    }
                    else if (a[key] < b[key]) {
                        cmp = -1;
                    }
                    cmp = cmp * sort;
                    if (cmp !== 0)
                        return cmp;
                }
                return 0;
            });
        }
        /* c8 ignore stop */
        return results;
    }
    remove(option) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < this.data.items.length; i++) {
                const item = this.data.items[i];
                if (criteria_1.Criteria.test(option.condition, item)) {
                    this.data.items.splice(i, 1);
                    return this.success(1, 1);
                }
            }
            return this.success(0);
        });
    }
    count(option) {
        return __awaiter(this, void 0, void 0, function* () {
            this.ensureData();
            if (!option || !option.condition) {
                return this.success(this.data.items.length);
            }
            let counter = 0;
            for (let item of this.data.items) {
                if (criteria_1.Criteria.test(option.condition, item)) {
                    counter += 1;
                }
            }
            return this.success(counter);
        });
    }
    increase(option) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let key in option.data) {
                const v = option.data[key];
                if (typeof v !== "number" || isNaN(v) || !isFinite(v)) {
                    throw new errors_1.Errors.InvalidParameters(`Invalid increase value ${v} for ${key}`);
                }
                const field = this.model.fields.find(item => item.key === key);
                const spec = typeSystem_1.GlobalTypeSystem.getSpec(field.type);
                if (!spec.isBasedOf("number")) {
                    throw new errors_1.Errors.RuntimeError(`Invalid increase value ${v} for ${key}: only number based field can be increased, we got ${spec.type}`);
                }
            }
            for (let item of this.data.items) {
                if (criteria_1.Criteria.test(option.condition, item)) {
                    const updates = Object.assign({}, item, option.data);
                    const result = this.checkIntegrity({
                        data: updates,
                        except: item
                    });
                    if (result.conflict) {
                        throw new errors_1.Errors.AlreadyExists(`${this.model.uniqueName} already exists: Conflict in key ${result.field.key}`);
                    }
                    for (let key in option.data) {
                        const v = option.data[key];
                        if (!item[key]) {
                            item[key] = v;
                        }
                        else {
                            item[key] = item[key] + v;
                        }
                    }
                }
            }
            return this.success(null, 1);
        });
    }
    inserts(option) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO check unique
            this.ensureData();
            const pushes = [];
            for (let data of option.datas) {
                const result = this.checkIntegrity({ data });
                if (result.conflict) {
                    throw new errors_1.Errors.AlreadyExists(`${this.model.uniqueName} already exists: Conflict in key ${result.field.key}: ${data[result.field.key]}`);
                }
                this.data.items.push(data);
                pushes.push(data);
            }
            return this.success(pushes, pushes.length);
        });
    }
    checkIntegrity(option) {
        for (let item of this.data.items) {
            for (let field of this.uniqueFields) {
                if (option.except === item)
                    continue;
                if (item[field.key] == option.data[field.key])
                    return {
                        conflict: true,
                        data: option.data,
                        field
                    };
            }
        }
        return {
            conflict: false
        };
    }
    update(option) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let item of this.data.items) {
                if (criteria_1.Criteria.test(option.condition, item)) {
                    const updates = Object.assign({}, item, option.data);
                    const result = this.checkIntegrity({
                        data: updates,
                        except: item
                    });
                    if (result.conflict) {
                        throw new errors_1.Errors.AlreadyExists(`${this.model.uniqueName} already exists: Conflict in key ${result.field.key}`);
                    }
                    Object.assign(item, option.data);
                }
            }
            return this.success(null, 1);
        });
    }
    /* c8 ignore start */
    all(option = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            option = option || {};
            let results = this.data.items.slice();
            if (option.condition) {
                results = results.filter(item => {
                    return criteria_1.Criteria.test(option.condition, item);
                });
            }
            if (option.sort) {
                this.sort({
                    sort: option.sort,
                    results
                });
            }
            if (option.offset > 0) {
                results = results.slice(option.offset);
            }
            if (option.count > 0) {
                results = results.slice(0, option.count);
            }
            return this.success(results);
        });
    }
}
exports.InMemoryRepository = InMemoryRepository;
/* c8 ignore start */
class InMemoryRepositoryProvider extends RepositoryProvider {
    getData(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return {};
        });
    }
    provide(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return new InMemoryRepository({
                data: yield this.getData(option),
                model: option.model,
                domain: this.domain
            });
        });
    }
}
exports.InMemoryRepositoryProvider = InMemoryRepositoryProvider;
class SavableInMemoryRepository extends InMemoryRepository {
    success(data, modifiedCount) {
        const _super = Object.create(null, {
            success: { get: () => super.success }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield this.save();
            return _super.success.call(this, data, modifiedCount);
        });
    }
}
exports.SavableInMemoryRepository = SavableInMemoryRepository;
class SavableInMemoryRepositoryProvider extends InMemoryRepositoryProvider {
    getData(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.load({
                descriptor: option.model,
            });
        });
    }
    provide(option) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            return new (class extends SavableInMemoryRepository {
                save() {
                    return __awaiter(this, void 0, void 0, function* () {
                        yield self.save({
                            descriptor: this.model,
                            data: this.data,
                        });
                    });
                }
            })({
                data: yield this.getData(option),
                model: option.model,
                domain: this.domain,
            });
        });
    }
}
exports.SavableInMemoryRepositoryProvider = SavableInMemoryRepositoryProvider;
/* c8 ignore stop */
//# sourceMappingURL=repository.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/resourceAction.js":
/*!************************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/resourceAction.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SafeResourceActionContext = exports.ResourceActionResult = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const criteria_1 = __webpack_require__(/*! @root-ts/criteria */ "./node_modules/@root-ts/criteria/index.js");
const aspect_field_1 = __webpack_require__(/*! ./design/aspect.field */ "./node_modules/@branch-ts/core/src/design/aspect.field.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
const textSearch_1 = __webpack_require__(/*! ./textSearch */ "./node_modules/@branch-ts/core/src/textSearch.js");
const Const = __importStar(__webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/const.js"));
const flow_1 = __webpack_require__(/*! ./codex/flow */ "./node_modules/@branch-ts/core/src/codex/flow.js");
const log_1 = __webpack_require__(/*! ./log */ "./node_modules/@branch-ts/core/src/log.js");
var ResourceActionResult;
(function (ResourceActionResult) {
    function fromRepositoryResponse(result) {
        return {
            result: result.result,
        };
    }
    ResourceActionResult.fromRepositoryResponse = fromRepositoryResponse;
})(ResourceActionResult || (exports.ResourceActionResult = ResourceActionResult = {}));
class SafeResourceActionContext {
    constructor(option) {
        this.option = option;
        this.domain = this.option.domain;
        this.codex = this.domain.codex;
        this.typeSystem = this.domain.codex.typeSystem;
        this.descriptor = this.option.descriptor;
        this.condition = this.descriptor.condition;
        this.executed = false;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.model = this.descriptor.model;
            this.fields = this.descriptor.fieldDescriptors;
            this.repository = yield this.domain.repositoryManager.getModelRepository(this.model);
            if (!this.repository) {
                throw new errors_1.Errors.RuntimeError(`${this.descriptor.model.uniqueName} repository not available`);
            }
            this.textSearch = new textSearch_1.TextSearchPolicy(this.fields);
            this.group = this.descriptor.group;
        });
    }
    isSupport(action) {
        const removables = ["remove", "removes"];
        if (this.model.irremovable && removables.indexOf(action) >= 0) {
            throw new errors_1.Errors.RuntimeError(`Immutable model can't apply action remove`);
        }
        return SafeResourceActionContext.types.indexOf(action) >= 0;
    }
    trigger(name, things) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.domain.hookManager.trigger(name, things);
        });
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.executed) {
                throw new errors_1.Errors.RuntimeError("Can't re-execute safe resource context");
            }
            this.executed = true;
            yield this.init();
            const actions = Object.keys(this.descriptor.action);
            const name = actions[0];
            if (!name) {
                throw new errors_1.Errors.RuntimeError(`Empty resource action`);
            }
            if (!this.isSupport(name)) {
                throw new errors_1.Errors.RuntimeError(`Invalid action name ${name}`);
            }
            const option = this.descriptor.action[name];
            const result = yield this[name](option);
            return result;
        });
    }
    count() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.repository.count({
                condition: this.condition
            });
            return ResourceActionResult.fromRepositoryResponse(res);
        });
    }
    all() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.repository.all({ condition: this.condition });
            res.result.forEach(doc => this.implementVirtualDataInPlace(doc));
            return ResourceActionResult.fromRepositoryResponse(res);
        });
    }
    query(option) {
        return __awaiter(this, void 0, void 0, function* () {
            option = option || {};
            let condition = criteria_1.Criteria.and(option.match, this.condition);
            condition = this.textSearch.applyTextSearchToCondition(option.text, condition);
            const sort = {};
            if (option.sort) {
                for (let key in option.sort) {
                    sort[key] = option.sort[key];
                }
            }
            const docs = yield this.repository.some(Object.assign(Object.assign({}, option), { sort, count: option.count || Const.DefaultGroupSomeCount, condition }));
            docs.result.forEach(doc => this.implementVirtualDataInPlace(doc));
            return ResourceActionResult.fromRepositoryResponse(docs);
        });
    }
    some(option) {
        return __awaiter(this, void 0, void 0, function* () {
            option = option || {};
            let condition = this.textSearch.applyTextSearchToCondition(option.text, this.condition);
            const sort = {};
            if (option.sort) {
                for (let key in option.sort) {
                    sort[key] = option.sort[key];
                }
            }
            const res = yield this.repository.some(Object.assign(Object.assign({}, option), { sort, count: option.count || Const.DefaultGroupSomeCount, condition }));
            res.result.forEach(doc => this.implementVirtualDataInPlace(doc));
            return ResourceActionResult.fromRepositoryResponse(res);
        });
    }
    get(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const quickMatchKeys = Object.keys(option).filter(item => item[0] !== "_").filter(key => typeof option[key] !== "undefined");
            let res;
            if (quickMatchKeys.length == 0) {
                res = yield this.repository.one({ condition: this.condition });
            }
            else {
                const criteria = new criteria_1.CriteriaBuilder();
                for (let key of quickMatchKeys) {
                    criteria.path(key).eq(option[key]);
                }
                const condition = this.condition && criteria_1.Criteria.and(criteria.build(), this.condition) || criteria.build();
                res = yield this.repository.one({ condition: condition });
            }
            this.implementVirtualDataInPlace(res.result);
            return ResourceActionResult.fromRepositoryResponse(res);
        });
    }
    implementVirtualDataInPlace(data) {
        if (!data)
            return data;
        if (!this.fields.some(item => item.availability === "virtual"))
            return data;
        const model = this.model;
        for (let key of model.fieldInitOrders) {
            const field = this.fields.find(item => item.key === key);
            if (field.availability !== "virtual") {
                continue;
            }
            if (!field.generate)
                continue;
            if (typeof field.generate !== "function")
                continue;
            const fn = field.generate;
            data[field.key] = fn.call(data);
        }
        return data;
    }
    update(option) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!option.data)
                return;
            if (!option.id) {
                throw new errors_1.Errors.InvalidParameters(`${this.model.uniqueName} missing id when updating`);
            }
            let flow = new flow_1.Flow(this.domain, this.model, Object.assign(Object.assign({}, this.domain.environment), { session: this.descriptor.session }));
            const origRes = yield this.get({ id: option.id });
            if (!origRes.result) {
                throw new errors_1.Errors.NotFound(`Update can't find original ${option.id}`);
            }
            const orig = origRes.result;
            const evalResult = yield flow.eval({
                input: option.data,
                original: orig,
                procedure: "update",
                locale: this.descriptor.locale || "en",
                textSearch: this.textSearch,
            });
            // Update item of id
            const idEqual = new criteria_1.CriteriaBuilder().path("id").eq(option.id).build();
            const condition = this.condition && criteria_1.Criteria.and(idEqual, this.condition) || idEqual;
            //const updated = Object.assign({}, info.full, info.diffWithSearchIndexes)
            yield this.checkDocumentPersistentTypeSpec({
                model: this.model,
                data: evalResult.data,
            });
            const onBeforeUpdateHookOption = {
                original: evalResult.original,
                data: evalResult.data,
                phase: "onBeforeUpdate",
                diff: evalResult.changed,
                session: this.descriptor.session,
            };
            yield this.trigger(this.model.uniqueName, onBeforeUpdateHookOption);
            let finalUpdates = Object.assign({}, evalResult.changed, evalResult.searchIndexes);
            for (let field of this.fields) {
                if (field.immutable && field.key in finalUpdates) {
                    if (Leaf.Util.isEmptyValue(finalUpdates[field.key])) {
                        delete finalUpdates[field.key];
                        continue;
                    }
                    if (field.key in evalResult.initialized) {
                        continue;
                    }
                    if (!Leaf.Util.isEmptyValue(option.data[field.key])) {
                        log_1.Logger.error(evalResult);
                        throw new errors_1.Errors.DesignError(`Updating immutable key ${field.uniqueName}: ${evalResult.initialized[field.key]}`);
                    }
                    delete finalUpdates[field.key];
                }
            }
            if (Object.keys(finalUpdates).length == 0) {
                return;
            }
            yield this.repository.update({
                condition,
                data: finalUpdates,
            });
            const onUpdateHookOption = {
                original: evalResult.original,
                data: evalResult.data,
                phase: "onUpdate",
                diff: finalUpdates,
                session: this.descriptor.session,
            };
            yield this.trigger(this.model.uniqueName, onUpdateHookOption);
            return;
        });
    }
    updateByMatch(option) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Temperory disabled");
        });
    }
    updates(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const updates = Promise.all(Object.keys(option.datas).map((id) => __awaiter(this, void 0, void 0, function* () {
                const data = option.datas[id];
                return yield this.update({
                    id,
                    data,
                });
            })));
            return;
        });
    }
    remove(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const idEqual = new criteria_1.CriteriaBuilder().path("id").eq(option.id).build();
            const condition = this.condition && criteria_1.Criteria.and(idEqual, this.condition) || idEqual;
            const itemRes = yield this.get({ id: option.id });
            if (!itemRes.result)
                return;
            let item;
            const self = this;
            const genItem = () => {
                if (item)
                    return item;
                item = itemRes.result;
                for (let field of self.fields) {
                    if (field.availability == "virtual") {
                        Object.defineProperty(item, field.key, {
                            get: field.generate,
                            enumerable: false,
                        });
                    }
                }
                return item;
            };
            const onBeforeRemoveHookOption = {
                get original() {
                    return genItem();
                },
                get data() {
                    return genItem();
                },
                phase: "onBeforeRemove",
                diff: {},
                session: this.descriptor.session,
            };
            yield this.trigger(this.model.uniqueName, onBeforeRemoveHookOption);
            yield this.repository.remove({ condition });
            const onRemoveHookOption = {
                get original() {
                    return genItem();
                },
                get data() {
                    return genItem();
                },
                phase: "onRemove",
                diff: {},
                session: this.descriptor.session,
            };
            yield this.trigger(this.model.uniqueName, onRemoveHookOption);
        });
    }
    removes(option) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let id of option.ids) {
                yield this.remove({ id });
            }
            return;
        });
    }
    create(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const flow = new flow_1.Flow(this.domain, this.model, Object.assign(Object.assign({}, this.domain.environment), { session: this.descriptor.session }));
            const evalResult = yield flow.eval({
                input: option.data,
                original: {},
                procedure: "create",
                locale: this.descriptor.locale,
            });
            const data = evalResult.data;
            const onBeforeCreateHookOption = {
                original: null,
                data,
                phase: "onBeforeCreate",
                diff: data,
                session: this.descriptor.session,
            };
            yield this.checkDocumentPersistentTypeSpec({
                model: this.model,
                data,
            });
            yield this.trigger(this.model.uniqueName, onBeforeCreateHookOption);
            if (this.condition) {
                if (!criteria_1.Criteria.test(this.condition, onBeforeCreateHookOption.data)) {
                    throw new errors_1.Errors.ConditionError(`Create condition mismatch in group ${this.group.uniqueName}`);
                }
            }
            const caches = this.textSearch.getSearchIndexCache(onBeforeCreateHookOption.data);
            const dataWithSearch = Object.assign(onBeforeCreateHookOption.data, caches);
            const insertResult = yield this.repository.inserts({ datas: [dataWithSearch] });
            if (insertResult.modifiedCount !== 1) {
                throw new errors_1.Errors.AlreadyExists();
            }
            const onCreateHookOption = {
                original: null,
                data: onBeforeCreateHookOption.data,
                phase: "onCreate",
                diff: data,
                session: this.descriptor.session,
            };
            yield this.trigger(this.model.uniqueName, onCreateHookOption);
            return { result: insertResult.result[0] };
        });
    }
    creates(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const datas = [];
            for (let value of option.datas) {
                const flow = new flow_1.Flow(this.domain, this.model, Object.assign(Object.assign({}, this.domain.environment), { session: this.descriptor.session }));
                const evalResult = yield flow.eval({
                    input: value,
                    procedure: "create",
                    original: {},
                    locale: this.descriptor.locale
                });
                const data = evalResult.data;
                yield this.checkDocumentPersistentTypeSpec({
                    model: this.model,
                    data
                });
                const onBeforeCreateHookOption = {
                    original: null,
                    data,
                    phase: "onBeforeCreate",
                    diff: data,
                    session: this.descriptor.session,
                };
                yield this.trigger(this.model.uniqueName, onBeforeCreateHookOption);
                if (this.condition) {
                    if (!criteria_1.Criteria.test(this.condition, onBeforeCreateHookOption.data)) {
                        throw new errors_1.Errors.ConditionError(`Create condition mismatch in group ${this.group.uniqueName}`);
                    }
                }
                datas.push(onBeforeCreateHookOption.data);
            }
            const insertsResult = yield this.repository.inserts({ datas });
            for (let data of insertsResult.result) {
                const onCreateHookOption = {
                    original: null,
                    data,
                    phase: "onCreate",
                    diff: data,
                    session: this.descriptor.session,
                };
                yield this.trigger(this.model.uniqueName, onCreateHookOption);
            }
            return {
                result: insertsResult.result
            };
        });
    }
    // For now we have 2 kind of check:
    // 1. integrity, chcekc the documents as whole, to see if it's valid and fit all constrains.
    // 2. write permission, check the updated part to see if user have the write to write.
    // 3. read striping, remove protected fields when reading.
    checkDocumentIntegrity(option) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkDocumentPersistentTypeSpec({
                model: this.model,
                data: option.data
            });
        });
    }
    checkDocumentWritePermission(option) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    checkDocumentPersistentTypeSpec(option) {
        // 1. do type check
        // 2. do required check
        const model = option.model;
        const fields = option.fields || model.fields;
        for (let field of fields) {
            // We only check solid field
            if (!aspect_field_1.FieldSpecification.PersistentAvailabilities.includes(field.availability)) {
                continue;
            }
            if (field.type == "enum") {
                if (field.optional && Leaf.Util.isEmptyValue(option.data[field.key]))
                    continue;
                const enums = field.enums || {};
                const values = Object.keys(enums).map(key => enums[key]);
                if (values.length > 0 && !values.includes(option.data[field.key])) {
                    throw new errors_1.Errors.IntegrityError(`${model.uniqueName}.${field.key} provided value is not valid in enum definition`);
                }
                continue;
            }
            let spec = this.typeSystem.getStrictType(field.type);
            if (!spec && field.type !== "any" && field.type !== "unknown") {
                log_1.Logger.warn("Checking field", field.uniqueName, "with implicity type", field.type);
                log_1.Logger.warn("This may not be the expected behavior, please check your definition");
                throw new errors_1.Errors.DesignError(`Unknown type for ${field.uniqueName}: ${field.type}`);
            }
            if (!spec) {
                spec = this.typeSystem.getSpec(field.type);
            }
            const isUninitialized = spec.isUninitialized(option.data[field.key]);
            if (isUninitialized) {
                if (!field.optional) {
                    throw new errors_1.Errors.IntegrityError(`${model.uniqueName}.${field.key} is required but uninitialized: ${option.data[field.key]}`);
                }
                else {
                    continue;
                }
            }
            if (field.optional && Leaf.Util.isEmptyValue(option.data[field.key])) {
                continue;
            }
            if (!spec.isSettableValue(option.data[field.key])) {
                throw new errors_1.Errors.IntegrityError(`${model.uniqueName}.${field.key} provided value is not settable for ${spec.type}: ${option.data[field.key]}`);
            }
        }
    }
}
exports.SafeResourceActionContext = SafeResourceActionContext;
SafeResourceActionContext.types = [
    "count", "all", "query", "some", "get", "update", "updates", "updateByMatch", "remove", "removes", "create", "creates"
];
SafeResourceActionContext.kinds = {
    read: ["count", "all", "query", "some", "get"],
    write: ["update", "updates", "updateByMatch"],
    create: ["create", "creates"],
    delete: ["remove", "removes"]
};
//# sourceMappingURL=resourceAction.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/rpc.js":
/*!*************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/rpc.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _RpcRegistry_descriptors, _ProjectionCommunicationRequester_session, _ProjectionCommunicationRequester_authType_accessor_storage, _ProjectionCommunicationRequester_authData_accessor_storage, _RpcResolveProxyProvider_proxy, _RpcStreamable_id_accessor_storage;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MockRequester = exports.RpcStreamable = exports.RpcResolveProxyProvider = exports.StreamableRecieverSource = exports.StreamableReciever = exports.ProjectionCommunicationRequester = exports.DomainCommunicationResolver = exports.RpcDistributer = exports.RpcRegistry = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const Const = __importStar(__webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/const.js"));
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
const namespace_1 = __webpack_require__(/*! ./namespace */ "./node_modules/@branch-ts/core/src/namespace.js");
const log_1 = __webpack_require__(/*! ./log */ "./node_modules/@branch-ts/core/src/log.js");
class RpcRegistry {
    get rpcs() {
        return this.proxy;
    }
    get descriptors() {
        if (__classPrivateFieldGet(this, _RpcRegistry_descriptors, "f"))
            return __classPrivateFieldGet(this, _RpcRegistry_descriptors, "f");
        __classPrivateFieldSet(this, _RpcRegistry_descriptors, this.domain.findAspects("rpc"), "f");
        return __classPrivateFieldGet(this, _RpcRegistry_descriptors, "f");
    }
    constructor(domain) {
        this.domain = domain;
        this.cache = {};
        this.proxy = new Proxy({}, this);
        _RpcRegistry_descriptors.set(this, void 0);
    }
    getRpcInfo(descriptor) {
        if (typeof descriptor == "string") {
            descriptor = this.descriptors.find(item => item.uniqueName == descriptor);
        }
        if (!descriptor)
            return null;
        const service = this.domain.services[descriptor.serviceUniqueName];
        if (typeof service[descriptor.name] !== "function") {
            return null;
        }
        const handler = service[descriptor.name].bind(service);
        return {
            descriptor,
            handler
        };
    }
    get(_, rpcUniqueName) {
        if (this.cache[rpcUniqueName])
            return this.cache[rpcUniqueName];
        const info = this.cache[rpcUniqueName] = this.getRpcInfo(rpcUniqueName);
        return info;
    }
}
exports.RpcRegistry = RpcRegistry;
_RpcRegistry_descriptors = new WeakMap();
class RpcDistributer {
    constructor(domain) {
        this.domain = domain;
        this.registry = new RpcRegistry(this.domain);
        this.rpcs = this.registry.rpcs;
    }
    handleRpc(option) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const info = this.rpcs[option.rpcUniqueName];
            const rpc = info === null || info === void 0 ? void 0 : info.descriptor;
            if (!rpc) {
                throw new errors_1.Errors.NotFound(`RPC ${option.rpcUniqueName} not found`);
            }
            let isPublicAvailable = false;
            if (((_a = rpc.roles) === null || _a === void 0 ? void 0 : _a.length) == 1 && ((_b = rpc.roles) === null || _b === void 0 ? void 0 : _b[0]) == "*")
                isPublicAvailable = true;
            if (!isPublicAvailable) {
                if (!((_c = rpc.roles) === null || _c === void 0 ? void 0 : _c.includes((_d = option.session) === null || _d === void 0 ? void 0 : _d.role))) {
                    throw new errors_1.Errors.Forbidden();
                }
            }
            if (rpc.guard) {
                const op = {
                    session: option.session,
                    rpcUniqueName: option.rpcUniqueName,
                    name: rpc.name,
                    params: option.option,
                    locale: option.locale || "en",
                    domain: this.domain
                };
                yield rpc.guard(op);
            }
            return yield info.handler(option.option, {
                rpc,
                domain: this.domain,
                session: option.session,
                stream: option.stream,
            });
        });
    }
}
exports.RpcDistributer = RpcDistributer;
class DomainCommunicationResolver {
    constructor(domain) {
        this.domain = domain;
        this.session = Leaf.Util.clone(Const.DefaultGuestSessionInfo);
    }
    setSession(session) {
        this.session = session;
    }
    getSessionInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.session)
                return null;
            return {
                type: this.session.type,
                role: this.session.role,
                userId: this.session.userId,
                locale: this.session.locale,
                ipAddress: this.session.ipAddress,
                displayName: this.session.displayName,
            };
        });
    }
    rpcCall(option) {
        return __awaiter(this, void 0, void 0, function* () {
            // rpc allowed with authentication
            try {
                return yield this.domain.rpc.handleRpc({
                    rpcUniqueName: option.rpcUniqueName,
                    option: option.params,
                    session: this.session,
                    stream: option.stream,
                    locale: option.locale || "en"
                });
            }
            catch (e) {
                log_1.Logger.error(e);
                throw e;
            }
        });
    }
    requestResourceAction(option) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield this.domain.requestResourceAction({
                    descriptor: option.descriptor,
                    session: this.session
                });
                if (!result) {
                    return {
                        result: null
                    };
                }
                return result;
            }
            catch (e) {
                log_1.Logger.error(e);
                throw e;
            }
        });
    }
}
exports.DomainCommunicationResolver = DomainCommunicationResolver;
// 1. can auth (return current authing session), auth will throw if not connected
// 2. emit "session"
// 3. for stateful link, emit "connect"/"disconnect"
// 4. for unstateful link, always "connect" and isOpen = true
// 5. when connect, req/rpcCall is garenteed to work(underlying facility may through permision or other internal error accordingly)
// 6. be destroy
class ProjectionCommunicationRequester {
    constructor() {
        this.events = new Leaf.EventEmitter();
        _ProjectionCommunicationRequester_authType_accessor_storage.set(this, void 0);
        _ProjectionCommunicationRequester_authData_accessor_storage.set(this, void 0);
        this.ready = new Leaf.ReadyBehavior();
        _ProjectionCommunicationRequester_session.set(this, Leaf.Util.clone(Const.DefaultGuestSessionInfo));
    }
    get authType() { return __classPrivateFieldGet(this, _ProjectionCommunicationRequester_authType_accessor_storage, "f"); }
    set authType(value) { __classPrivateFieldSet(this, _ProjectionCommunicationRequester_authType_accessor_storage, value, "f"); }
    get authData() { return __classPrivateFieldGet(this, _ProjectionCommunicationRequester_authData_accessor_storage, "f"); }
    set authData(value) { __classPrivateFieldSet(this, _ProjectionCommunicationRequester_authData_accessor_storage, value, "f"); }
    get session() {
        return this._session;
    }
    set _session(session) {
        __classPrivateFieldSet(this, _ProjectionCommunicationRequester_session, session, "f");
        this.events.emit("session", session);
    }
    get _session() {
        return __classPrivateFieldGet(this, _ProjectionCommunicationRequester_session, "f");
    }
}
exports.ProjectionCommunicationRequester = ProjectionCommunicationRequester;
_ProjectionCommunicationRequester_session = new WeakMap(), _ProjectionCommunicationRequester_authType_accessor_storage = new WeakMap(), _ProjectionCommunicationRequester_authData_accessor_storage = new WeakMap();
let StreamableReciever = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _get_source_decorators;
    return _a = class StreamableReciever {
            constructor() {
                this.cache = (__runInitializers(this, _instanceExtraInitializers), new Leaf.Race());
                this.isDrain = false;
                this.events = new Leaf.EventEmitter();
            }
            get source() {
                return new StreamableRecieverSource(this);
            }
            get() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.isDrain)
                        return null;
                    const data = yield this.cache.consume();
                    if (!data) {
                        this.isDrain = true;
                        return null;
                    }
                    else {
                        return data;
                    }
                });
            }
            destroy() {
                this.cache = null;
            }
            autoDestory() {
                throw new Error("Not Implemented");
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _get_source_decorators = [Leaf.cache()];
            __esDecorate(_a, null, _get_source_decorators, { kind: "getter", name: "source", static: false, private: false, access: { has: obj => "source" in obj, get: obj => obj.source }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.StreamableReciever = StreamableReciever;
class StreamableRecieverSource {
    constructor(receiver) {
        this.receiver = receiver;
    }
    write(data) {
        if (!this.receiver)
            return;
        if (!this.receiver.cache)
            return;
        this.receiver.events.emit("data", data);
        this.receiver.cache.feed(data);
    }
    end() {
        this.receiver.events.emit("end");
        this.receiver.cache.feed(null);
    }
}
exports.StreamableRecieverSource = StreamableRecieverSource;
class RpcResolveProxyProvider {
    constructor(projection) {
        this.projection = projection;
        _RpcResolveProxyProvider_proxy.set(this, null);
        this.mocks = {};
    }
    mock(name, fn) {
        this.mocks[name] = fn;
    }
    getProxy() {
        if (__classPrivateFieldGet(this, _RpcResolveProxyProvider_proxy, "f"))
            return __classPrivateFieldGet(this, _RpcResolveProxyProvider_proxy, "f");
        const candidates = {};
        for (let rpc of this.projection.findAspects("rpc")) {
            const fn = candidates[rpc.uniqueName] = (option) => __awaiter(this, void 0, void 0, function* () {
                if (this.mocks[rpc.uniqueName]) {
                    return yield this.mocks[rpc.uniqueName](option);
                }
                return yield this.projection.rpcCall({
                    rpcUniqueName: rpc.uniqueName,
                    params: option,
                    locale: this.projection.locale
                });
            });
            fn["mock"] = (fn) => {
                this.mocks[rpc.uniqueName] = fn;
            };
        }
        const resolver = new namespace_1.LeveledNamespaceResolver(candidates);
        __classPrivateFieldSet(this, _RpcResolveProxyProvider_proxy, resolver.getProxy(), "f");
        return __classPrivateFieldGet(this, _RpcResolveProxyProvider_proxy, "f");
    }
}
exports.RpcResolveProxyProvider = RpcResolveProxyProvider;
_RpcResolveProxyProvider_proxy = new WeakMap();
class RpcStreamable {
    constructor() {
        _RpcStreamable_id_accessor_storage.set(this, void 0);
        this.events = new Leaf.EventEmitter();
    }
    get id() { return __classPrivateFieldGet(this, _RpcStreamable_id_accessor_storage, "f"); }
    set id(value) { __classPrivateFieldSet(this, _RpcStreamable_id_accessor_storage, value, "f"); }
}
exports.RpcStreamable = RpcStreamable;
_RpcStreamable_id_accessor_storage = new WeakMap();
class MockRequester extends ProjectionCommunicationRequester {
    constructor() {
        super(...arguments);
        this.isOpen = false;
        this.mockAuth = (option) => {
            return this.mockSession || Const.DefaultGuestSessionInfo;
        };
        this.mockStreams = {};
    }
    auth(option) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.mockAuth(option);
        });
    }
    rpcCall(option) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Not impelemented");
        });
    }
    requestResourceAction(option) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Not implemented");
        });
    }
    destroy() {
        return;
    }
    getStream(id) {
        if (this.mockStreams[id])
            return this.mockStreams[id];
        return this.mockStreams[id] = new StreamableReciever();
    }
}
exports.MockRequester = MockRequester;
//# sourceMappingURL=rpc.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/service.js":
/*!*****************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/service.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DomainServiceContext = exports.ServiceContext = exports.FastDependencyManager = exports.Service = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const namespace_1 = __webpack_require__(/*! ./namespace */ "./node_modules/@branch-ts/core/src/namespace.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
const log_1 = __webpack_require__(/*! ./log */ "./node_modules/@branch-ts/core/src/log.js");
class Service {
    constructor() {
        this.services = {};
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
}
exports.Service = Service;
class FastDependencyManager {
    constructor() {
        this.context = {};
    }
    add(name, deps) {
        if (this.context[name])
            throw new Error(`Add duplicated dependency entry: ${name} already exists`);
        if (deps && deps.length == 0)
            deps = null;
        this.context[name] = deps;
    }
    resolve(tasks = Object.keys(this.context)) {
        tasks = tasks.slice();
        const orders = [];
        const pending = [];
        while (tasks.length > 0) {
            const first = tasks.shift();
            pending.push(first);
            while (pending.length > 0) {
                const cur = pending.at(-1);
                if (!this.context[cur]) {
                    orders.push(cur);
                    pending.pop();
                    continue;
                }
                let deps = this.context[cur];
                let hasUnfinishedDep = deps.some(dep => {
                    if (orders.includes(dep))
                        return false;
                    if (pending.includes(dep)) {
                        throw new Error(`Recursive dependency ${cur} -> ${dep}`);
                    }
                    const targetIndex = tasks.indexOf(dep);
                    if (targetIndex < 0) {
                        throw new Error(`Unknown dependency ${dep} of ${cur}`);
                    }
                    tasks.splice(targetIndex, 1);
                    pending.push(dep);
                    return true;
                });
                if (!hasUnfinishedDep) {
                    orders.push(cur);
                    pending.pop();
                }
            }
        }
        return orders;
    }
}
exports.FastDependencyManager = FastDependencyManager;
class ServiceContext {
    static isServiceInitialize(service) {
        if (!service)
            return false;
        return !!service[ServiceContext.serviceInitializeSymbol];
    }
    static markServiceInitialized(service, which = true) {
        if (!service)
            return;
        service[ServiceContext.serviceInitializeSymbol] = which;
    }
    constructor() {
        this.nameResolver = new namespace_1.ConvenientNamespaceResolver();
        this.events = new Leaf.EventEmitter();
        this.ready = new Leaf.ReadyBehavior();
        this.services = this.nameResolver.getProxy();
        this.dependencyManager = new FastDependencyManager;
        this.allServices = [];
        this.lock = new Leaf.Lock();
    }
    get(name) {
        return this.services[name];
    }
    register(s, name, dependencies = null) {
        this.allServices.push(s);
        this.addToDependency(s, name, dependencies);
        this.events.emit("register", name);
        return s;
    }
    addToDependency(s, uniqueName, dependencies = null) {
        this.dependencyManager.add(uniqueName, dependencies || null);
        this.nameResolver.add(uniqueName, s);
    }
    setup() {
        return __awaiter(this, void 0, void 0, function* () {
            Object.freeze(this.services);
            yield this.lock.lock("setup");
            let orders = this.dependencyManager.resolve();
            for (let name of orders) {
                let service = this.services[name];
                if (ServiceContext.isServiceInitialize(service)) {
                    throw new Error(`Duplicated initialization of service:${name}`);
                }
                service["services"] = this.services;
                yield this.initializeService(name);
                ServiceContext.markServiceInitialized(service, true);
            }
            this.lock.release("setup");
            this.events.emit("ready");
            log_1.Logger.info("All services ready");
            this.ready.yes();
        });
    }
    initializeService(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = this.services[name];
            if (!service.initialize)
                return;
            this.events.emit("initializing", name);
            if (service.initialize.length == 1) {
                throw new Error("callback style initialize deprecated");
            }
            else {
                service["services"] = this.nameResolver.getProxy();
                log_1.Logger.info("Initializing", name);
                yield service.initialize();
                ServiceContext.markServiceInitialized(service, true);
                this.events.emit("initialized", name);
            }
        });
    }
}
exports.ServiceContext = ServiceContext;
ServiceContext.serviceInitializeSymbol = Leaf.ensureGlobal("isServiceInitialized", () => Symbol("isServiceInitialized"));
class DomainServiceContext extends ServiceContext {
    constructor(domain) {
        super();
        this.domain = domain;
        this.serviceLoaded = [];
        this.register(domain, "domain");
    }
    loadServiceFromDomain(...names) {
        let current = this.serviceLoaded.map(item => item.uniqueName);
        const services = this.domain.findAspects("service");
        const targets = namespace_1.Namespace.filterAspects(services, ...names);
        for (let target of targets) {
            if (current.includes(target.uniqueName))
                continue;
            current = this.getRequiredServices(target, current);
        }
        const todos = current.slice(this.serviceLoaded.length).map(name => this.domain.findAspect("service", { uniqueName: name }));
        for (let todo of todos) {
            if (!todo.cons) {
                log_1.Logger.warn(`${todo.uniqueName} has no constructor, likely the implementation is note included or namespace is not correctly declared at top of the service by Annotation.namespace("${todo.namespace}")}")`);
                continue;
            }
            this.register(new todo.cons(), todo.uniqueName, todo.requires);
        }
        this.serviceLoaded.push(...todos);
    }
    getRequiredServices(service, current = [], pending = []) {
        if (current.includes(service.uniqueName))
            return current;
        if (pending.includes(service.uniqueName)) {
            throw new errors_1.Errors.DesignError(`Loop dependency ${service.uniqueName}`);
        }
        pending.push(service.uniqueName);
        current = current.slice();
        for (let req of service.requires || []) {
            const sub = this.domain.findAspect("service", { uniqueName: req });
            if (!sub) {
                throw new errors_1.Errors.DesignError(`Service ${req} required by ${service.uniqueName} not found`);
            }
            current = this.getRequiredServices(sub, current, pending);
        }
        pending.pop();
        current.push(service.uniqueName);
        return current;
    }
}
exports.DomainServiceContext = DomainServiceContext;
//# sourceMappingURL=service.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/textSearch.js":
/*!********************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/textSearch.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextSearchPolicy = void 0;
const criteria_1 = __webpack_require__(/*! @root-ts/criteria */ "./node_modules/@root-ts/criteria/index.js");
const Const = __importStar(__webpack_require__(/*! ./const */ "./node_modules/@branch-ts/core/src/const.js"));
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
class TextSearchPolicy {
    constructor(fieldDescriptors) {
        this.fieldDescriptors = fieldDescriptors;
        this.searchIndexes = this.getSearchIndexes();
        this.searchIndexKeys = this.getIndexesKeys();
    }
    get modelUniqueName() {
        if (this.fieldDescriptors.length == 0)
            return "_ZeroModel_";
        return this.fieldDescriptors[0].modelUniqueName;
    }
    getIndexesKeys() {
        return Object.seal(Object.keys(this.searchIndexes).map(key => Const.TextSearchCacheKeyPrefix + key));
    }
    applyTextSearchToCondition(query, condition) {
        if (!query)
            return condition;
        if (typeof query == "string") {
            if (!query.trim())
                return condition;
            query = { default: query };
        }
        if (Object.keys(query).map(key => query[key]).every(item => !item.trim())) {
            // all empty
            return condition;
        }
        const searchCondition = new criteria_1.CriteriaBuilder();
        let count = 0;
        for (let index in this.searchIndexes) {
            if (!query[index])
                continue;
            const queryString = query[index];
            if (!queryString.trim())
                continue;
            const indexKey = this.getIndexKey(index);
            const regs = this.createSearchKeywordsRegs(queryString);
            if (regs.length == 0)
                continue;
            if (regs.length == 1) {
                searchCondition.path(indexKey).reg(regs[0]);
            }
            else {
                searchCondition.path(indexKey).all(regs);
            }
            count++;
        }
        if (count == 0) {
            // default is the only key, and yet nothing available
            if ("default" in query && Object.keys(query).length == 1) {
                throw new errors_1.Errors.DesignError(`No text index for ${this.modelUniqueName}`);
            }
            throw new errors_1.Errors.DesignError(`Unknown search indexes ${Object.keys(query).join(",")} for ${this.modelUniqueName}`);
        }
        if (!condition)
            return searchCondition.build();
        const search = searchCondition.build();
        return criteria_1.Criteria.and(condition, search);
    }
    escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    createSearchKeywordsRegs(query) {
        if (!query)
            return null;
        const words = query.split(/\s+/).map(item => item.trim()).filter(item => !!item.trim());
        return words.map(word => new RegExp(this.escapeRegExp(word), "img"));
    }
    getIndexKey(index) {
        if (!this.searchIndexes[index])
            return null;
        return Const.TextSearchCacheKeyPrefix + index;
    }
    getSearchIndexCache(full) {
        const result = {};
        for (let index in this.searchIndexes) {
            const indexKey = Const.TextSearchCacheKeyPrefix + index;
            const includes = this.searchIndexes[index];
            const contents = includes.map(key => full[key]).filter(item => !!item);
            const content = this.generateSearchContent(contents);
            result[indexKey] = content;
        }
        return result;
    }
    generateSearchContent(contents) {
        return contents.join("\n");
    }
    getSearchIndexes() {
        const fields = this.fieldDescriptors;
        const result = {};
        for (let field of fields) {
            let index = null;
            if (field.textSearch) {
                if (field.textSearch === true) {
                    index = "default";
                }
                else if (typeof field.textSearch == "string") {
                    index = field.textSearch;
                }
                else {
                    throw new errors_1.Errors.DesignError(`Invalid textSearch of ${this.modelUniqueName}.${field.key}`);
                }
            }
            if (index) {
                result[index] = result[index] || [];
                result[index].push(field.key);
            }
        }
        for (let key in result) {
            Object.seal(result[key]);
        }
        Object.seal(result);
        Object.freeze(result);
        return result;
    }
}
exports.TextSearchPolicy = TextSearchPolicy;
//# sourceMappingURL=textSearch.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/typeSystem.js":
/*!********************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/typeSystem.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UInt32TypeSpec = exports.UInt16TypeSpec = exports.UInt8TypeSpec = exports.UIntTypeSpec = exports.Unicode64KTypeSpec = exports.Unicode8KTypeSpec = exports.Unicode1024TypeSpec = exports.Unicode256TypeSpec = exports.SizeCappedTextTypeSpec = exports.UrlTypeSpec = exports.JsonTypeSpec = exports.UserIdTypeSpec = exports.ReferenceTypeSpec = exports.IdTypeSpec = exports.IntTypeSpec = exports.StringTypeSpec = exports.AnyTypeSpec = exports.TypeSpec = exports.GlobalTypeSystem = exports.TypeSystem = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const log_1 = __webpack_require__(/*! ./log */ "./node_modules/@branch-ts/core/src/log.js");
class TypeSystem {
    constructor() {
        this.types = {};
        this.literalTypeMap = {
            any: "any",
            number: "number",
            string: "string",
            boolean: "boolean",
            "Type.Branch.Text": "text",
            "Type.Branch.Text.Unicode256": "text",
            "Type.Branch.Text.Unicode1024": "text",
            "Type.Branch.Text.Unicode8K": "text",
            "Type.Branch.Text.Unicode64K": "text",
            "Type.Branch.Int": "int",
            "Type.Branch.Int.U8": "int8",
            "Type.Branch.Int.U16": "int16",
            "Type.Branch.Int.U32": "int32",
            "Type.Branch.Timestamp": "timestamp",
            "Type.Branch.Id": "id",
            "Type.Branch.Code": "code",
            "Type.Branch.Json": "json",
            "Type.Branch.Url": "url",
            "Type.Branch.UserId": "userId",
            "Type.Branch.Auto": "auto",
        };
    }
    registerTypeSpec(convention) {
        this.types[convention.type] = convention;
        convention.typeSystem = this;
    }
    registerNativeType(type, base = "any") {
        const spec = new class extends AnyTypeSpec {
            constructor() {
                super(type, base);
            }
        };
        this.registerTypeSpec(spec);
    }
    getTypeLevel(type) {
        let keys = Object.keys(this.types);
        let i = 0;
        for (let key of keys) {
            if (key == type) {
                return i;
            }
            i++;
        }
        return 0;
    }
    getStrictType(type) {
        return this.types[type];
    }
    getSpec(type) {
        return this.types[type] || this.types["any"];
    }
    registerLiteralTypeMap(map) {
        for (let lit in map) {
            if (this.literalTypeMap[lit]) {
                log_1.Logger.log(`Overwrite dupliate literal type map ${lit}`);
            }
            this.literalTypeMap[lit] = map[lit];
        }
    }
    getTypeByLiteralType(lt) {
        return this.literalTypeMap[lt];
    }
    getTypeAcestors(type) {
        const result = [];
        while (this.types[type]) {
            const spec = this.types[type];
            result.push(spec.type);
            type = spec.base;
        }
        if (result.length == 0) {
            result.push("any");
        }
        return result;
    }
    getSupportedTypeNames() {
        return ["unknown", ...Object.keys(this.types)];
    }
}
exports.TypeSystem = TypeSystem;
exports.GlobalTypeSystem = new TypeSystem();
class TypeSpec {
    constructor(type, base = null) {
        this.type = type;
        this.base = base;
        this.zeroValue = null;
    }
    get baseSpec() {
        return this.typeSystem.types[this.base] || null;
    }
    isBasedOf(type) {
        if (this.type == type)
            return true;
        if (!this.baseSpec)
            return false;
        return this.baseSpec.isBasedOf(type);
    }
}
exports.TypeSpec = TypeSpec;
class AnyTypeSpec extends TypeSpec {
    constructor(type = "any", base = null) {
        super(type, base);
    }
    equal(a, b) {
        if (this.baseSpec) {
            return this.baseSpec.equal(a, b);
        }
        return a === b;
    }
    isUninitialized(v) {
        if (this.baseSpec) {
            return this.baseSpec.isUninitialized(v);
        }
        return typeof v == "undefined";
    }
    isZeroValue(v) {
        if (this.baseSpec && this.base !== "any") {
            return this.baseSpec.isZeroValue(v);
        }
        if (this.isBasedOf("number")) {
            return v === 0;
        }
        else if (this.isBasedOf("string")) {
            return v === "";
        }
        else if (this.isBasedOf("boolean")) {
            return v === false;
        }
        else if (this.isBasedOf("array")) {
            return Array.isArray(v) && v.length == 0;
        }
        return v === null;
    }
    isSettableValue(v) {
        if (this.type == "any")
            return !this.isUninitialized(v);
        if (typeof v == this.type) {
            if (this.type == "number") {
                if (Number.isNaN(v))
                    return false;
                if (!Number.isFinite(v))
                    return false;
            }
            return true;
        }
        if (this.base !== "any" && this.baseSpec) {
            return this.baseSpec.isSettableValue(v);
        }
        return false;
    }
    isRequired(v) {
        if (this.type == "any")
            return !this.isUninitialized(v);
        if (typeof v == this.type) {
            if (this.type == "number") {
                if (Number.isNaN(v))
                    return false;
                if (!Number.isFinite(v))
                    return false;
            }
            if (this.type == "string") {
                return !!v;
            }
            return true;
        }
        if (this.base !== "any" && this.baseSpec) {
            return this.baseSpec.isSettableValue(v);
        }
        return !this.isUninitialized(v);
    }
    getZeroValue() {
        if (this.baseSpec) {
            return this.baseSpec.getZeroValue();
        }
        if (this.isBasedOf("number")) {
            return 0;
        }
        else if (this.isBasedOf("string")) {
            return "";
        }
        else if (this.isBasedOf("array")) {
            return [];
        }
        else if (this.isBasedOf("boolean")) {
            return false;
        }
        else {
            return this.zeroValue;
        }
    }
    getUninitializedValue() {
        if (this.baseSpec) {
            return this.baseSpec.getUninitializedValue();
        }
        return undefined;
    }
}
exports.AnyTypeSpec = AnyTypeSpec;
exports.GlobalTypeSystem.registerTypeSpec(new AnyTypeSpec);
class StringTypeSpec extends AnyTypeSpec {
    constructor(type = "string", base = "any") {
        super(type, base);
        this.zeroValue = "";
    }
    equal(a, b) {
        if (this.baseSpec) {
            return this.baseSpec.equal(a, b);
        }
        return a === b;
    }
    isZeroValue(v) {
        return v === "";
    }
    isSettableValue(v) {
        return typeof v === "string";
    }
    isUninitialized(v) {
        return typeof v == "undefined";
    }
}
exports.StringTypeSpec = StringTypeSpec;
exports.GlobalTypeSystem.registerTypeSpec(new StringTypeSpec);
exports.GlobalTypeSystem.registerNativeType("number", "any");
exports.GlobalTypeSystem.registerNativeType("enum", "any");
exports.GlobalTypeSystem.registerNativeType("boolean", "any");
exports.GlobalTypeSystem.registerNativeType("text", "string");
exports.GlobalTypeSystem.registerNativeType("auto", "any");
class IntTypeSpec extends AnyTypeSpec {
    constructor(type = "int", base = "number") {
        super(type, base);
    }
    isSettableValue(v) {
        if (!this.baseSpec.isSettableValue(v))
            return false;
        if (!Number.isSafeInteger(v)) {
            return false;
        }
        return true;
    }
}
exports.IntTypeSpec = IntTypeSpec;
exports.GlobalTypeSystem.registerTypeSpec(new IntTypeSpec);
exports.GlobalTypeSystem.registerNativeType("timestamp", "int");
class IdTypeSpec extends StringTypeSpec {
    constructor(type = "id", base = "string") {
        super(type, base);
        this.zeroValue = null;
    }
    equal(a, b) {
        if (this.baseSpec) {
            return this.baseSpec.equal(a, b);
        }
        return a === b;
    }
    isUninitialized(v) {
        return typeof v == "undefined";
    }
    isZeroValue(v) {
        return v === null;
    }
    isSettableValue(v) {
        return typeof v === "string" || this.isZeroValue(v);
    }
}
exports.IdTypeSpec = IdTypeSpec;
exports.GlobalTypeSystem.registerTypeSpec(new IdTypeSpec);
class ReferenceTypeSpec extends IdTypeSpec {
    constructor(type = "reference", base = "id") {
        super(type, base);
    }
}
exports.ReferenceTypeSpec = ReferenceTypeSpec;
exports.GlobalTypeSystem.registerTypeSpec(new ReferenceTypeSpec);
class UserIdTypeSpec extends IdTypeSpec {
    constructor(type = "userId", base = "id") {
        super(type, base);
    }
}
exports.UserIdTypeSpec = UserIdTypeSpec;
exports.GlobalTypeSystem.registerTypeSpec(new UserIdTypeSpec);
exports.GlobalTypeSystem.registerNativeType("code", "text");
class JsonTypeSpec extends AnyTypeSpec {
    constructor(type = "json", base = "any") {
        super(type, base);
        this.zeroValue = null;
    }
    equal(a, b) {
        return Leaf.Util.deepEqual(a, b);
    }
    isUninitialized(v) {
        return typeof v == undefined;
    }
    isZeroValue(v) {
        return v === null;
    }
    isSettableValue(v) {
        return typeof v !== "undefined";
    }
}
exports.JsonTypeSpec = JsonTypeSpec;
exports.GlobalTypeSystem.registerTypeSpec(new JsonTypeSpec());
class UrlTypeSpec extends StringTypeSpec {
    constructor(type = "url", base = "string") {
        super(type, base);
    }
}
exports.UrlTypeSpec = UrlTypeSpec;
exports.GlobalTypeSystem.registerTypeSpec(new UrlTypeSpec());
class SizeCappedTextTypeSpec extends StringTypeSpec {
    constructor(sizeCap, type, base = "text") {
        super(type, base);
        this.sizeCap = sizeCap;
    }
    isSettableValue(v) {
        if (typeof v !== "string")
            return false;
        if (v.length > this.sizeCap)
            return false;
        return true;
    }
}
exports.SizeCappedTextTypeSpec = SizeCappedTextTypeSpec;
class Unicode256TypeSpec extends SizeCappedTextTypeSpec {
    constructor() {
        super(256, "unicode256", "text");
    }
}
exports.Unicode256TypeSpec = Unicode256TypeSpec;
class Unicode1024TypeSpec extends SizeCappedTextTypeSpec {
    constructor() {
        super(1024, "unicode1024", "text");
    }
}
exports.Unicode1024TypeSpec = Unicode1024TypeSpec;
class Unicode8KTypeSpec extends SizeCappedTextTypeSpec {
    constructor() {
        super(1024 * 8, "unicode8K", "text");
    }
}
exports.Unicode8KTypeSpec = Unicode8KTypeSpec;
class Unicode64KTypeSpec extends SizeCappedTextTypeSpec {
    constructor() {
        super(1024 * 64, "unicode64K", "text");
    }
}
exports.Unicode64KTypeSpec = Unicode64KTypeSpec;
exports.GlobalTypeSystem.registerTypeSpec(new Unicode256TypeSpec());
exports.GlobalTypeSystem.registerTypeSpec(new Unicode1024TypeSpec());
exports.GlobalTypeSystem.registerTypeSpec(new Unicode8KTypeSpec());
exports.GlobalTypeSystem.registerTypeSpec(new Unicode64KTypeSpec());
class UIntTypeSpec extends IntTypeSpec {
    constructor(maxNotInclude, type, base = "int") {
        super(type, base);
        this.maxNotInclude = maxNotInclude;
    }
    isSettableValue(v) {
        if (!super.isSettableValue(v))
            return false;
        if (v < 0)
            return false;
        if (v >= this.maxNotInclude)
            return false;
        return true;
    }
}
exports.UIntTypeSpec = UIntTypeSpec;
class UInt8TypeSpec extends UIntTypeSpec {
    constructor() {
        super(1 << 8, "uint8", "int");
    }
}
exports.UInt8TypeSpec = UInt8TypeSpec;
class UInt16TypeSpec extends UIntTypeSpec {
    constructor() {
        super(1 << 16, "uint16", "int");
    }
}
exports.UInt16TypeSpec = UInt16TypeSpec;
class UInt32TypeSpec extends UIntTypeSpec {
    constructor() {
        super(1 << 32, "uint32", "int");
    }
}
exports.UInt32TypeSpec = UInt32TypeSpec;
exports.GlobalTypeSystem.registerTypeSpec(new UInt8TypeSpec());
exports.GlobalTypeSystem.registerTypeSpec(new UInt16TypeSpec());
exports.GlobalTypeSystem.registerTypeSpec(new UInt32TypeSpec());
//# sourceMappingURL=typeSystem.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/core/src/util.js":
/*!**************************************************!*\
  !*** ./node_modules/@branch-ts/core/src/util.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Util = void 0;
const log_1 = __webpack_require__(/*! ./log */ "./node_modules/@branch-ts/core/src/log.js");
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@branch-ts/core/src/errors.js");
var Util;
(function (Util) {
    function ensureOnce(name, message = "Duplicate imports") {
        let uniqueCounter = Leaf.ensureGlobal(`Unique_${name}`, () => {
            let limit = Error.stackTraceLimit;
            Error.stackTraceLimit = Infinity;
            const prev = {
                count: 0,
                stack: new Error().stack.toString()
            };
            Error.stackTraceLimit = limit;
            return prev;
        });
        if (uniqueCounter.count > 0) {
            let limit = Error.stackTraceLimit;
            log_1.Logger.error(message);
            log_1.Logger.error("Duplicated import:", uniqueCounter.stack);
            const cur = {
                count: 0,
                stack: new Error().stack.toString()
            };
            log_1.Logger.error("Current import:", cur.stack);
            Error.stackTraceLimit = limit;
        }
        uniqueCounter.count++;
    }
    Util.ensureOnce = ensureOnce;
    Util.UniqueHandleSymbol = Leaf.ensureGlobal("UniqueHandleSymbol", () => {
        return Symbol("UniqueHandleSymbol");
    });
    function createLocalHandle() {
        return {
            id: Math.random().toString().slice(3),
        };
    }
    Util.createLocalHandle = createLocalHandle;
    Util.LocalHandle = createLocalHandle();
    function attachHandle(obj) {
        if (obj[Util.UniqueHandleSymbol]) {
            if (obj[Util.UniqueHandleSymbol].id == Util.LocalHandle.id)
                return true;
            return false;
        }
        Object.defineProperty(obj, Util.UniqueHandleSymbol, {
            configurable: false,
            enumerable: false,
            get() {
                return Util.LocalHandle;
            }
        });
        return true;
    }
    Util.attachHandle = attachHandle;
    Util.ConstructorSymbol = Leaf.ensureGlobal("ConstructorSymbol", () => {
        return Symbol("ConstructorSymbol");
    });
    function markBaseConstructor(cons, name = cons.name) {
        cons.prototype[Util.ConstructorSymbol] = name;
    }
    Util.markBaseConstructor = markBaseConstructor;
    function isConstructorOfBase(cons, base) {
        if (!base) {
            throw new errors_1.Errors.DesignError(`Base class is not available`);
        }
        if (!base.prototype[Util.ConstructorSymbol]) {
            throw new errors_1.Errors.DesignError(`Base class ${base.name} is not marked as base class`);
        }
        return cons.prototype[Util.ConstructorSymbol] == base.prototype[Util.ConstructorSymbol];
    }
    Util.isConstructorOfBase = isConstructorOfBase;
    function isInstanceOfBase(obj, base) {
        if (!obj)
            return false;
        if (!base.prototype[Util.ConstructorSymbol]) {
            throw new errors_1.Errors.DesignError(`Base class ${base.name} is not marked as base class`);
        }
        return obj[Util.ConstructorSymbol] == base.prototype[Util.ConstructorSymbol];
    }
    Util.isInstanceOfBase = isInstanceOfBase;
})(Util || (exports.Util = Util = {}));
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/web/src/ui/actions/actions.html.R.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@branch-ts/web/src/ui/actions/actions.html.R.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.R = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
var R;
(function (R) {
    class Actions extends Leaf.GeneratedWidget {
        constructor() {
            super(function () {
                var _e = this._e.bind(this);
                var _t = this._t.bind(this);
                return _e("div", { "data-list": { "name": "data-list", "templates": [{ "type": "raw", "content": "actionList" }] }, "class": { "name": "class", "templates": [{ "type": "raw", "content": "actions-a3e47a line text" }] } }, []);
            }, "Actions", []);
            this.TestDatas = Actions.TestDatas;
            this.BindedLists = Actions.BindedLists;
            this.BindedWidgets = Actions.BindedWidgets;
            this.InitialData = Actions.InitialData;
            this.path = Actions.path;
            this.GeneratedConstructor = Actions;
            if (Actions.InitialData) {
                this.renderRecursive(Actions.InitialData);
            }
        }
    }
    Actions.TestDatas = [];
    Actions.BindedLists = [{ "name": "actionList", "type": "void", "reference": null }];
    Actions.BindedWidgets = [];
    Actions.path = "/ui/actions/actions";
    Actions.widgetName = "Actions";
    Actions.InitialData = null;
    R.Actions = Actions;
    Actions["prototype"].widgetName = "Actions";
    (function (Actions) {
        class Button extends Leaf.GeneratedWidget {
            constructor() {
                super(function () {
                    var _e = this._e.bind(this);
                    var _t = this._t.bind(this);
                    return _e("span", { "role": { "name": "role", "templates": [{ "type": "raw", "content": "button" }] }, "class": { "name": "class", "templates": [{ "type": "raw", "content": "button-693853 button " }, { "type": "value", "content": "type", "reverse": false }] } }, [_t({ "templates": [{ "type": "value", "content": "buttonText", "reverse": false }] })]);
                }, "Button", ["buttonText", "type"]);
                this.TestDatas = Button.TestDatas;
                this.BindedLists = Button.BindedLists;
                this.BindedWidgets = Button.BindedWidgets;
                this.InitialData = Button.InitialData;
                this.path = Button.path;
                this.GeneratedConstructor = Button;
                if (Button.InitialData) {
                    this.renderRecursive(Button.InitialData);
                }
            }
        }
        Button.TestDatas = [];
        Button.BindedLists = [];
        Button.BindedWidgets = [];
        Button.path = "/ui/actions/actions/button";
        Button.widgetName = "Button";
        Button.InitialData = null;
        Actions.Button = Button;
        Button["prototype"].widgetName = "Button";
    })(Actions = R.Actions || (R.Actions = {}));
})(R || (exports.R = R = {}));
//# sourceMappingURL=actions.html.R.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/web/src/ui/actions/actions.js":
/*!***************************************************************!*\
  !*** ./node_modules/@branch-ts/web/src/ui/actions/actions.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Actions_errorHanler;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActionButton = exports.Actions = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const commonUI_1 = __webpack_require__(/*! ../commonUI/commonUI */ "./node_modules/@branch-ts/web/src/ui/commonUI/commonUI.js");
const actions_html_R_1 = __webpack_require__(/*! ./actions.html.R */ "./node_modules/@branch-ts/web/src/ui/actions/actions.html.R.js");
class Actions extends actions_html_R_1.R.Actions {
    constructor(actions) {
        super();
        this.defaultStyle = "link";
        this.events = new Leaf.EventEmitter();
        this.descriptors = [];
        _Actions_errorHanler.set(this, (e) => {
            commonUI_1.CommonUI.error(e);
        });
        if (actions)
            this.setActions(actions);
    }
    setLoadingTarget(target) {
        this.loadingTarget = target;
        return this;
    }
    setDefaultStyle(style) {
        this.defaultStyle = style;
        return this;
    }
    onChildAddActionList(child) {
        child.events.listenBy(this, "triggered", (result) => {
            this.events.emit(`triggered/${child.descriptor.name}`, result);
            this.events.emit("triggered", {
                action: child.descriptor,
                result
            });
        });
    }
    trigger(name) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            for (let item of this.actionList.toArray()) {
                const desc = item.descriptor;
                if (desc.name.toLocaleLowerCase() === name.toLocaleLowerCase() || ((_a = desc.displayName) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) == name.toLocaleLowerCase()) {
                    yield item.trigger();
                }
            }
        });
    }
    onChildRemoveActionList(child) {
        child.events.stopListenBy(this);
    }
    setActions(descs) {
        this.actionList.length = 0;
        this.descriptors = descs;
        this.sync();
        return this;
    }
    action(desc) {
        this.descriptors.push(desc);
        this.sync();
        return this;
    }
    sync() {
        return __awaiter(this, void 0, void 0, function* () {
            let todos = [];
            for (let action of this.descriptors) {
                if (action.test) {
                    if (!(yield action.test()))
                        continue;
                }
                todos.push(action);
            }
            const diff = Leaf.Util.arrayDiffTyped(todos, this.actionList.toArray(), (a, b) => {
                return a === b.descriptor;
            });
            for (let item of diff.right) {
                this.actionList.removeItem(item);
            }
            for (let item of diff.left) {
                const button = new ActionButton(this, item);
                this.actionList.push(button);
            }
            const arrs = this.actionList.toArray().sort((a, b) => {
                return todos.indexOf(a.descriptor) - todos.indexOf(b.descriptor);
            });
            this.actionList.length = 0;
            this.actionList.push(...arrs);
        });
    }
    get errorHandler() {
        return __classPrivateFieldGet(this, _Actions_errorHanler, "f");
    }
    catch(handler) {
        __classPrivateFieldSet(this, _Actions_errorHanler, handler, "f");
        return this;
    }
}
exports.Actions = Actions;
_Actions_errorHanler = new WeakMap();
class ActionButton extends actions_html_R_1.R.Actions.Button {
    constructor(actions, descriptor) {
        super();
        this.actions = actions;
        this.descriptor = descriptor;
        this.events = new Leaf.EventEmitter();
        this.VM.buttonText = descriptor.displayName || descriptor.name;
        this.VM.type == this.actions.defaultStyle;
        if (descriptor.style == "link") {
            this.VM.type = "link";
        }
        else if (descriptor.style == "warning") {
            this.VM.type = "warning";
        }
        else if (descriptor.style == "primary") {
            this.VM.type = "primary";
        }
    }
    onClickNode() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.trigger();
        });
    }
    trigger() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let result;
                result = yield commonUI_1.CommonUI.loading(this.actions.loadingTarget || this).during(() => __awaiter(this, void 0, void 0, function* () {
                    return yield this.descriptor.todo();
                }));
                this.events.emit("triggered", result);
            }
            catch (e) {
                if (this.actions.errorHandler) {
                    this.actions.errorHandler(e);
                }
                else {
                    throw e;
                }
            }
        });
    }
}
exports.ActionButton = ActionButton;
//# sourceMappingURL=actions.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/web/src/ui/commonUI/commonUI.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@branch-ts/web/src/ui/commonUI/commonUI.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonUI = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const windowBox_1 = __webpack_require__(/*! ../window/windowBox */ "./node_modules/@branch-ts/web/src/ui/window/windowBox.js");
const toaster_1 = __webpack_require__(/*! ./toaster */ "./node_modules/@branch-ts/web/src/ui/commonUI/toaster.js");
const loadingManager_1 = __webpack_require__(/*! ../loading/loadingManager */ "./node_modules/@branch-ts/web/src/ui/loading/loadingManager.js");
const actions_1 = __webpack_require__(/*! ../actions/actions */ "./node_modules/@branch-ts/web/src/ui/actions/actions.js");
const core_1 = __webpack_require__(/*! @branch-ts/core */ "./node_modules/@branch-ts/core/index.js");
const inputGroupBehavior_1 = __webpack_require__(/*! ../form/inputGroupBehavior */ "./node_modules/@branch-ts/web/src/ui/form/inputGroupBehavior.js");
class CommonUI {
    static loading(target, option = {}) {
        return loadingManager_1.LoadingManager.track(target, option);
    }
    static toast(content) {
        return toaster_1.Toaster.toast(content);
    }
    static prompt(message, _default) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.promptHandler) {
                return yield this.promptHandler(message, _default);
            }
            return window.prompt(message, _default);
        });
    }
    static alert(content, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            callback = callback || (() => null);
            if (this.alertHandler) {
                yield this.alertHandler(content);
                return;
            }
            else {
                alert(content);
                callback();
            }
        });
    }
    static getText(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const box = new windowBox_1.WindowBox();
            if (option.title) {
                box.setTitle(option.title);
            }
            const text = document.createElement("textarea");
            text.classList.add("text", "multiline");
            text.value = option.default || "";
            //text.style.whiteSpace = "wrap";
            text.classList.add("text", "multiline");
            //text.style.whiteSpace = "pre-wrap"
            text.style.padding = "20px";
            text.style.width = "800px";
            text.style.height = "640px";
            text.style.maxWidth = "90%";
            text.style.maxHeight = "90%";
            box.UI.container.appendChild(text);
            const inputGroup = new inputGroupBehavior_1.AreaInputGroupBehavior(box.node);
            try {
                const result = yield new Promise((res, rej) => {
                    inputGroup.events.once("submit", () => {
                        res(text.value.trim());
                    });
                    box.asPopup.events.listenByOnce(this, "hide", () => {
                        rej(new core_1.Errors.Abort());
                    });
                    const actions = new actions_1.Actions().setActions([{
                            name: option.ok || "Ok",
                            todo() {
                                return __awaiter(this, void 0, void 0, function* () {
                                    res(text.value.trim());
                                });
                            },
                            style: "primary",
                        }, {
                            name: option.cancel || "Cancel",
                            todo() {
                                return __awaiter(this, void 0, void 0, function* () {
                                    rej(new core_1.Errors.Abort());
                                });
                            }
                        }]);
                    box.UI.container.appendChild(actions.node);
                    box.asPopup.show();
                    text.focus();
                });
                return result;
            }
            finally {
                box.asPopup.events.stopListenBy(this);
                box.asPopup.hide();
            }
        });
    }
    static show(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const box = new windowBox_1.WindowBox();
            if (option.title) {
                box.setTitle(option.title);
            }
            if (option.text) {
                const text = document.createElement("div");
                text.innerText = option.text;
                text.style.whiteSpace = "wrap";
                text.classList.add("text", "multiline");
                text.style.whiteSpace = "pre-wrap";
                text.style.padding = "20px";
                box.UI.container.appendChild(text);
            }
            if (option.element) {
                box.UI.container.appendChild(option.element);
            }
            box.asPopup.show();
            yield box.asPopup.events.wait("hide");
        });
    }
    static nativeConfirm(title) {
        let result = confirm(title);
        return result;
    }
    static confirm(title) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.confirmHandler) {
                let result = yield this.confirmHandler(title);
                return result;
            }
            else {
                if (this.useNativeConfirm) {
                    return this.nativeConfirm(title);
                }
                else {
                    return this.nativeConfirm(title);
                }
            }
        });
    }
    static error(error, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            callback = callback || (() => null);
            console.error("Toast error", error);
            let content = "";
            if (typeof error == "string") {
                content = error;
            }
            else if (error instanceof Error) {
                if (error.name && error.name !== "Error") {
                    content = `${error.name}: ${error.message}`;
                }
                else {
                    content = error.message || error.name;
                }
            }
            if (this.errorHandler) {
                yield this.errorHandler(content);
                callback();
            }
            else {
                this.toast(content);
                callback && callback();
            }
        });
    }
    static block(el) {
        return {
            with: (option) => {
                CommonUI.toast(option.hint);
            }
        };
    }
    static unblock(el) {
        return;
    }
    static beginLoading() {
        this.loading(document.body).begin();
    }
    static finishLoading() {
        this.loading(document.body).end();
    }
    static isLoading() {
        return Object.keys(this.loadings).some(key => {
            return this.loadings[key];
        });
    }
    static vibrate(time = 100) {
        try {
            if (!navigator.vibrate) {
                const node = document.createElement("div");
                node.style.position = "absolute";
                node.style.width = "100%";
                node.style.height = "100%";
                node.style.left = "0";
                node.style.top = "0";
                node.style.transition = "all 300ms";
                node.style.background = "rgb(99,99,99)";
                node.style.opacity = "0.12";
                node.style.zIndex = "999999999999";
                node.style.pointerEvents = "none";
                document.body.appendChild(node);
                setTimeout(() => {
                    node.style.opacity = "0";
                }, 0);
                setTimeout(() => {
                    document.body.removeChild(node);
                }, 400);
            }
            else {
                navigator.vibrate(time);
            }
        }
        catch (e) {
            // Fail silently
        }
    }
}
exports.CommonUI = CommonUI;
CommonUI.useNativeConfirm = false;
CommonUI.loadingCounter = 0;
CommonUI.loadings = Leaf.ensureGlobal("CommonUILoadingStates", () => { return {}; });
const binds = ["confirm", "alert", "toast", "error"];
for (let key of binds) {
    CommonUI[key] = CommonUI[key].bind(CommonUI);
}
//# sourceMappingURL=commonUI.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/web/src/ui/commonUI/toaster.html.R.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@branch-ts/web/src/ui/commonUI/toaster.html.R.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.R = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
var R;
(function (R) {
    class Toaster extends Leaf.GeneratedWidget {
        constructor() {
            super(function () {
                var _e = this._e.bind(this);
                var _t = this._t.bind(this);
                return _e("div", { "class": { "name": "class", "templates": [{ "type": "raw", "content": "toaster-02ce89 toaster " }, { "type": "value", "content": "show", "reverse": false }, { "type": "raw", "content": " " }, { "type": "value", "content": "fadeOut", "reverse": false }] } }, [_t({ "templates": [{ "type": "raw", "content": "\n    " }] }), _e("div", { "class": { "name": "class", "templates": [{ "type": "raw", "content": "pop-wrapper" }] } }, [_t({ "templates": [{ "type": "raw", "content": "\n        " }] }), _e("div", { "class": { "name": "class", "templates": [{ "type": "raw", "content": "progress-bar" }] } }, [_t({ "templates": [{ "type": "raw", "content": "\n            " }] }), _e("div", { "data-id": { "name": "data-id", "templates": [{ "type": "raw", "content": "progress" }] }, "class": { "name": "class", "templates": [{ "type": "raw", "content": "progress" }] } }, []), _t({ "templates": [{ "type": "raw", "content": "\n        " }] })]), _t({ "templates": [{ "type": "raw", "content": "\n        " }] }), _e("div", { "class": { "name": "class", "templates": [{ "type": "raw", "content": "message" }] } }, [_t({ "templates": [{ "type": "value", "content": "message", "reverse": false }] })]), _t({ "templates": [{ "type": "raw", "content": "\n    " }] })]), _t({ "templates": [{ "type": "raw", "content": "\n" }] })]);
            }, "Toaster", ["message", "show", "fadeOut"]);
            this.TestDatas = Toaster.TestDatas;
            this.BindedLists = Toaster.BindedLists;
            this.BindedWidgets = Toaster.BindedWidgets;
            this.InitialData = Toaster.InitialData;
            this.path = Toaster.path;
            this.GeneratedConstructor = Toaster;
            if (Toaster.InitialData) {
                this.renderRecursive(Toaster.InitialData);
            }
        }
    }
    Toaster.TestDatas = [];
    Toaster.BindedLists = [];
    Toaster.BindedWidgets = [];
    Toaster.path = "/ui/commonUI/toaster";
    Toaster.widgetName = "Toaster";
    Toaster.InitialData = null;
    R.Toaster = Toaster;
    Toaster["prototype"].widgetName = "Toaster";
})(R || (exports.R = R = {}));
//# sourceMappingURL=toaster.html.R.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/web/src/ui/commonUI/toaster.js":
/*!****************************************************************!*\
  !*** ./node_modules/@branch-ts/web/src/ui/commonUI/toaster.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Toaster = exports.ToastManager = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const popupBehavior_1 = __webpack_require__(/*! ../popup/popupBehavior */ "./node_modules/@branch-ts/web/src/ui/popup/popupBehavior.js");
const commonUI_1 = __webpack_require__(/*! ./commonUI */ "./node_modules/@branch-ts/web/src/ui/commonUI/commonUI.js");
const toaster_html_R_1 = __webpack_require__(/*! ./toaster.html.R */ "./node_modules/@branch-ts/web/src/ui/commonUI/toaster.html.R.js");
class ToastManager {
    constructor() {
        this.frame = new Leaf.FrameBehavior().setInterval(1000 / 60).frame((delta) => __awaiter(this, void 0, void 0, function* () {
            this.next(delta);
        }));
        this.queue = [];
        this.currentHolding = null;
        this.maxShowing = Leaf.Util.isMobile() && 3 || 5;
        this.padding = 15;
    }
    next(delta) {
        for (let item of this.queue) {
            item.next(delta);
        }
    }
    add(toaster) {
        if (this.queue.length == 0) {
            this.frame.start();
        }
        for (let item of this.queue.slice()) {
            if (item.text === toaster.text) {
                item.hide();
            }
        }
        this.queue.push(toaster);
        this.render();
    }
    pause() {
        this.frame.stop();
    }
    continue() {
        if (this.queue.length > 0) {
            this.frame.start();
        }
    }
    remove(toaster) {
        this.queue = this.queue.filter(item => item !== toaster);
        this.render();
        if (this.queue.length == 0)
            this.frame.stop();
    }
    render() {
        let padding = this.padding;
        let top = 0;
        let maxShowing = this.maxShowing;
        let showings = [];
        let todos = this.queue.slice().reverse();
        for (let item of todos) {
            if (item.isPersist) {
                showings.push(item);
            }
            else if (maxShowing > 0) {
                maxShowing -= 1;
                showings.push(item);
            }
        }
        showings.reverse();
        showings.forEach((toaster, index) => {
            top += padding;
            toaster.node.style.transform = `translateY(${top}px) translateX(-50%)`;
            top += toaster.getHeight();
        });
        this.queue.slice().forEach((hide) => {
            if (showings.includes(hide))
                return;
            hide.node.style.transform = `translateY(${padding}px) translateX(-50%) scale(0.6)`;
        });
    }
}
exports.ToastManager = ToastManager;
class Toaster extends toaster_html_R_1.R.Toaster {
    static toast(text, time = 1000 * 2) {
        let t = new Toaster(text, time);
        t.show();
        return t;
    }
    constructor(text, time = 1000 * 2) {
        super();
        this.text = text;
        this.time = time;
        this.asPopup = new popupBehavior_1.PopupBehavior(this).withoutMask();
        this.duration = this.time;
        this.left = 1;
        this.isPersist = false;
        this.manager = Toaster.manager;
        this.isShow = false;
        this.asPopup.isPassThrough = true;
        this.node.style.position = "absolute";
        this.node.style.left = "50%";
        this.node.style.top = "0";
        this.node.onmouseenter = () => {
            this.persist();
        };
        this.node.onmouseleave = () => {
            this.unpersist();
        };
        this.node.ontouchstart = () => {
            this.persist();
        };
        this.node.ontouchend = () => {
            this.unpersist();
        };
        this.VM.message = this.text;
    }
    persist() {
        this.isPersist = true;
        this.manager.currentHolding = this;
        this.manager.pause();
    }
    unpersist() {
        this.isPersist = false;
        this.manager.continue();
    }
    next(delta) {
        this.left -= delta / this.duration;
        if (this.left <= 0) {
            this.left = 0;
            this.hide();
            return;
        }
        this.render();
    }
    render() {
        this.UI.progress.style.width = `${Math.min(1 + (1 - this.left) * 100, 100)}%`;
    }
    show() {
        this.VM.show = true;
        this.isShow = true;
        this.asPopup.show();
        this.manager.add(this);
    }
    hide() {
        return __awaiter(this, void 0, void 0, function* () {
            this.VM.show = false;
            this.isShow = false;
            this.VM.fadeOut = true;
            this.manager.remove(this);
            yield Leaf.Util.sleep(500);
            this.asPopup.hide();
        });
    }
    toast(message) {
        if (this.left <= 0) {
            return Toaster.toast(message);
        }
        this.left = 1;
        return this;
    }
    getHeight() {
        return this.node.getBoundingClientRect().height;
    }
    onClickNode() {
        return __awaiter(this, void 0, void 0, function* () {
            this.manager.pause();
            yield commonUI_1.CommonUI.show({
                text: this.text
            });
            this.manager.continue();
        });
    }
}
exports.Toaster = Toaster;
Toaster.manager = Leaf.ensureGlobal("LeafWebappLibToastManager", () => new ToastManager());
//# sourceMappingURL=toaster.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/web/src/ui/form/inputGroupBehavior.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@branch-ts/web/src/ui/form/inputGroupBehavior.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AreaInputGroupBehavior = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
let AreaInputGroupBehavior = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _keyUpListener_decorators;
    let _keyDownListener_decorators;
    return _a = class AreaInputGroupBehavior {
            constructor(area) {
                this.area = (__runInitializers(this, _instanceExtraInitializers), area);
                this.listenDetector = new Leaf.OncePerObjectBehavior(this);
                this.inputs = [];
                this.current = null;
                this.events = new Leaf.EventEmitter();
                this.sync();
                this.area.addEventListener("focusin", () => {
                    this.sync();
                });
                this.area.addEventListener("focusout", () => {
                    this.sync();
                });
            }
            focus() {
                var _b;
                this.sync();
                if (!this.current)
                    this.current = this.inputs[0];
                (_b = this.current) === null || _b === void 0 ? void 0 : _b.focus();
            }
            blur() {
                var _b;
                if (this.area.contains(document.activeElement)) {
                    (_b = document.activeElement) === null || _b === void 0 ? void 0 : _b["blur"]();
                }
            }
            set index(v) {
                this.sync();
                if (v < 0)
                    v = 0;
                if (v >= this.inputs.length)
                    v = this.inputs.length - 1;
                this.current = this.inputs[v];
                this.current.focus();
            }
            get index() {
                return this.inputs.indexOf(this.current);
            }
            get nextIndex() {
                return (this.index + 1) % this.inputs.length;
            }
            get prevIndex() {
                return (this.index - 1 + this.inputs.length) % this.inputs.length;
            }
            sync() {
                let inputs = Array.from(this.area.querySelectorAll("input, textarea, [contenteditable]"));
                const diff = Leaf.Util.arrayDiff(this.inputs, inputs);
                for (let item of diff.left) {
                    this.unattach(item);
                }
                for (let item of diff.right) {
                    this.attach(item);
                }
                this.inputs = inputs;
                if (!this.inputs.includes(this.current))
                    this.current = this.inputs[0];
            }
            next() {
                this.index = this.nextIndex;
            }
            prev() {
                this.index = this.prevIndex;
            }
            submit() {
                this.events.emit("submit");
            }
            keyUpListener(e) {
                var _b;
                if (((_b = e.key) === null || _b === void 0 ? void 0 : _b.toLowerCase()) == "enter") {
                    // do nothing
                    if (document.activeElement instanceof HTMLInputElement) {
                        e.stopImmediatePropagation();
                        e.preventDefault();
                        if (e.ctrlKey || e.metaKey) {
                            this.submit();
                        }
                        else {
                            if (this.index == this.inputs.length - 1) {
                                this.submit();
                            }
                            else {
                                this.next();
                            }
                        }
                    }
                    else if (e.ctrlKey || e.metaKey) {
                        if (this.index == this.inputs.length - 1) {
                            this.submit();
                        }
                        else {
                            this.next();
                        }
                    }
                }
            }
            keyDownListener(e) {
                var _b;
                if (((_b = e.key) === null || _b === void 0 ? void 0 : _b.toLowerCase()) == "tab") {
                    e.stopImmediatePropagation();
                    e.preventDefault();
                    if (e.shiftKey) {
                        this.prev();
                    }
                    else {
                        this.next();
                    }
                }
            }
            attach(item) {
                if (this.listenDetector.isTouched(item))
                    return;
                this.listenDetector.touch(item, () => {
                    item.addEventListener("keyup", this.keyUpListener);
                    item.addEventListener("keydown", this.keyDownListener);
                });
            }
            unattach(item) {
                if (!this.listenDetector.isTouched(item))
                    return;
                this.listenDetector.untouch(item);
                item.removeEventListener("keyup", this.keyUpListener);
                item.removeEventListener("keydown", this.keyDownListener);
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _keyUpListener_decorators = [Leaf.bound()];
            _keyDownListener_decorators = [Leaf.bound()];
            __esDecorate(_a, null, _keyUpListener_decorators, { kind: "method", name: "keyUpListener", static: false, private: false, access: { has: obj => "keyUpListener" in obj, get: obj => obj.keyUpListener }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _keyDownListener_decorators, { kind: "method", name: "keyDownListener", static: false, private: false, access: { has: obj => "keyDownListener" in obj, get: obj => obj.keyDownListener }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.AreaInputGroupBehavior = AreaInputGroupBehavior;
//# sourceMappingURL=inputGroupBehavior.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/web/src/ui/loading/loading.html.R.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@branch-ts/web/src/ui/loading/loading.html.R.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.R = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
var R;
(function (R) {
    class Loading extends Leaf.GeneratedWidget {
        constructor() {
            super(function () {
                var _e = this._e.bind(this);
                var _t = this._t.bind(this);
                return _e("loading", { "class": { "name": "class", "templates": [{ "type": "raw", "content": "loading-a21bee" }] } }, [_t({ "templates": [{ "type": "raw", "content": "\n    " }] }), _e("div", { "data-id": { "name": "data-id", "templates": [{ "type": "raw", "content": "circle" }] }, "class": { "name": "class", "templates": [{ "type": "raw", "content": "loading " }, { "type": "value", "content": "style", "reverse": false }] } }, [_t({ "templates": [{ "type": "raw", "content": "Loading..." }] })]), _t({ "templates": [{ "type": "raw", "content": "\n" }] })]);
            }, "Loading", ["style"]);
            this.TestDatas = Loading.TestDatas;
            this.BindedLists = Loading.BindedLists;
            this.BindedWidgets = Loading.BindedWidgets;
            this.InitialData = Loading.InitialData;
            this.path = Loading.path;
            this.GeneratedConstructor = Loading;
            if (Loading.InitialData) {
                this.renderRecursive(Loading.InitialData);
            }
        }
    }
    Loading.TestDatas = [];
    Loading.BindedLists = [];
    Loading.BindedWidgets = [];
    Loading.path = "/ui/loading/loading";
    Loading.widgetName = "Loading";
    Loading.InitialData = null;
    R.Loading = Loading;
    Loading["prototype"].widgetName = "Loading";
})(R || (exports.R = R = {}));
//# sourceMappingURL=loading.html.R.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/web/src/ui/loading/loading.js":
/*!***************************************************************!*\
  !*** ./node_modules/@branch-ts/web/src/ui/loading/loading.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoadingView = exports.Loading = void 0;
const loading_html_R_1 = __webpack_require__(/*! ./loading.html.R */ "./node_modules/@branch-ts/web/src/ui/loading/loading.html.R.js");
class Loading extends loading_html_R_1.R.Loading {
    constructor() {
        super();
        this.size = 18;
        this.VM.style = "simple";
        this.setSize(this.size);
        this.setLineWidth(2);
    }
    setSize(size) {
        this.node.style.width = size + "px";
        this.node.style.height = size + "px";
        this.size = size;
    }
    setLineWidth(width) {
        this.UI.circle.style.borderWidth = `${width}px`;
    }
    scale(scale) {
        this.setSize(this.size * scale);
    }
}
exports.Loading = Loading;
class LoadingView {
    constructor(container) {
        this.container = container;
        this.el = document.createElement("div");
        this.mask = true;
        this.isRelative = false;
        this.loading = new Loading();
        this.el.style.top = "0";
        this.el.style.left = "0";
        this.el.style.right = "0";
        this.el.style.bottom = "0";
        this.el.style.display = "flex";
        this.el.style.alignItems = "center";
        this.el.style.justifyContent = "center";
        this.el.style.opacity = "0";
        this.el.style.transition = "all 700ms";
        this.el.appendChild(this.loading.node);
        return this;
    }
    scale(scale) {
        this.loading.scale(scale);
        return this;
    }
    withoutMask() {
        this.mask = false;
        return this;
    }
    withMask() {
        this.mask = true;
        return this;
    }
    relative() {
        this.isRelative = true;
        return this;
    }
    show() {
        if (!this.container.contains(this.el)) {
            this.container.appendChild(this.el);
        }
        this.el.style.position = this.isRelative && "relative" || "absolute";
        this.el.style.zIndex = "99999999";
        this.el.style.opacity = "1";
        if (this.mask) {
            this.el.style.background = "rgba(0,0,0,0.2)";
            this.el.style.opacity = "1";
            this.el.style.pointerEvents = "auto";
        }
        else {
            this.el.style.background = "rgba(0,0,0,0)";
            this.el.style.opacity = "1";
            this.el.style.pointerEvents = "none";
        }
        return this;
    }
    hide() {
        this.el.style.opacity = "0";
        this.el.style.pointerEvents = "none";
        this.container.removeChild(this.el);
        return this;
    }
    reset() {
        this.hide();
    }
}
exports.LoadingView = LoadingView;
//# sourceMappingURL=loading.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/web/src/ui/loading/loadingManager.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@branch-ts/web/src/ui/loading/loadingManager.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoadingHandle = exports.LoadingManager = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const loading_1 = __webpack_require__(/*! ./loading */ "./node_modules/@branch-ts/web/src/ui/loading/loading.js");
const LoadingManagerSymbol = Symbol.for("LeafWebappLibLoadingManager");
class LoadingManager {
    constructor(widget, option = {}) {
        this.warnTimeout = 1000 * 10;
        this.activeHandles = [];
        if (widget instanceof Leaf.Widget) {
            this.node = widget.node;
        }
        else {
            this.node = widget;
        }
        this.warnTimeout = option.warnTimeout || 1000 * 10;
    }
    static track(widget, option = {}) {
        let node;
        if (widget instanceof Leaf.Widget) {
            node = widget.node;
        }
        else {
            node = widget;
        }
        let manager = node[LoadingManagerSymbol] = node[LoadingManagerSymbol] || new LoadingManager(node, option);
        return manager;
    }
    begin() {
        this.show();
        const handle = new LoadingHandle(this);
        this.attachHandle(handle);
        this.activeHandles.push(handle);
        return handle;
    }
    end() {
        for (let handle of this.activeHandles) {
            this.detachHandle(handle);
        }
        this.activeHandles.length = 0;
        this.hide();
    }
    during(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.begin().during(fn);
        });
    }
    updateStates() {
        this.activeHandles = this.activeHandles.filter(handle => {
            if (handle.isLoading)
                return true;
            this.detachHandle(handle);
            return false;
        });
        if (this.activeHandles.length == 0) {
            this.hide();
        }
    }
    hide() {
        var _a;
        (_a = this.loadingView) === null || _a === void 0 ? void 0 : _a.hide();
    }
    show() {
        if (!this.loadingView) {
            this.loadingView = new loading_1.LoadingView(this.node);
        }
        this.loadingView.show();
    }
    attachHandle(handle) {
        handle.events.listenBy(this, "change", () => {
            this.updateStates();
        });
    }
    detachHandle(handle) {
        handle.events.stopListenBy(this);
    }
}
exports.LoadingManager = LoadingManager;
class LoadingHandle {
    constructor(manager) {
        this.manager = manager;
        this.events = new Leaf.EventEmitter();
        this.isLoading = true;
    }
    during(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield fn();
            }
            finally {
                this.end();
            }
        });
    }
    end() {
        this.isLoading = false;
        this.events.emit("change");
    }
}
exports.LoadingHandle = LoadingHandle;
//# sourceMappingURL=loadingManager.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/web/src/ui/popup/popupBehavior.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@branch-ts/web/src/ui/popup/popupBehavior.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PopupStack_container;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupStates = exports.BackButtonPopupCancelBehavior = exports.Mask = exports.PopupBehavior = exports.PopupStack = void 0;
//import { History } from "../component/history"
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
class PopupStack {
    bindHistory(history) {
        this.cancelBehavior = new BackButtonPopupCancelBehavior(history, this);
    }
    constructor(container) {
        this.index = 0;
        this.popups = [];
        this.step = 5;
        this.base = PopupStack.base;
        _PopupStack_container.set(this, void 0);
        this.events = new Leaf.EventEmitter();
        this.isChecking = false;
        this.lastCheckPopup = null;
        this.rect = null;
        this.resizeCheckInterval = 300;
        if (container) {
            __classPrivateFieldSet(this, _PopupStack_container, container, "f");
        }
    }
    get top() {
        return this.popups.at(-1);
    }
    get topSolid() {
        for (let i = this.popups.length - 1; i >= 0; i--) {
            const cur = this.popups[i];
            if (cur.isPassThrough)
                continue;
            return cur;
        }
        return null;
    }
    set container(el) {
        __classPrivateFieldSet(this, _PopupStack_container, el, "f");
    }
    get container() {
        return __classPrivateFieldGet(this, _PopupStack_container, "f") || document.body;
    }
    isElementInTopMostLayer(element) {
        if (this.popups.length == 0) {
            return true;
        }
        const behavior = this.popups[this.popups.length - 1];
        return behavior.widget.node == element || behavior.widget.node.contains(element);
    }
    add(p) {
        if (this.popups.indexOf(p) >= 0) {
            return false;
        }
        this.popups.push(p);
        this.index += this.step;
        p.zIndex = this.index + this.base;
        this.events.emit("push", p);
        this.events.emit("change");
        if (this.popups.length == 1) {
            this.checkResize();
        }
        return true;
    }
    remove(p) {
        let change = false;
        this.popups = this.popups.filter((old) => {
            if (old === p) {
                change = true;
                return false;
            }
            return true;
        });
        let last = this.popups[this.popups.length - 1];
        if (last) {
            this.index = last.zIndex - this.base;
        }
        else {
            this.index = 0;
        }
        this.events.emit("change");
        this.events.emit("remove", p);
        const top = this.top;
        if (top) {
            top.resize();
        }
        return change;
    }
    getStack() {
        return this.popups;
    }
    checkResize() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isChecking)
                return;
            this.isChecking = true;
            while (true) {
                const top = this.top;
                if (!top.autoResize) {
                    return;
                }
                if (top) {
                    if (top !== this.lastCheckPopup) {
                        this.lastCheckPopup = null;
                        this.rect = null;
                    }
                    this.lastCheckPopup = top;
                    const rect = top.widget.node.getBoundingClientRect();
                    if (!this.rect) {
                        this.rect = rect;
                    }
                    else {
                        if (this.rect.width != rect.width || this.rect.height != rect.height) {
                            this.rect = rect;
                            top.resize(rect);
                        }
                    }
                }
                else {
                    break;
                }
                yield new Promise(res => setTimeout(res, this.resizeCheckInterval));
            }
            this.isChecking = false;
        });
    }
    static get global() {
        return this.topStack;
    }
}
exports.PopupStack = PopupStack;
_PopupStack_container = new WeakMap();
PopupStack.base = 100000000;
PopupStack.topStackName = "topStack";
PopupStack.topStack = Leaf.ensureGlobal(PopupStack.topStackName, () => new PopupStack());
class PopupBehavior {
    constructor(widget, manager = PopupStack.global) {
        this.widget = widget;
        this.manager = manager;
        this.autoResize = false;
        this.isShow = false;
        this.events = new Leaf.EventEmitter();
        this.isBlocked = false;
        this.isPassThrough = false;
        this.states = new PopupStates(this);
        this.position = {
            x: 0,
            y: 0,
        };
        this.size = {
            x: 0,
            y: 0
        };
        this.shouldCenter = false;
        this.disableAutoPosition = false;
        this.animationDuration = 0;
        this.withMask();
    }
    withoutMask() {
        this.mask = null;
        return this;
    }
    get container() {
        return this.manager.container;
    }
    withMask(option = {}) {
        if (!this.mask) {
            this.mask = new Mask();
            this.mask.events.listenBy(this, "interact", () => {
                this.events.emit("interactWithMask");
                if (this.isBlocked)
                    return;
                this.hide();
            });
        }
        if (option.color)
            this.mask.color(option.color);
        if (option.opacity)
            this.mask.opacity(option.opacity);
        return this;
    }
    // will not auto hide when click mask
    shouldBlock() {
        if (!this.mask) {
            console.error("Blockmode only makesense when withMask is invokded");
        }
        this.isBlocked = true;
        return this;
    }
    whenShow(fn) {
        this.events.listenByOnce(this, "show", fn);
        return this;
    }
    whenHide(fn) {
        this.events.listenByOnce(this, "hide", fn);
        return this;
    }
    in() {
        return __awaiter(this, void 0, void 0, function* () {
            this.manager.add(this);
            let node = this.widget.node;
            node.style.position = "absolute";
            node.style.zIndex = this.zIndex.toString();
            //node.style.opacity = "0"
            let container = this.container || document.body;
            //node.style.transition = "all 200ms"
            container.appendChild(this.widget.node);
            if (this.shouldCenter) {
                this.applyCenter();
                //await new Promise(res => setTimeout(res, 50))
            }
            //node.style.opacity = "1"
        });
    }
    out() {
        this.manager.remove(this);
        if (this.mask) {
            if (this.mask.el.parentElement) {
                this.mask.el.parentElement.removeChild(this.mask.el);
            }
        }
        this.widget.node.parentElement.removeChild(this.widget.node);
    }
    appendMask() {
        if (this.mask) {
            this.mask.el.style.zIndex = `${this.zIndex - 1}`;
            if (!this.container)
                return;
            this.container.appendChild(this.mask.el);
        }
    }
    show() {
        return __awaiter(this, void 0, void 0, function* () {
            this.states.feed("show");
            yield this.waitShow();
            return true;
        });
    }
    hide() {
        return __awaiter(this, void 0, void 0, function* () {
            this.states.feed("hide");
            yield this.waitHide();
            return true;
        });
    }
    resize(rect) {
        if (!this.shouldCenter)
            return;
        this.applyCenter(rect);
    }
    center() {
        if (!this.shouldCenter) {
            this.shouldCenter = true;
        }
        if (!this.isShow)
            return this;
        this.applyCenter();
        return this;
    }
    applyCenter(rect) {
        this.render();
        return;
        rect = rect || this.widget.node.getBoundingClientRect();
        let container = this.container || document.body;
        let winWidth = container.offsetWidth;
        let winHeight = container.offsetHeight;
        let left = (winWidth - rect.width) / 2;
        let top = (winHeight - rect.height) / 2;
        this.position.x = left;
        this.position.y = top;
        this.render();
        return {
            x: left,
            y: top
        };
    }
    render() {
        if (this.disableAutoPosition)
            return;
        if (this.shouldCenter) {
            this.widget.node.style.left = "50%";
            this.widget.node.style.top = "50%";
            this.widget.node.style.transform = `translateX(-50%) translateY(-50%)`;
        }
        else {
            this.widget.node.style.top = this.position.y + "px";
            this.widget.node.style.left = this.position.x + "px";
            this.widget.node.style.transform = "none";
        }
        if (this.size) {
            if (this.size.x > 0) {
                this.widget.node.style.width = this.size.x + "px";
            }
            if (this.size.y > 0) {
                this.widget.node.style.height = this.size.y + "px";
            }
        }
    }
    waitShow() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.states.state == "show")
                return;
            yield this.events.wait("show");
        });
    }
    waitHide() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.states.state == "hide")
                return;
            yield this.events.wait("hide");
        });
    }
}
exports.PopupBehavior = PopupBehavior;
const img = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAGCAYAAAARx7TFAAAACXBIWXMAAAsTAAALEwEAmpwYAAAF8mlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiIHhtcDpDcmVhdGVEYXRlPSIyMDE5LTA4LTExVDE1OjUzOjEzKzA5OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxOS0wOC0xMVQxNTo1NDo1NSswOTowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxOS0wOC0xMVQxNTo1NDo1NSswOTowMCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNzkzNTg4MC0xZjllLTQzOGMtOGM4MS0zMWE4NGVjNzEyNTMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDdEQjkyN0FCNDI5MTFFOUFBM0VGQTlFNkEyMzc0QzgiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowN0RCOTI3QUI0MjkxMUU5QUEzRUZBOUU2QTIzNzRDOCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjA3REI5Mjc3QjQyOTExRTlBQTNFRkE5RTZBMjM3NEM4IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjA3REI5Mjc4QjQyOTExRTlBQTNFRkE5RTZBMjM3NEM4Ii8+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjA3OTM1ODgwLTFmOWUtNDM4Yy04YzgxLTMxYTg0ZWM3MTI1MyIgc3RFdnQ6d2hlbj0iMjAxOS0wOC0xMVQxNTo1NDo1NSswOTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+PlF1agAAAB5JREFUCB1j+P//PwMIA8F/XGy8knA2IVPgiuhnHQCKS32DUeb/MwAAAABJRU5ErkJggg==)";
class Mask {
    constructor() {
        this.el = document.createElement("div");
        this.events = new Leaf.EventEmitter();
        this.el.classList.add("mask");
        this.el.style.position = "absolute";
        this.el.style.left = "0";
        this.el.style.right = "0";
        this.el.style.top = "0";
        this.el.style.bottom = "0";
        //this.el.style.backdropFilter = "blur(6px)"
        this.el.addEventListener("click", (e) => {
            e.stopImmediatePropagation();
            e.preventDefault();
            this.events.emit("interact");
        });
        this.el.addEventListener("contextmenu", (e) => {
            e.stopImmediatePropagation();
            e.preventDefault();
            this.events.emit("interact");
        });
        this.el.style.backgroundImage = img;
        this.el.style.backgroundRepeat = "repeat";
        //this.el.style.boxShadow = "rgba(0, 0, 0, 0.4) 0px 0px 50px 40px inset"
        this.color("rgba(0,0,0,0.35)");
        this.opacity(1);
    }
    color(color) {
        this.el.style.backgroundColor = color;
    }
    opacity(o) {
        this.el.style.opacity = o.toString();
    }
}
exports.Mask = Mask;
class BackButtonPopupCancelBehavior {
    constructor(history, popups) {
        this.history = history;
        this.popups = popups;
        this.stack = [];
        this.popups.events.listenBy(this, "push", (popup) => {
            if (popup.isBlocked)
                return;
            this.history.registerBackButton(popup, () => {
                popup.hide();
            });
        });
        this.popups.events.listenBy(this, "remove", (popup) => {
            this.history.removeBackButton(popup);
        });
    }
}
exports.BackButtonPopupCancelBehavior = BackButtonPopupCancelBehavior;
class PopupStates extends Leaf.States {
    constructor(popup) {
        super();
        this.popup = popup;
        this.setState("init");
    }
    atInit() {
        this.consumeWhenAvailable("show", () => {
            this.setState("fadeIn");
        });
    }
    atHide() {
        this.consumeAll("hide");
        this.consumeAll("show");
        this.consumeWhenAvailable("show", () => {
            this.setState("fadeIn");
        });
        this.popup.out();
        this.popup.isShow = false;
        this.popup.events.emit("hide");
    }
    atShow() {
        this.consumeAll("hide");
        this.consumeAll("show");
        this.consumeWhenAvailableMergeToLast("hide", () => {
            this.setState("fadeOut");
        });
        this.popup.isShow = true;
        this.popup.events.emit("show");
    }
    atFadeIn(stale) {
        return __awaiter(this, void 0, void 0, function* () {
            this.consumeAll("hide");
            this.consumeAll("show");
            yield this.popup.in();
            this.popup.appendMask();
            yield new Promise(res => setTimeout(() => {
                this.popup.events.emit("fadeIn");
                res(null);
            }, 0));
            this.consumeWhenAvailableMergeToLast("hide", () => {
                this.setState("fadeOut");
            });
            yield new Promise(res => setTimeout(res, this.popup.animationDuration + 50));
            if (stale())
                return;
            this.setState("show");
        });
    }
    atFadeOut(stale) {
        this.consumeAll("hide");
        this.consumeAll("show");
        this.popup.events.emit("fadeOut");
        this.consumeWhenAvailableMergeToLast("show", () => {
            this.setState("fadeIn");
        });
        setTimeout(() => {
            if (stale())
                return;
            this.setState("hide");
        }, this.popup.animationDuration + 50);
    }
}
exports.PopupStates = PopupStates;
//# sourceMappingURL=popupBehavior.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/web/src/ui/window/windowBox.html.R.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@branch-ts/web/src/ui/window/windowBox.html.R.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.R = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
var R;
(function (R) {
    class WindowBox extends Leaf.GeneratedWidget {
        constructor() {
            super(function () {
                var _e = this._e.bind(this);
                var _t = this._t.bind(this);
                return _e("div", { "class": { "name": "class", "templates": [{ "type": "raw", "content": "window-box-997677 window-box " }, { "type": "value", "content": "withTitle", "reverse": false }] } }, [_t({ "templates": [{ "type": "raw", "content": "\n    " }] }), _e("div", { "class": { "name": "class", "templates": [{ "type": "raw", "content": "title" }] } }, [_t({ "templates": [{ "type": "raw", "content": "\n        " }, { "type": "value", "content": "title", "reverse": false }, { "type": "raw", "content": "\n        " }] }), _e("div", { "class": { "name": "class", "templates": [{ "type": "raw", "content": "close-button" }] }, "data-id": { "name": "data-id", "templates": [{ "type": "raw", "content": "closeButton" }] } }, []), _t({ "templates": [{ "type": "raw", "content": "\n    " }] })]), _t({ "templates": [{ "type": "raw", "content": "\n    " }] }), _e("div", { "class": { "name": "class", "templates": [{ "type": "raw", "content": "container scrollable" }] }, "data-id": { "name": "data-id", "templates": [{ "type": "raw", "content": "container" }] } }, []), _t({ "templates": [{ "type": "raw", "content": "\n" }] })]);
            }, "WindowBox", ["title", "withTitle"]);
            this.TestDatas = WindowBox.TestDatas;
            this.BindedLists = WindowBox.BindedLists;
            this.BindedWidgets = WindowBox.BindedWidgets;
            this.InitialData = WindowBox.InitialData;
            this.path = WindowBox.path;
            this.GeneratedConstructor = WindowBox;
            if (WindowBox.InitialData) {
                this.renderRecursive(WindowBox.InitialData);
            }
        }
    }
    WindowBox.TestDatas = [];
    WindowBox.BindedLists = [];
    WindowBox.BindedWidgets = [];
    WindowBox.path = "/ui/window/windowBox";
    WindowBox.widgetName = "WindowBox";
    WindowBox.InitialData = null;
    R.WindowBox = WindowBox;
    WindowBox["prototype"].widgetName = "WindowBox";
})(R || (exports.R = R = {}));
//# sourceMappingURL=windowBox.html.R.js.map

/***/ }),

/***/ "./node_modules/@branch-ts/web/src/ui/window/windowBox.js":
/*!****************************************************************!*\
  !*** ./node_modules/@branch-ts/web/src/ui/window/windowBox.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WindowBox = void 0;
const windowBox_html_R_1 = __webpack_require__(/*! ./windowBox.html.R */ "./node_modules/@branch-ts/web/src/ui/window/windowBox.html.R.js");
const popupBehavior_1 = __webpack_require__(/*! ../popup/popupBehavior */ "./node_modules/@branch-ts/web/src/ui/popup/popupBehavior.js");
class WindowBox extends windowBox_html_R_1.R.WindowBox {
    constructor(window) {
        super();
        this.window = window;
        this.asPopup = new popupBehavior_1.PopupBehavior(this).shouldBlock().center();
        this.setTitle("notification");
    }
    onClickCloseButton() {
        this.asPopup.hide();
    }
    setTitle(title) {
        if (!title) {
            this.VM.withTitle = false;
            this.VM.title = "";
        }
        else {
            this.VM.withTitle = true;
            this.VM.title = title;
        }
    }
}
exports.WindowBox = WindowBox;
//# sourceMappingURL=windowBox.js.map

/***/ }),

/***/ "./node_modules/@root-ts/criteria/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@root-ts/criteria/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./src/index */ "./node_modules/@root-ts/criteria/src/index.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@root-ts/criteria/src/criteria.js":
/*!********************************************************!*\
  !*** ./node_modules/@root-ts/criteria/src/criteria.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.push(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.push(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CriteriaBuilder = exports.TemplateBuilder = exports.Builder = exports.Checker = exports.Criteria = void 0;
/// <reference path="./spec/type.d.ts"/>
// 1. Convert to mongo key query in place.
// 2. Convert to mongo query (create)
// 3. Checker.test()
const Leaf = __webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js");
var Criteria;
(function (Criteria) {
    Criteria.supportedTypes = ["lte", "gte", "lt", "gt", "eq", "reg", "wildcard", "in", "all"];
    function isMatch(data) {
        if (data && data.type && Criteria.supportedTypes.indexOf(data.type) >= 0)
            return true;
        return false;
    }
    Criteria.isMatch = isMatch;
    function getOneEqualField(condition, field) {
        if (!condition)
            return null;
        if (!condition.ors)
            return null;
        for (let match of condition.ors) {
            if (!match.ands)
                continue;
            for (let cond of match.ands) {
                if (cond.path == field && !Leaf.Util.isEmptyValue(cond.value)) {
                    return cond.value;
                }
            }
        }
        return null;
    }
    Criteria.getOneEqualField = getOneEqualField;
    function isMatches(data) {
        if (data && data.ands && data.ands.every((item) => {
            if (isMatch(item))
                return true;
            return false;
        })) {
            return true;
        }
        return false;
    }
    Criteria.isMatches = isMatches;
    function getImpliedValue(match) {
        if (!match)
            return {};
        const result = {};
        for (let cond of match.ands) {
            if (cond.type == "eq") {
                if (typeof cond.value !== "undefined") {
                    result[cond.path] = cond.value;
                }
            }
        }
        return result;
    }
    Criteria.getImpliedValue = getImpliedValue;
    function isCriteria(data) {
        if (data && data.ors && data.ors.every((matches) => {
            return isMatches(matches);
        })) {
            return true;
        }
        return false;
    }
    Criteria.isCriteria = isCriteria;
    function isValid(data) {
        if (isMatch(data) || isMatches(data) || isCriteria(data)) {
            return true;
        }
        return false;
    }
    Criteria.isValid = isValid;
    function empty() {
        return {
            ors: [{
                    ands: [],
                }]
        };
    }
    Criteria.empty = empty;
    function realize(template, data) {
        if (!template)
            return null;
        const builder = new TemplateBuilder(template);
        return builder.fill(data);
    }
    Criteria.realize = realize;
    function or(criterias) {
        let result = Leaf.tag({
            ors: [],
        }, "criteria");
        if (criterias.length == 0) {
            return result;
        }
        criterias = criterias.filter(item => !!item);
        if (criterias.length == 0)
            return null;
        for (let item of criterias) {
            result.ors.push(...item.ors);
        }
        return result;
    }
    Criteria.or = or;
    function compact(criteria) {
        // throw new Error("Not implemented")
        return criteria;
    }
    Criteria.compact = compact;
    function isConflict(criteria) {
        // throw new Error("Not implemented")
        return false;
    }
    Criteria.isConflict = isConflict;
    function and(...criterias) {
        let tag = "criteria";
        // All null
        let allNone = true;
        for (let item of criterias) {
            if (item) {
                allNone = false;
            }
        }
        if (allNone)
            return null;
        criterias = criterias.filter(item => !!item);
        if (criterias.length == 0)
            return this.empty();
        if (criterias.length == 1)
            return criterias[0];
        let result = Leaf.tag({
            ors: []
        }, tag);
        let first = criterias.shift();
        let second = criterias.shift();
        for (let firstOr of first.ors) {
            for (let secondOr of second.ors) {
                result.ors.push({
                    ands: [...firstOr.ands, ...secondOr.ands]
                });
            }
        }
        return compact(and(result, ...criterias));
    }
    Criteria.and = and;
    function never() {
        return {
            ors: [
                Leaf.tag({
                    ands: []
                }, "matches")
            ]
        };
    }
    Criteria.never = never;
    function test(condition, data) {
        if (condition === null || typeof condition == "undefined")
            return true;
        if (isMatch(condition))
            return testMatch(condition, data);
        else if (isMatches(condition))
            return testMatches(condition, data);
        else if (isCriteria(condition))
            return testCriteria(condition, data);
        return false;
    }
    Criteria.test = test;
    function testCriteria(cri, data) {
        if (!cri)
            return true;
        for (let item of cri.ors) {
            if (testMatches(item, data))
                return true;
        }
        return false;
    }
    Criteria.testCriteria = testCriteria;
    function criteriaToValue(cri) {
        let obj = {};
        for (let ands of cri.ors) {
            for (let match of ands.ands) {
                if (!match.path) {
                    return match.value;
                }
                obj[match.path] = match.value;
            }
        }
        return Leaf.Util.reconstructObjectMap(obj);
    }
    Criteria.criteriaToValue = criteriaToValue;
    function testMatch(match, data) {
        let value;
        if (match.path) {
            value = Leaf.Util.getObjectValue(data, match.path || "");
        }
        else {
            value = data;
        }
        if (match.type == "eq") {
            return value === match.value;
        }
        else if (match.type == "lte") {
            return value <= match.value;
        }
        else if (match.type == "gte") {
            return value >= match.value;
        }
        else if (match.type == "lt") {
            return value < match.value;
        }
        else if (match.type == "gt") {
            return value > match.value;
        }
        else if (match.type == "all") {
            for (let todo of match.value) {
                if (typeof todo == "string") {
                    if (value.indexOf(todo) < 0)
                        return false;
                }
                else if (todo instanceof RegExp) {
                    if (!todo.test(value)) {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
            return true;
        }
        else if (match.type == "in") {
            for (let sub of match.value) {
                if (sub == value)
                    return true;
                if (sub instanceof RegExp) {
                    sub.lastIndex = 0;
                    if (sub.test(value))
                        return true;
                }
            }
            return match.value.indexOf(value) >= 0;
        }
        else if (match.type == "reg") {
            return match.value.test(value);
        }
        else if (match.type == "wildcard") {
            throw new Error("Wildcard not supported");
        }
        return false;
    }
    Criteria.testMatch = testMatch;
    function testMatches(matches, data) {
        for (let item of matches.ands) {
            if (!Criteria.testMatch(item, data)) {
                return false;
            }
        }
        return true;
    }
    Criteria.testMatches = testMatches;
    function subInplace(criteria, path) {
        for (let ors of criteria.ors) {
            for (let match of ors.ands) {
                if (!match.path)
                    match.path = path;
                else
                    match.path = path + "." + match.path;
            }
        }
    }
    Criteria.subInplace = subInplace;
})(Criteria = exports.Criteria || (exports.Criteria = {}));
class Checker {
    constructor(condition) {
        this.condition = condition;
    }
}
exports.Checker = Checker;
class Builder {
    constructor() {
        this.tb = new TemplateBuilder;
    }
    sub(path) {
        this.tb.seal();
        Criteria.subInplace(this.tb.criteria, path);
    }
    path(path) {
        this.tb.path(path);
        return this;
    }
    lt(value) {
        this.tb.lt(null, value);
        return this;
    }
    gt(value) {
        this.tb.gt(null, value);
        return this;
    }
    lte(value) {
        this.tb.lte(null, value);
        return this;
    }
    gte(value) {
        this.tb.gte(null, value);
        return this;
    }
    eq(value) {
        this.tb.eq(null, value);
        return this;
    }
    all(value) {
        this.tb.all(null, value);
        return this;
    }
    in(value) {
        this.tb.in(null, value);
        return this;
    }
    reg(value) {
        this.tb.reg(null, value);
        return this;
    }
    build() {
        this.tb.seal();
        let criteria = Leaf.Util.clone(this.tb.criteria);
        return Leaf.tag(criteria, "criteria");
    }
    clone() {
        const builder = new Builder();
        builder.tb = this.tb.clone();
        return builder;
    }
}
exports.Builder = Builder;
function prepare(target, context) {
    let fn = target;
    return function (ref, value) {
        let obj = this;
        if (obj.isSealed)
            throw new Error("Can't modify criteria after sealed");
        obj.ensureCurrentConditions();
        let result = fn.apply(this, arguments);
        if (!result.path && result.reference) {
            result.path = result.reference;
        }
        obj.currentOptional = false;
        return result;
    };
}
let TemplateBuilder = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _gt_decorators;
    let _lt_decorators;
    let _lte_decorators;
    let _gte_decorators;
    let _eq_decorators;
    let _all_decorators;
    let _in_decorators;
    let _reg_decorators;
    let _wildcard_decorators;
    return _a = class TemplateBuilder {
            constructor(criteria = {
                ors: []
            }) {
                this.criteria = (__runInitializers(this, _instanceExtraInitializers), criteria);
                this.currentPath = null;
                this.currentConditions = null;
                this.currentOptional = false;
                this.isSealed = false;
                this.numericType = ["lt", "gt", "lte", "gte"];
            }
            clone() {
                const tb = new TemplateBuilder();
                tb.currentPath = this.currentPath;
                tb.currentConditions = Leaf.Util.clone(this.currentConditions);
                tb.currentOptional = this.currentOptional;
                tb.criteria = Leaf.Util.clone(this.criteria);
                return tb;
            }
            optional() {
                this.currentOptional = true;
                return this;
            }
            getTemplate() {
                this.seal();
                return this.criteria;
            }
            ensureCurrentConditions() {
                if (!this.currentConditions) {
                    this.currentConditions = this.createEmptyConditions();
                }
            }
            createEmptyConditions() {
                return {
                    ands: []
                };
            }
            isEmptyMatches(conditions) {
                return !conditions || !conditions.ands || conditions.ands.length == 0;
            }
            path(path) {
                this.currentPath = path;
                return this;
            }
            gt(reference, value) {
                this.currentConditions.ands.push({
                    path: this.currentPath,
                    type: "gt",
                    reference,
                    value,
                    optional: this.currentOptional
                });
                return this;
            }
            lt(reference, value) {
                this.currentConditions.ands.push({
                    path: this.currentPath,
                    type: "lt",
                    reference,
                    value,
                    optional: this.currentOptional
                });
                return this;
            }
            lte(reference, value) {
                this.currentConditions.ands.push({
                    path: this.currentPath,
                    type: "lte",
                    reference,
                    value,
                    optional: this.currentOptional
                });
                return this;
            }
            gte(reference, value) {
                this.currentConditions.ands.push({
                    path: this.currentPath,
                    type: "gte",
                    reference,
                    value,
                    optional: this.currentOptional
                });
                return this;
            }
            eq(reference, value) {
                this.currentConditions.ands.push({
                    path: this.currentPath,
                    type: "eq",
                    reference,
                    value,
                    optional: this.currentOptional
                });
                return this;
            }
            all(reference, value) {
                this.currentConditions.ands.push({
                    path: this.currentPath,
                    type: "all",
                    reference,
                    value,
                    optional: this.currentOptional
                });
                return this;
            }
            in(reference, value) {
                this.currentConditions.ands.push({
                    path: this.currentPath,
                    type: "in",
                    reference,
                    value,
                    optional: this.currentOptional
                });
                return this;
            }
            or() {
                if (this.currentConditions)
                    this.criteria.ors.push(this.currentConditions);
                this.currentConditions = null;
            }
            reg(reference, value) {
                this.currentConditions.ands.push({
                    path: this.currentPath,
                    type: "reg",
                    reference,
                    value,
                    optional: this.currentOptional
                });
                return this;
            }
            wildcard() {
                throw new Error("Not implemented");
            }
            seal() {
                if (this.currentConditions)
                    this.criteria.ors.push(this.currentConditions);
                this.currentConditions = null;
                this.isSealed = true;
                return this;
            }
            build(obj) {
                return this.fill(obj);
            }
            fill(obj) {
                if (!this.isSealed) {
                    this.seal();
                }
                let criteria = Leaf.Util.clone(this.criteria);
                if (!obj) {
                    return criteria;
                }
                criteria.ors = criteria.ors.filter(conds => {
                    conds.ands.map(cond => {
                        if (cond.reference) {
                            let value = Leaf.Util.getObjectValue(obj, cond.reference);
                            if (!Leaf.Util.isEmptyValue(value)) {
                                if (this.numericType.indexOf(cond.type) >= 0 && typeof value !== "number") {
                                    throw new Error(`Invalid condition: ${cond.reference} must be a number`);
                                }
                                else if (cond.type == "reg" && !(value instanceof RegExp)) {
                                    throw new Error(`Invalid condition: ${cond.reference} must be a RegExp`);
                                }
                                else if (cond.type == "in" && !(Array.isArray(value))) {
                                    value = [value];
                                }
                            }
                            if (!Leaf.Util.isEmptyValue(value)) {
                                cond.value = value;
                            }
                            if (cond.type == "eq" && Array.isArray(cond.value)) {
                                return {
                                    type: "in",
                                    value: cond.value,
                                    optional: cond.optional
                                };
                            }
                        }
                        if (Leaf.Util.isEmptyValue(cond.value)) {
                            if (cond.optional) {
                                return null;
                            }
                            console.error("Invalid condition", cond);
                            throw new Error(`Critical condition ${cond.reference} of type $${cond.type} missing value`);
                        }
                        return cond;
                    }).filter(item => !!item);
                    if (conds.ands.length == 0)
                        return false;
                    return true;
                });
                return criteria;
            }
        },
        (() => {
            _gt_decorators = [prepare];
            _lt_decorators = [prepare];
            _lte_decorators = [prepare];
            _gte_decorators = [prepare];
            _eq_decorators = [prepare];
            _all_decorators = [prepare];
            _in_decorators = [prepare];
            _reg_decorators = [prepare];
            _wildcard_decorators = [prepare];
            __esDecorate(_a, null, _gt_decorators, { kind: "method", name: "gt", static: false, private: false, access: { has: obj => "gt" in obj, get: obj => obj.gt } }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _lt_decorators, { kind: "method", name: "lt", static: false, private: false, access: { has: obj => "lt" in obj, get: obj => obj.lt } }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _lte_decorators, { kind: "method", name: "lte", static: false, private: false, access: { has: obj => "lte" in obj, get: obj => obj.lte } }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _gte_decorators, { kind: "method", name: "gte", static: false, private: false, access: { has: obj => "gte" in obj, get: obj => obj.gte } }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _eq_decorators, { kind: "method", name: "eq", static: false, private: false, access: { has: obj => "eq" in obj, get: obj => obj.eq } }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _all_decorators, { kind: "method", name: "all", static: false, private: false, access: { has: obj => "all" in obj, get: obj => obj.all } }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _in_decorators, { kind: "method", name: "in", static: false, private: false, access: { has: obj => "in" in obj, get: obj => obj.in } }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _reg_decorators, { kind: "method", name: "reg", static: false, private: false, access: { has: obj => "reg" in obj, get: obj => obj.reg } }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _wildcard_decorators, { kind: "method", name: "wildcard", static: false, private: false, access: { has: obj => "wildcard" in obj, get: obj => obj.wildcard } }, null, _instanceExtraInitializers);
        })(),
        _a;
})();
exports.TemplateBuilder = TemplateBuilder;
class CriteriaBuilder extends Builder {
}
exports.CriteriaBuilder = CriteriaBuilder;
//# sourceMappingURL=criteria.js.map

/***/ }),

/***/ "./node_modules/@root-ts/criteria/src/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@root-ts/criteria/src/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./criteria */ "./node_modules/@root-ts/criteria/src/criteria.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
const ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/leaf-ts/dist/leaf.js":
/*!*******************************************!*\
  !*** ./node_modules/leaf-ts/dist/leaf.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Leaf;
(function (Leaf) {
    let gl = {};
    const GlobalName = "LEAF_GLOBAL";
    if (typeof window !== "undefined") {
        gl = window[GlobalName] = window[GlobalName] || {};
    }
    else if (typeof globalThis !== "undefined") {
        gl = globalThis[GlobalName] = globalThis[GlobalName] || {};
    }
    else if (typeof __webpack_require__.g !== "undefined") {
        gl = __webpack_require__.g[GlobalName] = __webpack_require__.g[GlobalName] || {};
    }
    else if (typeof self !== "undefined") {
        gl = self[GlobalName] = self[GlobalName] || {};
    }
    Leaf.Global = gl;
    function ensureGlobal(name, create) {
        Leaf.Global[name] = Leaf.Global[name] || create();
        return Leaf.Global[name];
    }
    Leaf.ensureGlobal = ensureGlobal;
})(Leaf || (Leaf = {}));
/// <reference path="leaf.ts" />
var Leaf;
(function (Leaf) {
    class ErrorDoc {
        constructor() {
            this.errors = {};
        }
        static create() {
            return new ErrorDoc();
        }
        static build(info) {
            let result = {};
            for (let name in info) {
                result[name] = createError(name, Error, info[name] || {});
            }
            return result;
        }
        define(name, base, defaultProperty) {
            let Base = Error;
            if (typeof base === "string") {
                let _ = this[base];
                if (typeof _ === "function") {
                    Base = _;
                }
            }
            else if (typeof base === "function") {
                Base = base;
            }
            else if (base) {
                console.warn("Unknown base error", base);
            }
            let E = createError(name, Base, defaultProperty);
            this.errors[name] = E;
            return this;
        }
        generate() {
            return this.errors;
        }
    }
    Leaf.ErrorDoc = ErrorDoc;
    function createError(name, Base, defaultProperty) {
        return class E extends Base {
            constructor(message, detail) {
                super(message, detail);
                this.detail = null;
                this.via = null;
                this.toJSON = null;
                if (typeof message === "object") {
                    if (!detail) {
                        detail = message;
                        message = name;
                    }
                    else {
                        try {
                            message = JSON.stringify(message, null, 4);
                        }
                        catch (e) {
                            message = name + "Warning: recursive error property" + e.toString();
                        }
                    }
                }
                this.name = name;
                this.message = message || name;
                if (typeof defaultProperty === "function") {
                    let _ = Base;
                    Base = defaultProperty;
                    defaultProperty = _;
                }
                if (!detail)
                    detail = {};
                if (!defaultProperty)
                    defaultProperty = {};
                for (let prop in defaultProperty) {
                    this[prop] = defaultProperty[prop];
                }
                if (!this.detail) {
                    this.detail = {};
                }
                for (let prop in detail) {
                    this.detail[prop] = detail[prop];
                }
                for (let prop in detail) {
                    this[prop] = detail[prop];
                }
                if (detail.via) {
                    this.via = detail.via;
                }
                this.toJSON = () => {
                    let result = {};
                    for (let prop in this) {
                        if (this.hasOwnProperty(prop) && typeof this[prop] !== "function") {
                            result[prop] = this[prop];
                        }
                    }
                    if (this.message) {
                        result["message"] = this.message;
                    }
                    result["name"] = this.name;
                    return result;
                };
            }
        };
        //let E = function (message: string, detail: any) {
        //    if (typeof message === "object") {
        //        if (!detail) {
        //            detail = message
        //            message = name
        //        } else {
        //            try {
        //                message = JSON.stringify(message, null, 4)
        //            } catch (e) {
        //                message = name + "Warning: recursive error property" + e.toString()
        //            }
        //        }
        //    }
        //    this.name = name
        //    this.message = message || name
        //    if (typeof defaultProperty === "function") {
        //        let _ = base
        //        base = defaultProperty
        //        defaultProperty = _
        //    }
        //    if (!detail) detail = {}
        //    if (!defaultProperty) defaultProperty = {}
        //    for (let prop in defaultProperty) {
        //        this[prop] = defaultProperty[prop]
        //    }
        //    if (!this.detail) {
        //        this.detail = {}
        //    }
        //    for (let prop in detail) {
        //        this.detail[prop] = detail[prop]
        //    }
        //    if (detail.via) {
        //        this.via = detail.via
        //    }
        //}
    }
    Leaf.createError = createError;
    Leaf.Errors = ErrorDoc.create()
        .define("Timeout")
        .define("Abort")
        .define("IOError")
        .define("NetworkError")
        .define("LockError")
        .generate();
})(Leaf || (Leaf = {}));
var Leaf;
(function (Leaf) {
    let Tagged;
    (function (Tagged) {
        Tagged.tagSymbol = Leaf.ensureGlobal("LeafTagSymbol", () => Symbol.for("Leaf.Tag"));
        function tag(obj, name) {
            obj[Tagged.tagSymbol] = Symbol.for(name);
            return obj;
        }
        Tagged.tag = tag;
        function tagOf(obj) {
            if (!obj)
                return null;
            return Symbol.keyFor(obj[Tagged.tagSymbol]);
        }
        Tagged.tagOf = tagOf;
    })(Tagged = Leaf.Tagged || (Leaf.Tagged = {}));
    Leaf.tag = Tagged.tag;
    Leaf.tagOf = Tagged.tagOf;
})(Leaf || (Leaf = {}));
var Leaf;
(function (Leaf) {
    class Property {
        static define(who, name, def) {
            let cache = {};
            if (who[name])
                cache.value = who[name];
            if (def.value)
                cache.value = def.value;
            let getFn = (cache) => {
                return cache.value;
            };
            let setFn = (value, cache) => {
                cache.value = value;
                return cache.value;
            };
            let getIt = def.get || getFn;
            let setIt = def.set || setFn;
            Object.defineProperty(who, name, {
                get: () => {
                    return getIt(cache);
                },
                set: (v) => {
                    return setIt(v, cache);
                },
                enumerable: def.enumerable || false
            });
            return def.value || null;
        }
        // For IE using with will cause problem
        static withProps(who) {
            return new WithProperty(who);
        }
    }
    Leaf.Property = Property;
    class WithProperty {
        constructor(who) {
            this.who = who;
        }
        define(name, def) {
            Property.define(this.who, name, def);
            return this;
        }
    }
    Leaf.WithProperty = WithProperty;
})(Leaf || (Leaf = {}));
var Leaf;
(function (Leaf) {
    class Logger {
        static debug(...args) {
            console.error(...args);
        }
        static error(...args) {
            console.error(...args);
        }
        static log(...args) {
            console.log(...args);
        }
        static line(str) {
            let stdout = process.stdout;
            stdout.clearLine();
            stdout.cursorTo(0);
            stdout.write(str);
        }
        static lineEnd() {
            let stdout = process.stdout;
            stdout.write("\n");
        }
        static trace() {
            console.trace();
        }
    }
    Leaf.Logger = Logger;
})(Leaf || (Leaf = {}));
var Leaf;
(function (Leaf) {
    class Serializer {
        constructor() {
            this.typeKey = "_$t";
            this.dataKey = "_$d";
            this.typeMap = {
                "date": {
                    Cons: Date,
                    fromType: (date) => {
                        return date.toString();
                    },
                    toType: (str) => {
                        return new Date(str);
                    }
                },
                "reg": {
                    Cons: RegExp,
                    fromType: (reg) => {
                        return {
                            s: reg.source,
                            g: reg.global,
                            i: reg.ignoreCase,
                            m: reg.multiline
                        };
                    },
                    toType: (data) => {
                        let mod = `${data.g && "g"}${data.m && "m"}${data.i && "i"}`;
                        return new RegExp(data.s, mod);
                    }
                },
                "error": {
                    Cons: Error,
                    fromType: (error) => {
                        let result = {};
                        for (let key in error) {
                            if (typeof error[key] !== "function") {
                                if (error.hasOwnProperty(key)) {
                                    result[key] = error[key];
                                }
                            }
                        }
                        result["name"] = error.name;
                        result["message"] = error.message;
                        result["stack"] = error.stack;
                        return result;
                    },
                    toType: (data) => {
                        if (!data) {
                            return data;
                        }
                        let error = new Error(data.message);
                        for (let prop in data) {
                            error[prop] = data[prop];
                        }
                        return error;
                    }
                }
            };
        }
        tokenize(data) {
            if (!data)
                return data;
            if (Array.isArray(data)) {
                return data.map(item => this.tokenize(item));
            }
            if (typeof data !== "object")
                return data;
            for (let type in this.typeMap) {
                let info = this.typeMap[type];
                if (data instanceof info.Cons) {
                    return {
                        [this.typeKey]: type,
                        [this.dataKey]: info.fromType(data)
                    };
                }
            }
            let result = {};
            for (let k in data) {
                result[k] = this.tokenize(data[k]);
            }
            return result;
        }
        detokenize(v) {
            if (!v)
                return v;
            if (Array.isArray(v)) {
                return v.map(item => this.detokenize(item));
            }
            if (typeof v !== "object")
                return v;
            if (!v[this.typeKey]) {
                let result = {};
                for (let k in v) {
                    result[k] = this.detokenize(v[k]);
                }
                return result;
            }
            let info = this.typeMap[v[this.typeKey]];
            if (!info)
                return v;
            return info.toType(v[this.dataKey]);
        }
        serialize(data) {
            return JSON.stringify(this.tokenize(data));
        }
        deserialize(data) {
            return this.detokenize(JSON.parse(data));
        }
        register(type, config) {
            this.typeMap[type] = config;
        }
        static getDefault() {
            if (!this.defaultSerializer)
                this.defaultSerializer = new Serializer();
            return this.defaultSerializer;
        }
    }
    Leaf.Serializer = Serializer;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts"/>
var Leaf;
(function (Leaf) {
    let reg = /{{([a-zA-Z0-9._]+)(:[^}]*)?}}/g;
    let singleReg = /^{{([a-zA-Z0-9._]+)(:[^}]*)?}}$/;
    function renderString(str, actions) {
        if (singleReg.test(str)) {
            let literal = str.slice(2, -2);
            let [name, content] = literal.split(":");
            let action = Leaf.Util.getObjectValue(actions, name);
            if (typeof action === "function") {
                let fn = action;
                return fn(content);
            }
            else if (action) {
                return action;
            }
        }
        reg.lastIndex = 0;
        return str.replace(reg, (match, name, content) => {
            if (content) {
                content = content.slice(1) || null;
            }
            const action = Leaf.Util.getObjectValue(actions, name);
            if (typeof action === "function") {
                let fn = action;
                return fn(content);
            }
            else if (typeof action === "string" || typeof action === "number") {
                return action.toString();
            }
            else {
                return match;
            }
        });
    }
    Leaf.renderString = renderString;
    function render(obj, actions) {
        if (typeof obj === "string") {
            return renderString(obj, actions);
        }
        else if (obj instanceof String) {
            return renderString(obj.toString(), actions);
        }
        else if (!obj) {
            return obj;
        }
        else if (Array.isArray(obj)) {
            return obj.map((item) => {
                return render(item, actions);
            });
        }
        else if (obj instanceof Date) {
            return obj;
        }
        else if (typeof obj === "object") {
            let result = {};
            for (let key in obj) {
                let value = render(obj[key], actions);
                result[key] = value;
            }
            return result;
        }
        return obj;
    }
    Leaf.render = render;
})(Leaf || (Leaf = {}));
var Leaf;
(function (Leaf) {
    // UTC it's self is not aware of leap second.
    // Most of our job are second level, so a one second offset is OK.
    // Time generator just ignore that 1 secon since time doesn't change.
    // The fact is that, at the time pass leap second, we will have 59:59 ~00:00 actually take 2 second
    // or during the first 1hour, every second is 1/3600 longer, sort of remapping. it's mostly OK.
    // except that during first less graceful solution, we will double the things happend during the next
    // logical second, since it's actually 2 physical second. The latter approach spread 1second physical insertion
    // into 3600 second each.
    // What ever, in most case, we don't care about leap second
    class Time {
        static humanTime(time) {
            return new Date(time).toLocaleString();
        }
        static humanDuration(time, fix = 2) {
            let sec = 1000;
            let min = sec * 60;
            let hour = min * 60;
            let day = hour * 24;
            if (time < min) {
                return (time / sec).toFixed(fix) + "s";
            }
            if (time < hour) {
                return (time / min).toFixed(fix) + "m";
            }
            if (time < day) {
                return (time / hour).toFixed(fix) + `h`;
            }
            return (time / day).toFixed(fix) + `d`;
        }
        // We always respect the getHours() of the date as it's in the specified zone
        // say, date is actually 2018-01-01 GMT0
        // We specify zone of GMT +8.
        // Then the Time object is logically 2018-01-01 08:00:00 GMT0 which is also 2018-01-01 00:00:00 GTM +8
        // despite the fact that the date is actually 2018-01-01 00:00:00 GMT 0
        //
        constructor(date = new Date, zone = Time.defaultTimeZone) {
            this.date = date;
            this.zone = zone;
            this.shift = new Date().getTimezoneOffset() * 60 * 1000
                // utc shift to target timezone
                + this.zone * 60 * 60 * 1000;
            this.ref = new Date(this.date.getTime() + this.shift);
        }
        getZoneFullYear() {
            return this.ref.getFullYear();
        }
        getZoneMonth() {
            return this.ref.getMonth();
        }
        getZoneDate() {
            return this.ref.getDate();
        }
        getTime() {
            return this.date.getTime();
        }
        getZoneDay() {
            return this.ref.getDay();
        }
        getZoneHours() {
            return this.ref.getHours();
        }
        getZoneMinutes() {
            return this.ref.getMinutes();
        }
        getZoneSeconds() {
            return this.ref.getSeconds();
        }
        thisZoneYearStart(durationYear = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let years = Time.diffYear(this.ref, visualZero.ref);
            let left = years % durationYear;
            let pass = years - left;
            let newRef = new Date(visualZero.ref);
            newRef.setFullYear(visualZero.ref.getFullYear() + pass);
            return Time.createTime(this.zone, newRef);
        }
        thisZoneMonthStart(durationMonth = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let years = Time.diffYear(this.ref, visualZero.ref);
            let month = Time.diffMonth(this.ref, visualZero.ref);
            if (month < 0)
                month += 12;
            let all = years * 12 + month;
            let left = all % durationMonth;
            let passMonth = all - left;
            let newRef = new Date(visualZero.ref);
            newRef.setMonth(visualZero.ref.getMonth() + passMonth);
            return Time.createTime(this.zone, newRef);
        }
        thisZoneWeekStart(durationWeek = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * 60 * 60 * 24 * 7 * durationWeek;
            let week = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setDate(newRef.getDate() + week * 7 * durationWeek);
            return Time.createTime(this.zone, newRef);
        }
        thisZoneDayStart(durationDay = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * 60 * 60 * 24 * durationDay;
            let days = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setDate(newRef.getDate() + days * durationDay);
            return Time.createTime(this.zone, newRef);
        }
        thisZoneHourStart(durationHour = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * 60 * 60 * durationHour;
            let hours = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setHours(newRef.getHours() + hours * durationHour);
            return Time.createTime(this.zone, newRef);
        }
        thisZoneMinuteStart(durationMinute = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * 60 * durationMinute;
            let minutes = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setMinutes(newRef.getMinutes() + minutes * durationMinute);
            return Time.createTime(this.zone, newRef);
        }
        thisZoneSecondStart(durationSecond = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * durationSecond;
            let seconds = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setSeconds(newRef.getSeconds() + seconds * durationSecond);
            return Time.createTime(this.zone, newRef);
        }
        // visual zero is start of the range loop
        thisZoneRangeStart(duration, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let start = visualZero.date;
            let pass = Math.floor((this.date.getTime() - start.getTime()) / duration) * duration;
            return new Time(new Date(start.getTime() + pass), this.zone);
        }
        prevZoneYearStart(durationYear = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let years = Time.diffYear(this.ref, visualZero.ref);
            let left = years % durationYear;
            let pass = years - left;
            let newRef = new Date(visualZero.ref);
            newRef.setFullYear(visualZero.ref.getFullYear() + pass - durationYear);
            return Time.createTime(this.zone, newRef);
        }
        prevZoneMonthStart(durationMonth = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let years = Time.diffYear(this.ref, visualZero.ref);
            let month = Time.diffMonth(this.ref, visualZero.ref);
            if (month < 0)
                month += 12;
            let all = years * 12 + month;
            let left = all % durationMonth;
            let passMonth = all - left;
            let newRef = new Date(visualZero.ref);
            newRef.setMonth(visualZero.ref.getMonth() + passMonth - durationMonth);
            return Time.createTime(this.zone, newRef);
        }
        prevZoneWeekStart(durationWeek = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * 60 * 60 * 24 * 7 * durationWeek;
            let week = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setDate(newRef.getDate() + week * 7 * durationWeek - durationWeek * 7);
            return Time.createTime(this.zone, newRef);
        }
        prevZoneDayStart(durationDay = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * 60 * 60 * 24 * durationDay;
            let days = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setDate(newRef.getDate() + days * durationDay - durationDay);
            return Time.createTime(this.zone, newRef);
        }
        prevZoneHourStart(durationHour = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * 60 * 60 * durationHour;
            let hours = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setHours(newRef.getHours() + hours * durationHour - durationHour);
            return Time.createTime(this.zone, newRef);
        }
        prevZoneMinuteStart(durationMinute = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * 60 * durationMinute;
            let minutes = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setMinutes(newRef.getMinutes() + minutes * durationMinute - durationMinute);
            return Time.createTime(this.zone, newRef);
        }
        prevZoneSecondStart(durationSecond = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * durationSecond;
            let seconds = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setSeconds(newRef.getSeconds() + seconds * durationSecond - durationSecond);
            return Time.createTime(this.zone, newRef);
        }
        // visual zero is start of the range loop
        prevZoneRangeStart(duration = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let start = visualZero.date;
            let pass = Math.floor((this.date.getTime() - visualZero.date.getTime()) / duration) * duration;
            return new Time(new Date(start.getTime() + pass - duration), this.zone);
        }
        nextZoneYearStart(durationYear = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let years = Time.diffYear(this.ref, visualZero.ref);
            let left = years % durationYear;
            let pass = years - left;
            let newRef = new Date(visualZero.ref);
            newRef.setFullYear(visualZero.ref.getFullYear() + pass + durationYear);
            return Time.createTime(this.zone, newRef);
        }
        nextZoneMonthStart(durationMonth = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let years = Time.diffYear(this.ref, visualZero.ref);
            let month = Time.diffMonth(this.ref, visualZero.ref);
            if (month < 0)
                month += 12;
            let all = years * 12 + month;
            let left = all % durationMonth;
            let passMonth = all - left;
            let newRef = new Date(visualZero.ref);
            newRef.setMonth(visualZero.ref.getMonth() + passMonth + durationMonth);
            return Time.createTime(this.zone, newRef);
        }
        nextZoneWeekStart(durationWeek = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * 60 * 60 * 24 * 7 * durationWeek;
            let week = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setDate(newRef.getDate() + week * 7 * durationWeek + durationWeek * 7);
            return Time.createTime(this.zone, newRef);
        }
        nextZoneDayStart(durationDay = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * 60 * 60 * 24 * durationDay;
            let days = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setDate(newRef.getDate() + days * durationDay + durationDay);
            return Time.createTime(this.zone, newRef);
        }
        nextZoneHourStart(durationHour = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * 60 * 60 * durationHour;
            let hours = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setHours(newRef.getHours() + hours * durationHour + durationHour);
            return Time.createTime(this.zone, newRef);
        }
        nextZoneMinuteStart(durationMinute = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * 60 * durationMinute;
            let minutes = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setMinutes(newRef.getMinutes() + minutes * durationMinute + durationMinute);
            return Time.createTime(this.zone, newRef);
        }
        nextZoneSecondStart(durationSecond = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let delta = this.date.getTime() - visualZero.date.getTime();
            let step = 1000 * durationSecond;
            let seconds = Math.floor(delta / step);
            let newRef = new Date(visualZero.ref);
            newRef.setSeconds(newRef.getSeconds() + seconds * durationSecond + durationSecond);
            return Time.createTime(this.zone, newRef);
        }
        // visual zero is start of the range loop
        nextZoneRangeStart(duration = 1, visualZero = Time.createTime(this.zone, Time.systemUTCStartRef)) {
            let start = visualZero.date;
            let pass = Math.floor((this.date.getTime() - visualZero.date.getTime()) / duration) * duration;
            return new Time(new Date(start.getTime() + pass + duration), this.zone);
        }
        static createTime(zone, ...args) {
            let date;
            if (args[0] instanceof Date) {
                date = args[0];
            }
            else {
                // now in current time zone we looks good
                date = new Date(args[0], args[1], args[2], args[3], args[4], args[5]);
            }
            // shift to UTC
            let shift = date.getTimezoneOffset() * 60 * 1000
                // shift to expected zone
                + zone * 60 * 60 * 1000;
            let shifted = new Date(date.getTime() - shift);
            // now shifted date if present in required time zone has expected date
            return new Time(new Date(shifted), zone);
        }
        static diffYear(a, b) {
            return this.diff(a, b, 0);
        }
        static diffMonth(a, b) {
            return this.diff(a, b, 1);
        }
        static diffRefDate(a, b) {
            return this.diff(a, b, 2);
        }
        static diffHours(a, b) {
            return this.diff(a, b, 3);
        }
        static diffMinutes(a, b) {
            return this.diff(a, b, 3);
        }
        //  Edge case of leap month is not considerered
        // That is if we compare 2004-02-29 and 2005-02-28 we get 11 month and only 2005-03-01 ~2005-03-28 we get 12 month
        // And passing 2004-02-29 by one year, we may get 2005-03-01, I think that's acceptable OK in most situation
        static diff(a, b, offset = 0) {
            let arrs = [a, b].map(item => [item.getFullYear(), item.getMonth(), item.getDate(), item.getHours(), item.getMinutes(), item.getSeconds(), item.getTime() % 1000]).map(item => item.slice(offset));
            let diff = arrs[0][0] - arrs[1][0];
            for (let i = 1; i < arrs[0].length; i++) {
                let subDiff = arrs[0][i] - arrs[1][i];
                if (subDiff > 0) {
                    return diff;
                }
                else if (subDiff < 0) {
                    return diff - 1;
                }
                else {
                    continue;
                }
            }
            return diff;
        }
    }
    //static defaultTimeZone = -new Date().getTimezoneOffset() / 60
    // we use UTC0 by default
    Time.defaultTimeZone = -new Date().getTimezoneOffset() / 60;
    // we start from 2000-01-01 at time zone
    Time.systemUTCStartRef = new Date(2000, 0);
    Leaf.Time = Time;
    class MinimumPulseGenerator {
        constructor() {
            this.items = [];
            this.interval = 50;
            this.timer = null;
        }
        add(item) {
            this.items.push(item);
            if (this.items.length == 1) {
                this.tick();
            }
        }
        remove(item) {
            this.items = this.items.filter(old => item !== old);
            if (this.items.length == 0) {
                clearTimeout(this.timer);
            }
        }
        tick() {
            let cur = Math.round(Date.now() / this.interval) * this.interval;
            let next = cur + this.interval;
            let interval = next - Date.now();
            clearTimeout(this.timer);
            this.timer = setTimeout(() => {
                this.tick();
            }, interval);
            this.trigger();
        }
        trigger() {
            let now = new Date();
            for (let item of this.items) {
                item.check(now);
            }
        }
    }
    Leaf.MinimumPulseGenerator = MinimumPulseGenerator;
    class FixedTimeGenerator {
        // Always use UTC:+0 by default
        // When `period pervided as number`
        constructor(period, duration, zone, start = Time.createTime(zone, new Date(2000, 0))) {
            this.period = period;
            this.duration = duration;
            this.zone = zone;
            this.start = start;
            this.isStart = false;
            this.currentTime = 0;
            this.nextTime = this.next();
            this.events = new Leaf.EventEmitter();
            while (this.zone > 12) {
                this.zone -= 24;
            }
            while (this.zone < -11) {
                this.zone += 24;
            }
        }
        toJSON() {
            return { currentTime: this.currentTime };
        }
        fromJSON(json) {
            this.currentTime = json.currentTime || 0;
        }
        enableAutoCounting() {
            if (this.isStart)
                return;
            this.isStart = true;
            FixedTimeGenerator.minimum.add(this);
            return this;
        }
        disableAutoCounting() {
            if (!this.isStart)
                return;
            this.isStart = false;
            FixedTimeGenerator.minimum.remove(this);
            return this;
        }
        check(now) {
            //console.log((now.getTime() - this.nextTime) / 1000 / 60)
            if (now.getTime() > this.nextTime) {
                // those who actually received it will be somehow latter
                this.currentTime = this.pick(now);
                this.nextTime = this.next(now);
                this.events.emit("tick", this.currentTime);
            }
        }
        pick(date = new Date) {
            let time = new Time(date, this.zone);
            if (this.period == "year") {
                time = time.thisZoneYearStart(this.duration, this.start);
            }
            else if (this.period == "month") {
                time = time.thisZoneMonthStart(this.duration, this.start);
            }
            else if (this.period == "day") {
                time = time.thisZoneDayStart(this.duration, this.start);
            }
            else if (this.period == "week") {
                time = time.thisZoneWeekStart(this.duration, this.start);
            }
            else if (this.period == "hour") {
                time = time.thisZoneHourStart(this.duration, this.start);
            }
            else if (this.period == "minute") {
                time = time.thisZoneMinuteStart(this.duration, this.start);
            }
            else if (this.period == "second") {
                time = time.thisZoneSecondStart(this.duration, this.start);
            }
            else if (this.period == "milli") {
                time = time.thisZoneRangeStart(this.duration, this.start);
            }
            return time.date.getTime();
        }
        next(date = new Date) {
            let time = new Time(date, this.zone);
            if (this.period == "year") {
                time = time.nextZoneYearStart(this.duration, this.start);
            }
            else if (this.period == "month") {
                time = time.nextZoneMonthStart(this.duration, this.start);
            }
            else if (this.period == "day") {
                time = time.nextZoneDayStart(this.duration, this.start);
            }
            else if (this.period == "week") {
                time = time.nextZoneWeekStart(this.duration, this.start);
            }
            else if (this.period == "hour") {
                time = time.nextZoneHourStart(this.duration, this.start);
            }
            else if (this.period == "minute") {
                time = time.nextZoneMinuteStart(this.duration, this.start);
            }
            else if (this.period == "second") {
                time = time.nextZoneSecondStart(this.duration, this.start);
            }
            else if (this.period == "milli") {
                time = time.nextZoneRangeStart(this.duration, this.start);
            }
            return time.date.getTime();
        }
        static nextTick(fn) {
            if (typeof process != "undefined") {
                process.nextTick(fn);
            }
            else if (typeof setImmediate != "undefined") {
                setImmediate(fn);
            }
            else {
                setTimeout(fn, 0);
            }
        }
    }
    FixedTimeGenerator.minimum = new MinimumPulseGenerator();
    Leaf.FixedTimeGenerator = FixedTimeGenerator;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts" />
var Leaf;
(function (Leaf) {
    class EventBubbler {
        constructor(events) {
            this.events = events;
            this.isStale = false;
            this.isStopped = false;
        }
        stop() {
            if (this.isStale) {
                throw new Error("Already staled");
            }
            this.isStopped = true;
        }
        stale() {
            this.isStale = true;
        }
    }
    class EventEmitter {
        constructor() {
            this.addListener = this.addEventListener;
            this.off = this.removeEventListener;
            this.bubbler = null;
            this.events = {};
        }
        addEventListener(event, handler) {
            this.on(event, handler);
            return this;
        }
        removeAllListeners() {
            this.removeEventListener();
        }
        on(event, handler) {
            let ehs = this.getOrCreateEventHandlers(event);
            ehs.push({
                once: false,
                handler: handler
            });
            return this;
        }
        once(event, handler) {
            let ehs = this.getOrCreateEventHandlers(event);
            ehs.push({
                once: true,
                handler: handler
            });
            return this;
        }
        listenByOnce(who, event, handler) {
            let ehs = this.getOrCreateEventHandlers(event);
            ehs.push({
                owner: who,
                once: true,
                handler: handler
            });
            return this;
        }
        listenBy(who, event, handler) {
            if (Array.isArray(event)) {
                for (let e of event) {
                    this.listenBy(who, e, handler);
                }
                return this;
            }
            let ehs = this.getOrCreateEventHandlers(event);
            ehs.push({
                owner: who,
                once: false,
                handler: handler
            });
            return this;
        }
        stopListenBy(who, event, handler) {
            if (event) {
                let ehs = this.getOrCreateEventHandlers(event);
                ehs = ehs.filter((eh) => {
                    if (eh.owner === who && (!handler || handler === eh.handler))
                        return false;
                    return true;
                });
                this.events[event] = ehs;
            }
            else {
                if (!who) {
                    return;
                }
                for (let name in this.events) {
                    let ehs = this.events[name];
                    let change = false;
                    ehs = ehs.filter((eh) => {
                        if (eh.owner === who && (!handler || handler === eh.handler)) {
                            change = true;
                            return false;
                        }
                        return true;
                    });
                    if (change) {
                        this.events[name] = ehs;
                    }
                }
            }
            return this;
        }
        removeEventListener(event, handler) {
            if (!event) {
                this.events = {};
            }
            if (!handler) {
                this.events[event] = [];
                return this;
            }
            let ehs = this.getOrCreateEventHandlers(event);
            let change = false;
            ehs = ehs.filter((eh) => {
                if (!eh.owner && (!handler || handler === eh.handler)) {
                    change = true;
                    return false;
                }
                return true;
            });
            if (change) {
                this.events[event] = ehs;
            }
            return this;
        }
        createNextBubbler() {
            this.bubbler = new EventBubbler(this);
            return this.bubbler;
        }
        emit(event, ...values) {
            let todo = [];
            let ehs = this.getOrCreateEventHandlers(event);
            let change = false;
            let bubbler = this.bubbler;
            this.bubbler = null;
            ehs = ehs.filter((eh) => {
                if (eh.owner)
                    todo.push(eh.handler.bind(eh.owner));
                else
                    todo.push(eh.handler);
                if (eh.once) {
                    change = true;
                    return false;
                }
                return true;
            });
            if (change) {
                this.events[event] = ehs;
            }
            todo.every((handler) => {
                if (bubbler && bubbler.isStopped)
                    return false;
                handler(...values);
                return true;
            });
            bubbler && bubbler.stale();
            return bubbler;
        }
        getOrCreateEventHandlers(event) {
            let ehs = this.events[event];
            if (!ehs) {
                ehs = this.events[event] = [];
            }
            return ehs;
        }
        wait(event) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((res, rej) => {
                    const onError = (err) => {
                        this.removeEventListener(event, onEvent);
                        rej(err);
                    };
                    const onEvent = (data) => {
                        this.removeEventListener("error", onError);
                        res(data);
                    };
                    this.once("error", onError);
                    this.once(event, onEvent);
                });
            });
        }
    }
    Leaf.EventEmitter = EventEmitter;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts" />
var Leaf;
(function (Leaf) {
    class Situations {
        static fromEvents(inits, events) {
            const situations = new Situations(inits);
            for (let key in inits) {
                events.listenBy(situations, key, value => {
                    situations.set(key, value);
                });
            }
            return situations;
        }
        constructor(inits) {
            this.inits = inits;
            this.events = new Leaf.EventEmitter;
            this.situations = Leaf.Util.clone(this.inits);
            this.waits = [];
        }
        get(key) {
            return this.situations[key];
        }
        set(key, value) {
            if (this.situations[key] === value)
                return value;
            this.situations[key] = value;
            const todos = [];
            this.waits = this.waits.filter(wait => {
                if (wait.key === key) {
                    if (wait.not && wait.value !== value) {
                        todos.push(wait);
                        return false;
                    }
                    else if (!wait.not && wait.value === value) {
                        todos.push(wait);
                        return false;
                    }
                }
                return true;
            });
            setTimeout(() => {
                this.events.emit(key, value);
                for (let todo of todos) {
                    todo.callback(null, value);
                }
            }, 0);
            return value;
        }
        waitNot(key, value) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.situations[key] !== value)
                    return value;
                const callback = Leaf.SharedCallbacks.create();
                this.waits.push({
                    key: key,
                    value,
                    not: true,
                    callback
                });
                return callback.promise();
            });
        }
        wait(key, value) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.situations[key] === value)
                    return value;
                const callback = Leaf.SharedCallbacks.create();
                this.waits.push({
                    key: key,
                    value,
                    callback
                });
                return callback.promise();
            });
        }
    }
    Leaf.Situations = Situations;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts" />
var Leaf;
(function (Leaf) {
    class Hook {
        constructor() {
            this.hooks = {};
        }
        hookBy(who, name, callback) {
            let hooks = this.hooks[name] = this.hooks[name] || [];
            hooks.push({
                owner: who,
                name: name,
                callback
            });
        }
        stopHookBy(who, name) {
            for (let key in this.hooks) {
                if (name && name !== key)
                    continue;
                this.hooks[key] = this.hooks[key].filter(item => item.owner !== who);
            }
        }
        trigger(_option, callback) {
            return __awaiter(this, void 0, void 0, function* () {
                let option;
                if (typeof _option == "string") {
                    option = {
                        name: _option
                    };
                }
                else {
                    option = _option;
                }
                let hooks = this.hooks[option.name] || [];
                let procedure = new HookTriggerProcedure(hooks);
                return new Promise((res, rej) => {
                    procedure.trigger(option, (info) => {
                        if (callback)
                            callback(info);
                        res(info);
                    });
                });
            });
        }
    }
    Leaf.Hook = Hook;
    class HookTriggerInfo {
        constructor(option, callback) {
            this.option = option;
            this.callback = callback;
            this.error = this.option.error;
            this.data = this.option.data;
            this.params = this.option.params;
            this.done = this.callback;
            this.isAborted = false;
        }
        provide(data) {
            this.data = data;
            this.continue();
        }
        abort(error) {
            this.isAborted = true;
            this.done(error);
        }
        continue() {
            this.done();
        }
    }
    Leaf.HookTriggerInfo = HookTriggerInfo;
    class HookTriggerProcedure {
        constructor(hooks, order = "stack") {
            this.hooks = hooks;
            this.order = order;
            this.error = null;
            this.data = null;
            this.params = null;
            this.callback = null;
            this.hooks = hooks.slice();
        }
        trigger(option, callback) {
            this.error = option.error;
            this.data = option.data;
            this.params = option.params;
            this.callback = Leaf.Util.once(callback);
            this.info = new HookTriggerInfo({
                error: this.error,
                data: this.data,
                params: this.params,
            }, (err) => {
                if (this.info.isAborted) {
                    this.callback(this.info);
                    return;
                }
                if (this.hooks.length == 0) {
                    this.callback(this.info);
                    return;
                }
                this.next();
            });
            this.next();
        }
        next() {
            let hook;
            if (this.order == "stack") {
                hook = this.hooks.pop();
            }
            else if (this.order == "queue") {
                hook = this.hooks.shift();
            }
            else {
                throw new Error("Unknown hook order");
            }
            if (!hook) {
                this.callback(this.info);
                return;
            }
            hook.callback(this.info);
        }
    }
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts" />
var Leaf;
(function (Leaf) {
    class States {
        constructor() {
            this.events = new Leaf.EventEmitter();
            this.state = "void";
            this.sole = 1;
            this.soleEmitted = 1;
            this.lastException = null;
            this.rescues = [];
            this.data = {};
            this.feeds = {};
            this.isDebugging = false;
            this.clearHandler = null;
            this.name = this.constructor && this.constructor["name"] || null;
            this.panicErrorRecursive = null;
            this.panicError = null;
            this.panicState = null;
            this._logger = (...infos) => {
                let log = console.log;
                log.apply(console, infos);
            };
            this._assertingStateSequence = null;
            this._assertingStateCallback = null;
            this._assertingStateIndex = 0;
            this.reset();
        }
        reset() {
            this.data = {};
            this.feeds = {};
            this.respawn();
            this.events.emit("reset");
        }
        errorOrGoto(err, state, ...args) {
            if (err) {
                this.error(err);
                return;
            }
            this.setState(state, ...args);
        }
        setState(state, ...args) {
            try {
                this._setState(state, ...args);
            }
            catch (e) {
                console.error(e);
                if (state == "panic") {
                    this.setState("recursivePanic");
                }
                else {
                    this.error(e);
                }
            }
        }
        _stateBegin() {
            try {
                this.events.emit("before/" + this.state);
                this.events.emit("state", this.state);
                this.events.emit("state/" + this.state);
            }
            catch (e) {
                console.error("ignore state/before error during events", e);
            }
        }
        _stateFinish() {
            try {
                this.events.emit("after/" + this.state);
            }
            catch (e) {
                console.error("ignore state/after error during events", e);
            }
            this.soleEmitted = this.sole;
            this._updateStateAssertion(this.state);
        }
        clearConsumers() {
            if (this.feeds) {
                for (let prop in this.feeds) {
                    let feed = this.feeds[prop];
                    feed.feedListener = null;
                }
            }
        }
        _setState(state, ...args) {
            if (this.state === "panic" && state !== "void") {
                return;
            }
            // set state syncly from previous state
            // so we emit the previous state here
            // That is, all state/${state} is guaranteed to be emitted
            // after the state finish and before the next state start.
            this.clear();
            if (this.soleEmitted < this.sole) {
                this._stateFinish();
            }
            // clear all consumers
            this.clearConsumers();
            // new sole
            this.sole += 1;
            this.previousState = this.state;
            this.state = state;
            if (this.isDebugging) {
                this.debugStateHandler();
            }
            this._stateBegin();
            let stateHandler = "at" + state[0].toUpperCase() + state.substring(1);
            if (this[stateHandler]) {
                let sole = this.sole;
                try {
                    let pro = this[stateHandler](function () {
                        return sole !== this.sole;
                    }.bind(this), ...args);
                    if (pro && Leaf.Util.isPromise(pro)) {
                        pro.catch(e => {
                            if (this.state == "panic") {
                                console.error(e);
                                console.error("Recursive panic");
                                this.panicErrorRecursive = e;
                                this.setState("recursivePanic");
                            }
                            else {
                                this.panicError = e;
                                this.panicState = this.state;
                                this.setState("panic");
                            }
                        });
                    }
                }
                catch (e) {
                    if (this.state == "panic") {
                        console.error(e);
                        console.error("Recursive panic");
                        this.panicErrorRecursive = e;
                        this.setState("recursivePanic");
                        return;
                    }
                    this.error(e);
                    return;
                }
                // didn't set state during the process, we can safely emit state here
                if (sole === this.sole) {
                    //this._stateFinish()
                }
            }
            else if (state !== "void") {
                this.error(new Error(`InvalidState ${state}`));
            }
        }
        error(err) {
            this.panicError = err;
            this.panicState = this.state;
            this._logger(`Panic at ${this.state}`, this.panicError);
            if (this.panicError) {
                this.setState("panic");
            }
        }
        atPanic() {
            console.error("Panic at", this.panicState, this.panicError);
            this.events.emit("panic", this.panicError, this.panicState);
        }
        recover(recoverState, data) {
            let error = this.panicError;
            let state = this.panicState;
            this.respawn();
            if (!recoverState) {
                recoverState = ("void");
            }
            this.setState(recoverState, data);
            return { error, state };
        }
        respawn() {
            this.sole = this.sole || 1;
            this.sole += 1;
            this.soleEmitted = this.sole;
            this.panicError = null;
            this.panicState = null;
            this.setState("void");
            this.clear();
        }
        clear(handler) {
            if (handler) {
                if (this.clearHandler) {
                    throw new Error("Already clearing with a handler");
                }
                this.clearHandler = handler;
            }
            else {
                handler = this.clearHandler;
                this.clearHandler = null;
                if (handler) {
                    handler();
                }
            }
        }
        ensureFeed(name) {
            if (this.feeds[name])
                return this.feeds[name];
            let feed = this.feeds[name] = {
                feedListener: null,
                signals: [],
                name: name
            };
            return feed;
        }
        feed(name, signal) {
            if (!this.feeds[name]) {
                this.feeds[name] = {
                    feedListener: null,
                    signals: [],
                    name: name
                };
            }
            let feed = this.feeds[name];
            feed.signals.push(signal);
            let listener = feed.feedListener;
            if (listener) {
                feed.feedListener = null;
                try {
                    listener();
                }
                catch (e) {
                    this.error(e);
                }
            }
        }
        consumeAll(name) {
            let feed = this.feeds[name];
            if (feed) {
                let length = feed.signals.length;
                feed.signals.length = 0;
                return length;
            }
            return 0;
        }
        hasFeed(name) {
            return this.feeds[name] && this.feeds[name].signals.length > 0;
        }
        consume(name) {
            if (!this.hasFeed(name))
                return null;
            let feed = this.feeds[name];
            if (feed) {
                return feed.signals.shift();
            }
            return null;
        }
        consumeWhenAvailableMergeToLast(name, callback) {
            this.consumeWhenAvailable(name, (detail) => {
                let last = null;
                while (true) {
                    last = this.consume(name);
                    if (!last)
                        break;
                }
                try {
                    if (last) {
                        callback(last);
                    }
                    else {
                        callback(detail);
                    }
                }
                catch (e) {
                    this.error(e);
                }
            });
        }
        isConsuming(name) {
            return this.feeds[name] && this.feeds[name].feedListener && true || false;
        }
        consumeWhenAvailable(name, callback) {
            let feed = this.feeds[name];
            if (!feed) {
                feed = this.ensureFeed(name);
            }
            let called = false;
            feed.feedListener = () => {
                if (called)
                    return;
                called = true;
                callback(this.consume(name));
            };
            this.setImmediate(() => {
                let feed = this.feeds[name];
                // cleared by others
                if (!feed || !feed.feedListener)
                    return;
                // have signals
                if (feed && feed.signals && feed.signals.length > 0) {
                    try {
                        let listener = feed.feedListener;
                        listener();
                    }
                    catch (e) {
                        this.error(e);
                    }
                }
                this.events.emit("starve", name);
                this.events.emit("starve/" + name);
            });
        }
        debug(option) {
            this.isDebugging = true;
        }
        debugStateHandler(option, message) {
            option = option || {};
            let name = option.name || this.name || "Anonymous";
            let text = `${name}: state - ${this.state}`;
            this._logger(text);
        }
        setLogger(logger) {
            this._logger = logger;
        }
        assertStateSequence(states, callback) {
            if (this._assertingStateSequence) {
                callback(new Error("Already asserting"));
                return;
            }
            this._assertingStateSequence = states;
            this._assertingStateCallback = callback;
            this._assertingStateIndex = 0;
        }
        _endStateAssertion(err) {
            let cb = this._assertingStateCallback;
            if (!cb)
                return;
            this._assertingStateSequence = null;
            this._assertingStateIndex = 0;
            this._assertingStateCallback = null;
            cb(err);
        }
        _updateStateAssertion(state) {
            if (!this._assertingStateSequence)
                return;
            let should = this._assertingStateSequence[this._assertingStateIndex];
            if (should !== state) {
                this._endStateAssertion(new Error(`State at index ${this._assertingStateIndex} should be ${should} but is ${state} during sequence ${this._assertingStateSequence.map((s, index) => { if (index === this._assertingStateIndex)
                    return "->" + s; return s; }).join("\n")}`));
            }
        }
        atRecursivePanic() {
            this._logger("RecursivePanics", this.panicError);
        }
        setImmediate(fn) {
            if (typeof setImmediate !== "undefined") {
                setImmediate(fn);
            }
            else {
                setTimeout(fn, 0);
            }
        }
    }
    Leaf.States = States;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts" />
var Leaf;
(function (Leaf) {
    if (typeof XMLHttpRequest == "undefined") {
        // pollyfill for node
        if (Leaf["XMLHttpRequest"]) {
            XMLHttpRequest = Leaf["XMLHttpRequest"];
        }
    }
    class APIFactory {
        _handleResponse(response, callback) {
            let data;
            if (response) {
                try {
                    if (this.option.serializer) {
                        data = this.option.serializer.deserialize(response);
                    }
                    else {
                        data = JSON.parse(response);
                    }
                }
                catch (e) {
                    callback(new Leaf.Errors.NetworkError("Broken Response", { raw: response }), null);
                    return;
                }
                if (!data.state) {
                    if (data.error) {
                        callback(this.errorMapper(data.error), null);
                    }
                    else {
                        callback(new Error("APIError"), null);
                    }
                    return;
                }
                else {
                    callback(null, data.data);
                }
            }
            else {
                callback(new Leaf.Errors.NetworkError("Empty response"), null);
            }
        }
        constructor(option) {
            this.option = option;
            this.responseHandler = null;
            this.errorMapper = (err) => {
                let _err = new Error(err.message);
                _err.message = err.message;
                _err.name = err.name;
                // @ts-ignore
                _err.raw = err;
                // @ts-ignore
                _err.state = err.state;
                return _err;
            };
            if (!(typeof this.option.defaultTimeout === "number")) {
                this.option.defaultTimeout = 0;
            }
            if (!(typeof this.option.prefix === "string")) {
                this.option.prefix = "";
            }
            if (!(typeof this.option.suffix === "string")) {
                this.option.suffix = "";
            }
            if (!this.option.root) {
                this.option.root = "";
            }
            if (option.errorMapper) {
                this.errorMapper = option.errorMapper;
            }
        }
        createAPI(option) {
            if (typeof option.mock == "undefined") {
                option.mock = this.option.mock;
            }
            let api = new APIDeclare(this, option);
            return api;
        }
        createAPIFunction(option) {
            let api = this.createAPI(option);
            return api.getFunction();
        }
        solveResponse(err, response, callback) {
            callback(err, response);
        }
        request(option, callback) {
            let method = option.method || "GET";
            let url = option.url;
            let sendData = null;
            let headers = option.headers || {};
            let bodyType = option.bodyType || this.option.bodyType || "query";
            // Don't send null, send {}. Some framework not recognize null as a valid json
            if (!option.query)
                option.query = {};
            let queryString = this.buildQueryString(option.query);
            if (method.toUpperCase() === "GET") {
                if (url.indexOf("? <= 0")) {
                    url += "?";
                }
                else {
                    url += "&";
                }
                url += queryString;
                sendData = null;
            }
            else {
                if (bodyType === "query") {
                    sendData = queryString;
                }
                else {
                    if (this.option.serializer) {
                        sendData = this.option.serializer.serialize(option.query);
                    }
                    else {
                        sendData = JSON.stringify(option.query);
                    }
                }
            }
            let xhr = new XMLHttpRequest();
            xhr.open(method, url, true);
            if (option.withCredentials) {
                xhr.withCredentials = true;
            }
            xhr.setRequestHeader("Accept", "application/json");
            if (bodyType === "json") {
                xhr.setRequestHeader("Content-Type", "application/json");
            }
            else {
                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            }
            for (let name in this.option.headers) {
                if (!headers[name])
                    headers[name] = this.option.headers[name];
            }
            for (let name in headers) {
                xhr.setRequestHeader(name, headers[name]);
            }
            let done = false;
            let _callback = callback;
            let timer = null;
            callback = (err, response) => {
                clearTimeout(timer);
                // disable multiple callback
                callback = () => { };
                this.solveResponse(err, response, _callback);
                return;
            };
            if (option.timeout) {
                timer = setTimeout(() => {
                    callback = () => { };
                    _callback(new Leaf.Errors.Timeout(`Request timeout after ${option.timeout}`), null);
                    xhr.abort();
                }, option.timeout * 1000);
            }
            xhr.onreadystatechange = () => {
                if (xhr.readyState === 0 && !done) {
                    callback(new Leaf.Errors.NetworkError(), null);
                    return;
                }
                if (xhr.readyState === 4) {
                    done = true;
                    this.lastResponse = xhr.responseText;
                    if (this.responseHandler) {
                        this.responseHandler(xhr.responseText, callback);
                    }
                    else {
                        this._handleResponse(xhr.responseText, callback);
                    }
                }
            };
            if (method.toLowerCase() != "get") {
                xhr.send(sendData);
            }
            else {
                xhr.send();
            }
            return xhr;
        }
        buildQueryString(query) {
            if (!query) {
                return "";
            }
            let kvs = [];
            for (let prop in query) {
                let value = query[prop] || "";
                kvs.push([encodeURIComponent(prop), encodeURIComponent(value)].join("="));
            }
            return kvs.join("&");
        }
    }
    Leaf.APIFactory = APIFactory;
    class APIDeclare {
        constructor(factory, option) {
            this.factory = factory;
            this.option = option;
            this.mocks = [];
        }
        mock(option, error, result) {
            this.mocks.push({
                option, error, result
            });
            return this;
        }
        _mock(option, callback) {
            for (let mock of this.mocks) {
                if (Leaf.Util.deepEqual(option, mock.option)) {
                    callback(mock.error, mock.result);
                    return true;
                }
            }
            return false;
        }
        decorateAPIOption(option, fn) {
            return function (...args) {
                let op = args[0] || {};
                for (let key in option) {
                    if (typeof op[key] == "undefined") {
                        op[key] = option[key];
                    }
                }
                args[0] = op;
                fn(...args);
            };
        }
        getFunction() {
            let fn = this.invoke.bind(this);
            fn.API = this;
            fn.mock = (option, error, result) => {
                this.mock(option, error, result);
                return fn;
            };
            fn.with = (data) => {
                let apiOption = Leaf.Util.clone(this.option);
                if (!apiOption.data)
                    apiOption.data = {};
                for (let key in data) {
                    apiOption.data[key] = data[key];
                }
                let declare = new APIDeclare(this.factory, apiOption);
                declare.mocks = this.mocks;
                return declare.getFunction();
            };
            fn.transform = (ts) => {
                return (op, callback) => {
                    fn(op, (err, data) => {
                        if (err) {
                            callback();
                            return;
                        }
                        callback(null, ts(data));
                    });
                };
            };
            return fn;
        }
        invoke(data = {}, callback) {
            data = Object.assign({}, data);
            if (this.option.data) {
                // default params
                for (let prop in this.option.data) {
                    if (typeof data[prop] == "undefined") {
                        data[prop] = this.option.data[prop];
                    }
                }
            }
            if (this.option.mock || this.factory.option.mock) {
                let mocked = this._mock(data, callback);
                if (!mocked) {
                    callback(new Error(`Mock miss for ${this.option.method} ${this.option.path}. Data: ${JSON.stringify(data)}`));
                }
                return;
            }
            let method = this.option.method;
            let url = this.factory.option.root + this.factory.option.prefix + this.option.path + this.factory.option.suffix;
            let routeParams = (url.match(/:[a-z_][a-z0-9_]*/ig) || []).map((item) => { return item.substring(1); });
            for (let prop in data) {
                if (routeParams.indexOf(prop) >= 0) {
                    url = url.replace(new RegExp(":" + prop, "g"), encodeURIComponent(data[prop]));
                    delete data[prop];
                }
            }
            let reqOption = {
                url, method,
                query: data,
                timeout: this.option.timeout,
                headers: this.option.headers,
                withCredentials: this.option.withCredentials,
                bodyType: this.option.bodyType
            };
            return new Promise((res, rej) => {
                this.factory.request(reqOption, (err, result) => {
                    if (callback) {
                        callback(err, result);
                        return;
                    }
                    if (err) {
                        rej(err);
                    }
                    else {
                        res(result);
                    }
                });
            });
        }
    }
    Leaf.APIDeclare = APIDeclare;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts" />
var Leaf;
(function (Leaf) {
    Leaf.RPCErrors = Leaf.ErrorDoc.create()
        .define("APINotExists")
        .define("Timeout")
        .define("Conflict")
        .define("BrokenConnection")
        .define("Abort")
        .generate();
    function RPCMethod() {
        return (target, propertyKey, descriptor) => {
            if (typeof descriptor.value == "function") {
                descriptor.value["__isRPCMethod"] = true;
            }
        };
    }
    Leaf.RPCMethod = RPCMethod;
    class RPCComposer {
        isOpen() {
            return !!this.connection;
        }
        allocateId() { return this.requestOffset++; }
        install(obj = this, decorator) {
            for (let key in obj) {
                let v = obj[key];
                if (typeof v !== "function")
                    continue;
                if (v["__isRPCMethod"]) {
                    if (v.length !== 2) {
                        console.error(`RPCMethod ${key} must accept 2 arguments (option,callback), which accepts ${v.length}.`);
                        continue;
                    }
                    if (this.methods[key]) {
                        console.error("Duplicate RPCMethod ${key}");
                        continue;
                    }
                    let method = v.bind(obj);
                    if (decorator) {
                        method = decorator(method, key);
                    }
                    this.registerRPCMethod(key, method);
                }
            }
        }
        constructor(option = {}) {
            this.option = option;
            this.declares = {};
            this.requestOffset = 10000;
            this.methods = {};
            this.remoteEvents = new Leaf.EventEmitter();
            this.responseHandlers = [];
            this.events = new Leaf.EventEmitter();
            this.serializer = new Leaf.Serializer();
            this.preserveErrorStack = false;
            if (!(typeof this.option.defaultTimeout === "number")) {
                this.option.defaultTimeout = -1;
            }
        }
        setConnection(con) {
            this.connection = con;
            this.connection.events.listenBy(this, "message", (message) => {
                this.handleMessage(message);
            });
            this.connection.events.listenBy(this, "close", () => {
                this.unsetConnection();
            });
            this.events.emit("open");
        }
        unsetConnection() {
            if (!this.connection)
                return;
            this.connection.events.stopListenBy(this);
            this.connection = null;
            for (let handler of this.responseHandlers) {
                this.finishHandler(handler, new Leaf.RPCErrors.Abort);
            }
            this.responseHandlers.length = 0;
            this.events.emit("close");
        }
        revokeRPCMethod(name) {
            delete this.methods[name];
        }
        registerRPCMethod(name, handler) {
            //if (this.methods[name]) { throw new RPCErrors.Conflict(`RPC Method "${name}" already exists`) }
            this.methods[name] = handler;
        }
        createRPCDeclare(option) {
            let api = new RPCDeclare(this, option);
            this.declares[option.name] = api;
            return api;
        }
        createRPCInvokeInterface(option) {
            let api = this.createRPCDeclare(option);
            if (option.persist) {
                this[option.name] = api;
            }
            return api.getFunction();
        }
        emitRemoteEvent(name, data) {
            let blob = {
                name: name,
                data: data,
                type: RPCProtocolBlobType.EVENT
            };
            this.send(this.normalize(blob));
        }
        invoke(name, data, handle, option = {}) {
            if (!handle) {
                handle = () => { };
            }
            if (!this.connection) {
                handle(new Leaf.RPCErrors.BrokenConnection("Connection not exists"));
                return;
            }
            let handler = {
                id: this.allocateId(),
                handler: handle,
                finished: false,
                timer: null,
                method: name
            };
            let timeout = option.timeout || this.option.defaultTimeout;
            if (timeout > 0) {
                handler.timer = setTimeout(() => {
                    if (!handler.finished) {
                        this.finishHandlerById(handler.id, new Leaf.RPCErrors.Timeout(`RPC timeout after ${timeout || this.option.defaultTimeout}`));
                    }
                    this.events.emit("timeout");
                }, timeout);
            }
            this.responseHandlers.push(handler);
            let blob = {
                id: handler.id,
                method: name,
                data: data,
                type: RPCProtocolBlobType.INVOKE
            };
            this.send(this.normalize(blob));
        }
        serialize(data) {
            return this.serializer.serialize(data);
        }
        deserialize(content) {
            return this.serializer.deserialize(content);
        }
        send(data) {
            if (!this.connection)
                return false;
            if (typeof data !== "string") {
                data = this.serialize(data);
            }
            this.connection.send(data);
            return true;
        }
        handleMessage(rawString) {
            let data = null;
            try {
                let raw = this.deserialize(rawString);
                data = this.denormalize(raw);
            }
            catch (e) {
                return;
            }
            if (data.type === RPCProtocolBlobType.INVOKE) {
                this.handleInvoke(data);
            }
            else if (data.type === RPCProtocolBlobType.RESPONSE) {
                this.handleResponse(data);
            }
            else if (data.type === RPCProtocolBlobType.EVENT) {
                this.handleEvent(data);
            }
        }
        handleInvoke(req) {
            return __awaiter(this, void 0, void 0, function* () {
                let response = {
                    id: req.id,
                    type: RPCProtocolBlobType.RESPONSE
                };
                let call = this.methods[req.method];
                if (!call) {
                    if (this.invokeNotFoundHandler) {
                        call = this.invokeNotFoundHandler(req.method);
                    }
                    if (!call) {
                        response.error = new Leaf.RPCErrors.APINotExists(`Requesting API ${req.method} not exists`);
                        if (!this.preserveErrorStack) {
                            delete response.error.stack;
                        }
                        this.send(this.normalize(response));
                        return;
                    }
                }
                let returned = false;
                let res = (err, data) => {
                    if (returned)
                        return;
                    returned = true;
                    response.error = err;
                    if (response.error && !this.preserveErrorStack) {
                        delete response.error["stack"];
                    }
                    response.data = data;
                    this.send(this.normalize(response));
                };
                try {
                    const result = yield call(req.data);
                    res(null, result);
                }
                catch (e) {
                    res(e, null);
                }
            });
        }
        handleResponse(res) {
            this.finishHandlerById(res.id, res.error, res.data);
        }
        handleEvent(event) {
            setTimeout(() => {
                this.remoteEvents.emit(event.name, event.data);
                this.remoteEvents.emit("*", event);
            }, 0);
        }
        transformObject(data, handler) {
            if (typeof data !== "object") {
                return data;
            }
            if (Array.isArray(data)) {
                return data.map((item) => { return this.transformObject(item, handler); });
            }
            if (!data)
                return data;
            let norm = data;
            if (handler) {
                norm = handler(norm);
            }
            // changed by custom norm
            if (norm && norm !== data) {
                return norm;
            }
            for (let prop in data) {
                data[prop] = this.transformObject(data[prop], handler);
            }
            return data;
        }
        normalize(data) {
            return this.transformObject(data, this.customNormalize);
        }
        denormalize(data) {
            return this.transformObject(data, this.customDenormalize);
        }
        finishHandlerById(id, err, value) {
            this.responseHandlers = this.responseHandlers.filter((handler) => {
                if (handler.id === id) {
                    this.finishHandler(handler, err, value);
                    return false;
                }
                return true;
            });
        }
        finishHandler(handler, err, value) {
            handler.finished = true;
            if (handler.timer) {
                clearTimeout(handler.timer);
                handler.timer = null;
            }
            setTimeout(() => {
                this.events.emit("response", {
                    method: handler.method,
                    id: handler.id, error: err, value
                });
                handler.handler(err, value);
            }, 0);
        }
    }
    Leaf.RPCComposer = RPCComposer;
    class RPCDeclare {
        constructor(center, option) {
            this.center = center;
            this.option = option;
        }
        getFunction() {
            let fn = this.invoke.bind(this);
            fn.RPC = this;
            return fn;
        }
        invoke(data = {}, callback) {
            return __awaiter(this, void 0, void 0, function* () {
                if (callback) {
                    throw new Error("Callback style invoke is nolonger supported in leaf-ts");
                }
                let handle;
                let promise = new Promise((res, rej) => {
                    handle = (err, result) => {
                        if (err) {
                            rej(err);
                            return;
                        }
                        res(result);
                    };
                });
                while (!this.center.isOpen()) {
                    yield this.center.events.wait("open");
                }
                this.center.invoke(this.option.name, data, handle, {
                    timeout: this.option.timeout || 0
                });
                return yield promise;
            });
        }
    }
    Leaf.RPCDeclare = RPCDeclare;
    class RPCConnectionBase {
        constructor() {
            this.events = new Leaf.EventEmitter();
        }
    }
    Leaf.RPCConnectionBase = RPCConnectionBase;
    let RPCProtocolBlobType;
    (function (RPCProtocolBlobType) {
        RPCProtocolBlobType[RPCProtocolBlobType["INVOKE"] = 1] = "INVOKE";
        RPCProtocolBlobType[RPCProtocolBlobType["RESPONSE"] = 2] = "RESPONSE";
        RPCProtocolBlobType[RPCProtocolBlobType["EVENT"] = 3] = "EVENT";
    })(RPCProtocolBlobType = Leaf.RPCProtocolBlobType || (Leaf.RPCProtocolBlobType = {}));
    class RPCBrowserWebSocketConnection extends RPCConnectionBase {
        constructor(connection) {
            super();
            this.connection = connection;
            this.connection.addEventListener("open", (msg) => {
                this.events.emit("open");
            });
            this.connection.addEventListener("message", (msg) => {
                this.events.emit("message", msg.data);
            });
            this.connection.addEventListener("close", () => {
                this.events.emit("close");
            });
        }
        send(content) {
            this.connection.send(content);
        }
        isOpen() {
            return this.connection.readyState == this.connection.OPEN;
        }
        close() {
            this.connection.close();
        }
        describe() {
            return this.connection.url;
        }
    }
    Leaf.RPCBrowserWebSocketConnection = RPCBrowserWebSocketConnection;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts" />
var Leaf;
(function (Leaf) {
    class Race {
        constructor() {
            this.consumers = [];
            this.waiters = [];
            this.hungryWaiters = [];
            this.cache = [];
            this.max = -1;
        }
        consume() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.cache.length == 0 || this.consumers.length > 0) {
                    let done;
                    let error;
                    let promise = new Promise((res, rej) => {
                        done = res;
                        error = rej;
                    });
                    this.consumers.push({
                        promise, done, error
                    });
                    return promise;
                }
                else {
                    return this.cache.shift();
                }
            });
        }
        wait() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.cache.length > 0)
                    return;
                return new Promise((res) => {
                    this.waiters.push(res);
                });
            });
        }
        waitHungry() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.max < 0 || this.cache.length < this.max)
                    return;
                return new Promise((res) => {
                    this.hungryWaiters.push(res);
                });
            });
        }
        feed(...datas) {
            return __awaiter(this, void 0, void 0, function* () {
                while (this.consumers.length > 0 && datas.length > 0) {
                    let waiter = this.consumers.shift();
                    waiter.done(datas.shift());
                }
                if (datas.length > 0) {
                    this.cache.push(...datas);
                }
                if (this.cache.length < this.max || this.max < 0) {
                    if (this.hungryWaiters.length > 0) {
                        for (let fn of this.hungryWaiters) {
                            fn();
                        }
                        this.hungryWaiters.length = 0;
                    }
                }
                this.waiters = this.waiters.filter(waiter => {
                    if (this.cache.length > 0) {
                        waiter();
                        return false;
                    }
                    return true;
                });
            });
        }
        error(error) {
            let consumers = this.consumers;
            this.consumers = [];
            for (let waiter of consumers) {
                waiter.error(error);
            }
        }
        close() {
            let consumers = this.consumers;
            this.consumers = [];
            for (let waiter of consumers) {
                waiter.done(null);
            }
        }
    }
    Leaf.Race = Race;
    class Lock {
        constructor() {
            this.waiters = {};
            this.defaultLockName = "default";
        }
        wait(name = this.defaultLockName) {
            return __awaiter(this, void 0, void 0, function* () {
                let waiter = this.waiters[name];
                if (!waiter || !waiter.locked)
                    return false;
                yield waiter.race.wait();
                return true;
            });
        }
        isLock(name = this.defaultLockName) {
            let waiter = this.waiters[name];
            if (!waiter)
                return false;
            if (waiter.waitingForLock > 0)
                return true;
            if (!waiter.locked)
                return false;
            return true;
        }
        lock(name = this.defaultLockName) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.lockBy(null, name);
            });
        }
        lockBy(who = null, name = this.defaultLockName) {
            return __awaiter(this, void 0, void 0, function* () {
                let waiter = this.waiters[name] = this.waiters[name] || {
                    race: new Race,
                    locked: false,
                    by: null,
                    waitingForLock: 0,
                };
                if (waiter.locked || waiter.waitingForLock > 0) {
                    waiter.waitingForLock++;
                    yield waiter.race.consume();
                    waiter.waitingForLock--;
                }
                waiter.locked = true;
                waiter.by = who || null;
            });
        }
        release(name = "default") {
            return this.releaseBy(null, name);
        }
        releaseBy(who = null, name = this.defaultLockName) {
            let waiter = this.waiters[name];
            if (!waiter || !waiter.locked) {
                throw new Leaf.Errors.LockError("Release not locked");
            }
            if (waiter.by !== who) {
                throw new Leaf.Errors.LockError("Release owner invalid");
            }
            if (waiter.waitingForLock == 0) {
                waiter.locked = false;
            }
            waiter.by = null;
            if (waiter.race.consumers.length > 0) {
                waiter.race.feed(true);
            }
        }
        with(a1, fn) {
            return __awaiter(this, void 0, void 0, function* () {
                let name = this.defaultLockName;
                if (fn) {
                    name = a1;
                }
                else {
                    fn = a1;
                }
                if (typeof fn !== "function") {
                    throw new Error("Lock.with requires a function");
                }
                if (typeof name !== "string") {
                    throw new Error("Lock.with requires a name");
                }
                yield this.lock(name);
                try {
                    return yield fn();
                }
                finally {
                    this.release(name);
                }
            });
        }
    }
    Leaf.Lock = Lock;
    class Join {
        constructor() {
            this.race = new Race();
            this.handles = [];
        }
        fork() {
            let handle = new JoinHandle(this);
            this.handles.push(handle);
            this.race.cache.length = 0;
            return handle;
        }
        join() {
            return __awaiter(this, void 0, void 0, function* () {
                this.check();
                yield this.race.wait();
            });
        }
        check() {
            let done = true;
            for (let handle of this.handles) {
                if (!handle.joined) {
                    done = false;
                    break;
                }
            }
            if (done) {
                this.handles.length = 0;
                this.race.feed(true);
            }
        }
    }
    Leaf.Join = Join;
    class JoinHandle {
        constructor(context) {
            this.context = context;
            this.joined = false;
        }
        join() {
            return __awaiter(this, void 0, void 0, function* () {
                this.joined = true;
                this.context.check();
                return yield this.context.join();
            });
        }
    }
    Leaf.JoinHandle = JoinHandle;
    class Limits {
        constructor(count) {
            this.count = count;
            this.left = this.count;
            this.race = new Race();
            for (let i = 0; i < count; i++) {
                this.race.feed(true);
            }
        }
        wait() {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.race.wait();
            });
        }
        obtain() {
            return __awaiter(this, void 0, void 0, function* () {
                let result = yield this.race.consume();
                this.left--;
                return result;
            });
        }
        release() {
            if (this.left < this.count) {
                this.left++;
                this.race.feed(true);
            }
            else {
                throw new Error("Logic error, release through max");
            }
        }
    }
    Leaf.Limits = Limits;
    class Value {
        constructor() {
            this.lock = new Lock();
            this.lock.lock();
        }
        get() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.lock.isLock())
                    return this.value;
                yield this.lock.lock();
                this.lock.release();
                return this.value;
            });
        }
        isInitialized() {
            return this.lock.isLock();
        }
        unset() {
            // already lock(no value)
            if (this.lock.isLock())
                return;
            this.value = null;
            this.lock.lock();
        }
        set(v) {
            this.value = v;
            if (this.lock.isLock()) {
                this.lock.release();
            }
        }
    }
    Leaf.Value = Value;
    class RunnerQueue {
        constructor(maxConcurrency = 1) {
            this.maxConcurrency = maxConcurrency;
            this.race = new Race();
            this.limits = new Limits(this.maxConcurrency);
            this.keepRun();
        }
        keepRun() {
            return __awaiter(this, void 0, void 0, function* () {
                while (true) {
                    const task = yield this.race.consume();
                    yield this.limits.obtain();
                    task().then(() => {
                        this.limits.release();
                    }).catch(() => {
                        this.limits.release();
                    });
                }
            });
        }
        wait(fn) {
            return new Promise((res, rej) => {
                this.race.feed(() => __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield fn();
                    }
                    catch (e) {
                        rej(e);
                        return;
                    }
                    res(null);
                }));
            });
        }
        add(fn) {
            this.race.feed(fn);
        }
    }
    Leaf.RunnerQueue = RunnerQueue;
})(Leaf || (Leaf = {}));
var Leaf;
(function (Leaf) {
    class Service {
        get isInitialized() {
            return ServiceContext.isServiceInitialize(this);
        }
        set isInitialized(v) {
            ServiceContext.markServiceInitialized(this, v);
        }
        initialize() {
            return __awaiter(this, void 0, void 0, function* () {
                return;
            });
        }
        afterInitialize() {
            return __awaiter(this, void 0, void 0, function* () {
            });
        }
        constructor(_defaultSettings, settings) {
            this._defaultSettings = _defaultSettings;
            this.passive = true;
            this.dependencies = [];
            this.befores = [];
            this.settings = {};
            this.buildOption(_defaultSettings || {}, settings);
        }
        buildOption(df, config) {
            this.settings = Leaf.Util.buildOption(df, config);
        }
    }
    Leaf.Service = Service;
    class FastDependencyManager {
        constructor() {
            this.context = {};
        }
        add(name, deps) {
            if (this.context[name])
                throw new Error(`Add duplicated dependency entry: ${name} already exists`);
            if (deps && deps.length == 0)
                deps = null;
            this.context[name] = deps;
        }
        resolve(tasks = Object.keys(this.context)) {
            tasks = tasks.slice();
            const orders = [];
            const pending = [];
            while (tasks.length > 0) {
                const first = tasks.shift();
                pending.push(first);
                while (pending.length > 0) {
                    const cur = pending.at(-1);
                    if (!this.context[cur]) {
                        orders.push(cur);
                        pending.pop();
                        continue;
                    }
                    let deps = this.context[cur];
                    let hasUnfinishedDep = deps.some(dep => {
                        if (orders.includes(dep))
                            return false;
                        if (pending.includes(dep)) {
                            throw new Error(`Recursive dependency ${cur} -> ${dep}`);
                        }
                        const targetIndex = tasks.indexOf(dep);
                        if (targetIndex < 0) {
                            throw new Error(`Unknown dependency ${dep}`);
                        }
                        tasks.splice(targetIndex, 1);
                        pending.push(dep);
                        return true;
                    });
                    if (!hasUnfinishedDep) {
                        orders.push(cur);
                        pending.pop();
                    }
                }
            }
            return orders;
        }
    }
    Leaf.FastDependencyManager = FastDependencyManager;
    class DependencyManager {
        constructor() {
            this.context = {};
            this.befores = {};
            this.onAddDymanicDependency = (name) => { };
        }
        add(name, deps, before) {
            if (this.context[name])
                throw new Error(`Add duplicated dependency entry: ${name} already exists`);
            if (deps && deps.length == 0)
                deps = null;
            this.context[name] = deps;
            if (before) {
                this.befores[name] = before;
            }
        }
        addReverseDependency(name, dep) {
            if (!this.context[name])
                this.context[name] = [];
            this.context[name].push(dep);
        }
        resolveDependency(name, chain = []) {
            // inject all before into dependency
            for (let name in this.befores) {
                let matchers = this.befores[name];
                for (let serviceName in this.context) {
                    for (let matcher of matchers) {
                        if (typeof matcher == "string") {
                            if (matcher === serviceName) {
                                this.addReverseDependency(serviceName, name);
                                break;
                            }
                        }
                        else if (matcher instanceof RegExp && matcher.test(serviceName)) {
                            this.addReverseDependency(serviceName, name);
                            break;
                        }
                    }
                }
            }
            if (typeof this.context[name] === "undefined") {
                this.onAddDymanicDependency(name);
                if (typeof this.context[name] === "undefined") {
                    throw new Error(`${name} required by ${chain[chain.length - 1]} couldn't be fullfilled.`);
                }
            }
            if (this.context[name] === null)
                return [];
            chain = chain.slice();
            if (chain.indexOf(name) >= 0) {
                chain.push(name);
                throw new Error(`Recursive dependency detected: ${chain.join("\n=>")}`);
            }
            chain.push(name);
            let result = [];
            let all = [];
            for (let matcher of this.context[name] || []) {
                if (typeof matcher === "string") {
                    if (!all.includes(matcher))
                        all.push(matcher);
                }
                else if (matcher instanceof RegExp) {
                    for (let name in this.context) {
                        if (matcher.test(name) && !all.includes(name)) {
                            all.push(name);
                        }
                    }
                }
            }
            for (let dep of all) {
                if (dep === name)
                    continue;
                let deps = this.resolveDependency(dep, chain);
                for (let subDep of deps) {
                    if (result.indexOf(subDep) < 0)
                        result.push(subDep);
                }
                result.push(dep);
            }
            return result;
        }
        resolveRegExp(deps, all) {
            let result = [];
            for (let dep of deps) {
                if (typeof dep == "string") {
                    result.push(dep);
                }
                else if (dep instanceof RegExp) {
                    let replacement = all.filter(item => dep.test(item));
                    result.push(...replacement);
                }
            }
            let distincts = [];
            for (let item of result) {
                if (distincts.indexOf(item) < 0) {
                    distincts.push(item);
                }
            }
            return result;
        }
        resolve(extra = []) {
            let result = [];
            let all = Object.keys(this.context).concat(extra);
            for (let name in this.context) {
                this.context[name] = this.resolveRegExp(this.context[name] || [], all);
            }
            for (let name in this.befores) {
                this.befores[name] = this.resolveRegExp(this.befores[name] || [], all);
            }
            for (let name in this.context) {
                let deps = this.resolveDependency(name);
                for (let dep of deps) {
                    if (!result.includes(dep))
                        result.push(dep);
                }
                if (!result.includes(name))
                    result.push(name);
            }
            return result;
        }
    }
    Leaf.DependencyManager = DependencyManager;
    class ServiceContext {
        static isServiceInitialize(service) {
            if (!service)
                return false;
            return !!service[ServiceContext.serviceInitializeSymbol];
        }
        static markServiceInitialized(service, which = true) {
            if (!service)
                return;
            service[ServiceContext.serviceInitializeSymbol] = which;
        }
        constructor(settings = {}) {
            this.settings = settings;
            this.BuiltInServiceInstances = {};
            this.passiveServices = {};
            this.events = new Leaf.EventEmitter();
            this.ready = new Leaf.ReadyBehavior();
            this.isPassiveServiceEnabled = false;
            this.builtInServiceConstructors = {};
            this.services = {};
            this.dependencyManager = new DependencyManager;
            this.dirtyRegister = false;
            this.lock = new Leaf.Lock();
            //for (let name in BuiltInService) {
            //    let Con = BuiltInService[name] as any
            //    let s = new Con(this.settings)
            //    this.BuiltInServiceInstances[s.name] = s
            //}
            // When dependency not met but we have that dependency in our built-in service
            this.dependencyManager.onAddDymanicDependency = (name) => {
                if (this.passiveServices[name]) {
                    this.addToDependency(this.passiveServices[name]);
                    return;
                }
                let Cons = this.builtInServiceConstructors[name];
                if (Cons && !this.BuiltInServiceInstances[name]) {
                    this.BuiltInServiceInstances[name] = new Cons(settings);
                }
                let s = this.BuiltInServiceInstances[name];
                if (s) {
                    if (s["asBuiltIn"]) {
                        s["asBuiltIn"]();
                    }
                    this.addToDependency(s);
                }
            };
        }
        addBuiltInServiceConstructor(name, Cons) {
            this.builtInServiceConstructors[name] = Cons;
        }
        register(s) {
            this.dirtyRegister = true;
            // passive module will only add when required
            if (s.passive && this.isPassiveServiceEnabled) {
                this.passiveServices[s.name] = s;
            }
            else {
                this.addToDependency(s);
            }
            this.events.emit("register", s.name);
            return s;
        }
        addToDependency(s) {
            this.dependencyManager.add(s.name, s.dependencies || null);
            this.services[s.name] = s;
        }
        isServiceConstructor(obj) {
            return typeof obj === "function" && (obj.prototype["thisObjectIsRootServiceConstructor"] || obj.prototype[ServiceContext.serviceConstructorSymbol]);
        }
        setup() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.lock.lock("setup");
                for (let key in this.services) {
                    const service = this.services[key];
                    if (service["preInitialize"]) {
                        this.events.emit("preInitializing", key);
                        yield service["preInitialize"](this);
                        this.events.emit("preInitialized", key);
                    }
                }
                let all = Object.keys(this.passiveServices);
                let initialSequence = this.dependencyManager.resolve(all);
                this.dirtyRegister = false;
                for (let i = 0; i < initialSequence.length; i++) {
                    const name = initialSequence[i];
                    if (this.dirtyRegister)
                        initialSequence = this.dependencyManager.resolve(all);
                    let service = this.services[name];
                    if (!service) {
                        throw new Error("Fail to find service name " + name);
                        return;
                    }
                    if (ServiceContext.isServiceInitialize(service)) {
                        throw new Error(`Duplicated service initialization of service:${name}`);
                        continue;
                    }
                    service.services = this.services;
                    yield this.initializeService(service);
                    ServiceContext.markServiceInitialized(service, true);
                    yield this.serviceAfterInitialized(service);
                }
                this.lock.release("setup");
                this.events.emit("ready");
                this.ready.yes();
            });
        }
        serviceAfterInitialized(service) {
            return __awaiter(this, void 0, void 0, function* () {
                let timer = null;
                let name = service.name;
                if (!service.afterInitialize)
                    return;
                if (service.afterInitialize.length == 1) {
                    throw new Error("Callback style after initialize deprecated");
                }
                else {
                    yield service.afterInitialize();
                    clearTimeout(timer);
                }
            });
        }
        initializeService(service) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!service.initialize)
                    return;
                let name = service.name;
                this.events.emit("initializing", name);
                if (service.initialize.length == 1) {
                    throw new Error("callback style initialize deprecated");
                }
                else {
                    service.services = service.services || {};
                    Object.assign(service.services, this.services);
                    yield service.initialize();
                    ServiceContext.markServiceInitialized(service, true);
                    this.events.emit("initialized", name);
                }
            });
        }
    }
    ServiceContext.serviceInitializeSymbol = Leaf.ensureGlobal("isServiceInitialized", () => Symbol("isServiceInitialized"));
    ServiceContext.serviceConstructorSymbol = Leaf.ensureGlobal("serviceConstructorSymbol", () => Symbol("serviceConstructorSymbol"));
    Leaf.ServiceContext = ServiceContext;
    Service.prototype[ServiceContext.serviceConstructorSymbol] = true;
})(Leaf || (Leaf = {}));
var Leaf;
(function (Leaf) {
    class Referencer {
        constructor() {
            this.events = new Leaf.EventEmitter();
            this.counter = 0;
        }
        ref() {
            this.counter += 1;
            if (this.counter == 1) {
                this.events.emit("init");
            }
            else {
                this.events.emit("ref");
            }
        }
        deref() {
            this.counter -= 1;
            if (this.counter == 0) {
                this.events.emit("release");
            }
            else if (this.counter > 0) {
                this.events.emit("deref");
            }
            else {
                console.error("Invalid Deref");
            }
        }
    }
    Leaf.Referencer = Referencer;
    class OwnerReferencer {
        constructor() {
            this.events = new Leaf.EventEmitter();
            this.refs = [];
        }
        ttl(time) {
            return new OwnerReferenceCachier(this, time);
        }
        release() {
            this.refs.length = 0;
            this.events.emit("release");
        }
        getCounter() {
            return this.refs.reduce((a, b) => {
                return a + b.counter;
            }, 0);
        }
        refBy(who) {
            for (let ref of this.refs) {
                if (ref.owner == who) {
                    ref.counter += 1;
                    this.events.emit("ref");
                    return true;
                }
            }
            this.refs.push({
                owner: who,
                counter: 1
            });
            if (this.getCounter() == 1) {
                this.events.emit("init");
            }
            else {
                this.events.emit("ref");
            }
            return true;
        }
        derefBy(who) {
            let i = 0;
            for (let ref of this.refs) {
                if (ref.owner == who) {
                    ref.counter -= 1;
                    if (ref.counter < 0) {
                        console.error("Invalid by ", who);
                        throw new Error("Invalid Deref by");
                    }
                    if (this.getCounter() <= 0) {
                        this.events.emit("release");
                    }
                    else {
                        this.events.emit("deref");
                    }
                    return true;
                }
                i++;
            }
            console.error("Invalid by ", who);
            throw new Error("Invalid derefence by");
        }
    }
    Leaf.OwnerReferencer = OwnerReferencer;
    class MultipleReference {
        constructor() {
            this.refs = [];
            this.targetRefs = [];
            this.events = new Leaf.EventEmitter();
        }
        refTarget(target) {
            for (let item of this.targetRefs) {
                if (item.target === target) {
                    item.counter += 1;
                    this.events.emit("ref", target);
                    return true;
                }
            }
            this.targetRefs.push({
                target,
                counter: 1
            });
            this.events.emit("init", target);
            return true;
        }
        derefTarget(target, n = 1) {
            let i = 0;
            for (let item of this.targetRefs) {
                if (item.target === target) {
                    item.counter -= n;
                    if (item.counter == 0) {
                        this.targetRefs.splice(i, 1);
                        this.events.emit("release", target);
                    }
                    else {
                        this.events.emit("deref", target);
                    }
                    return true;
                }
                i++;
            }
            return false;
        }
        derefAll(who) {
            let arr = this.refs;
            for (let i = 0; i < arr.length; i++) {
                let item = arr[i];
                if (item.owner === who) {
                    arr.splice(i, 1);
                    i--;
                    this.derefTarget(item.target, item.counter);
                }
            }
        }
        refBy(who, target) {
            let arr = this.refs;
            for (let i = 0; i < arr.length; i++) {
                let item = arr[i];
                if (item.owner === who && target == item.owner) {
                    item.counter += 1;
                    return this.refTarget(target);
                }
            }
            this.refs.push({
                target,
                owner: who,
                counter: 1
            });
            return this.refTarget(target);
        }
        derefBy(who, target) {
            if (!target) {
                return this.derefAll(who);
            }
            let arr = this.refs;
            for (let i = 0; i < arr.length; i++) {
                let item = arr[i];
                if (item.owner === who && target == item.owner) {
                    item.counter -= 1;
                    if (item.counter <= 0) {
                        arr.splice(i, 1);
                    }
                    return this.derefTarget(target);
                }
            }
            return false;
        }
    }
    Leaf.MultipleReference = MultipleReference;
    class OwnerReferenceCachier {
        constructor(referencer, time = 10000) {
            this.referencer = referencer;
            this.time = time;
            this.timer = null;
            this.referencer.refBy(this);
            this.referencer.events.listenBy(this, "deref", () => {
                let counter = this.referencer.getCounter();
                // Only me reference
                if (counter == 1) {
                    this.debounceDeref();
                }
            });
            this.referencer.events.listenBy(this, "ref", () => {
                this.stopDebounceDeref();
            });
        }
        debounceDeref() {
            this.timer = setTimeout(() => {
                this.referencer.derefBy(this);
                this.referencer.events.stopListenBy(this);
            }, this.time);
        }
        stopDebounceDeref() {
            clearTimeout(this.timer);
        }
    }
    Leaf.OwnerReferenceCachier = OwnerReferenceCachier;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts" />
var Leaf;
(function (Leaf) {
    class Util {
        constructor() { }
        static isPromise(p) {
            return p.then && p.catch;
        }
        static debugAsyncFunction(value, option = {}) {
            return function (...args) {
                return __awaiter(this, void 0, void 0, function* () {
                    yield (option === null || option === void 0 ? void 0 : option.before(...args));
                    const v = yield value.apply(this, args);
                    yield (option === null || option === void 0 ? void 0 : option.after(v));
                    return v;
                });
            };
        }
        static debugFunction(value, option = {}) {
            return function (...args) {
                option === null || option === void 0 ? void 0 : option.before(...args);
                const v = value.apply(this, args);
                option === null || option === void 0 ? void 0 : option.after(v);
                return v;
            };
        }
        static once(fn) {
            let called = false;
            return ((...args) => {
                if (called)
                    return;
                called = true;
                fn(...args);
            });
        }
        static clone(obj) {
            if (!obj)
                return obj;
            if (Array.isArray(obj)) {
                return obj.map((item) => {
                    return Util.clone(item);
                });
            }
            if (obj instanceof Date) {
                return obj;
            }
            if (obj instanceof RegExp) {
                let i = obj.ignoreCase && "i" || "";
                let g = obj.global && "g" || "";
                let m = obj.multiline && "m" || "";
                return new RegExp(obj.source, i + g + m);
            }
            if (obj
                instanceof String) {
                return new String(obj);
            }
            if (typeof obj == "symbol")
                return obj;
            if (typeof obj === "function") {
                return obj;
            }
            if (typeof obj === "object") {
                let result = {};
                for (let prop in obj) {
                    result[prop] = this.clone(obj[prop]);
                }
                return result;
            }
            // for RegExp/Function we left it as is.
            return obj;
        }
        static capitalize(str) {
            if (!str)
                return str;
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        static uncapitalize(str) {
            if (!str)
                return str;
            return str.charAt(0).toLowerCase() + str.slice(1);
        }
        static camelToSlug(str) {
            if (!str)
                return str;
            return str.replace(/[a-z][A-Z]/g, (match) => {
                return match[0] + "-" + match[1].toLowerCase();
            }).toLowerCase();
        }
        static slugToCamel(str) {
            if (!str)
                return str;
            return str.replace(/-[a-z]/ig, (match) => {
                return match.slice(1).toUpperCase();
            });
        }
        static deepEqual(a, b) {
            if (a === b)
                return true;
            if (typeof a !== typeof b)
                return false;
            if (typeof a !== "object")
                return false;
            if (Array.isArray(a)) {
                if (a.length != b.length)
                    return false;
                for (let i = 0; i < a.length; i++) {
                    if (!this.deepEqual(a[i], b[i]))
                        return false;
                }
                return true;
            }
            else {
                if (!a || !b) {
                    return false;
                }
                let pas = Object.getOwnPropertyNames(a);
                let pbs = Object.getOwnPropertyNames(b);
                if (pas.length != pbs.length) {
                    return false;
                }
                let diff = this.arrayDiff(pas, pbs);
                if (diff.left.length !== 0 || diff.right.length !== 0)
                    return false;
                for (let key of diff.intersect) {
                    if (!this.deepEqual(a[key], b[key])) {
                        return false;
                    }
                }
                return true;
            }
        }
        static ensureArray(value) {
            if (Array.isArray(value))
                return value;
            if (Leaf.Util.isEmptyValue(value))
                return [];
            return [value];
        }
        static dictDiff(d1, d2, identical) {
            let left = Object.keys(d1).map((name) => { return { name: name, value: d1[name] }; });
            let right = Object.keys(d2).map((name) => { return { name: name, value: d2[name] }; });
            if (!identical) {
                identical = (a, b) => {
                    return a === b;
                };
            }
            let result = this.arrayDiff(left, right, (a, b) => {
                return identical(a.value, b.value);
            });
            return {
                left: result.left.map(item => item.name),
                right: result.right.map(item => item.name),
                interact: result.interact.map(item => item.name),
                intersect: result.intersect.map(item => item.name)
            };
        }
        static random(seed = Math.random().toString()) {
            let num = 1;
            for (let i = 0; i < seed.length; i++) {
                let char = seed.charCodeAt(i);
                num *= char + 0.5;
                num %= 100000;
            }
            num = Math.round(num * num);
            var m_w = 123456789;
            var m_z = 987654321;
            var mask = 0xffffffff;
            // Takes any integer
            m_w = num;
            m_z = 987654321;
            // Returns number between 0 (inclusive) and 1.0 (exclusive),
            // just like Math.random().
            m_z = (36969 * (m_z & 65535) + (m_z >> 16)) & mask;
            m_w = (18000 * (m_w & 65535) + (m_w >> 16)) & mask;
            var result = ((m_z << 16) + m_w) & mask;
            result /= 4294967296;
            return result + 0.5;
        }
        static arrayShuffleInplace(array, seed = Math.random().toString()) {
            seed = Util.random(seed).toString();
            for (var i = array.length - 1; i > 0; i--) {
                let rnd = Util.random(seed);
                seed = rnd.toString();
                var j = Math.floor(rnd * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
            return array;
        }
        static arrayDiffTyped(arr1, arr2, identical) {
            if (!identical) {
                identical = (a, b) => {
                    return a === b;
                };
            }
            arr1 = arr1.slice();
            arr2 = arr2.slice();
            let leftShare = [];
            let rightShare = [];
            for (let i = 0; i < arr1.length; i++) {
                if (!arr1[i])
                    break;
                for (let j = 0; j < arr2.length; j++) {
                    if (identical(arr1[i], arr2[j])) {
                        leftShare.push(arr1[i]);
                        rightShare.push(arr2[j]);
                        arr1.splice(i, 1);
                        arr2.splice(j, 1);
                        i--;
                        break;
                    }
                }
            }
            return {
                left: arr1,
                right: arr2,
                leftShare,
                rightShare
            };
        }
        static arrayDiff(arr1 = [], arr2 = [], identical) {
            if (!identical) {
                identical = (a, b) => {
                    return a === b;
                };
            }
            arr1 = arr1.slice();
            arr2 = arr2.slice();
            let intersect = [];
            for (let i = 0; i < arr1.length; i++) {
                if (!arr1[i])
                    break;
                for (let j = 0; j < arr2.length; j++) {
                    if (identical(arr2[j], arr1[i])) {
                        intersect.push(arr1[i]);
                        arr1.splice(i, 1);
                        arr2.splice(j, 1);
                        i--;
                        break;
                    }
                }
            }
            return {
                left: arr1,
                right: arr2,
                interact: intersect,
                intersect,
            };
        }
        static arrayUnique(array, hash = (item) => item) {
            const result = [];
            const hashs = [];
            for (let item of array) {
                const id = hash(item);
                if (hashs.includes(id))
                    continue;
                result.push(item);
                hashs.push(id);
            }
            return result;
        }
        static buildOption(defaultOption, option = {}) {
            if (defaultOption == null || typeof defaultOption == "undefined") {
                return option;
            }
            if (typeof defaultOption !== "undefined" && defaultOption !== null && (typeof option === "undefined" || option === null)) {
                return defaultOption;
            }
            let result = {};
            if (Array.isArray(option)) {
                return option;
            }
            if (Array.isArray(defaultOption)) {
                if (!option) {
                    return defaultOption.slice();
                }
                else {
                    return option;
                }
            }
            if (typeof option === "object") {
                for (let name in defaultOption) {
                    if (typeof option[name] !== "undefined") {
                        result[name] = this.buildOption(defaultOption[name], option[name]);
                    }
                    else {
                        result[name] = defaultOption[name];
                    }
                }
                return result;
            }
            return option;
        }
        static timeout(time, task, info) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield Promise.race([new Promise((res, rej) => setTimeout(() => {
                        rej(new Error(`Timeout: ${info || "unknown"}`));
                    }, time)),
                    task
                ]);
            });
        }
        static sleep(time) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield new Promise(res => {
                    setTimeout(res, time);
                });
            });
        }
        static getBrowserInfo() {
            let unknown = {
                name: "None",
                version: "None",
                mobile: false
            };
            if (typeof globalThis.navigator === "undefined") {
                return unknown;
            }
            let N = navigator.appName;
            let ua = navigator.userAgent;
            if (!ua)
                return unknown;
            let M = ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
            let tem = ua.match(/version\/([\.\d]+)/i);
            if (M && tem != null) {
                M[2] = tem[1];
            }
            M = M ? [M[1], M[2]] : [N, navigator.appVersion, '-?'];
            return { name: M[0], version: M[1], mobile: Util.isMobile() };
        }
        static mergeUnsafe(a, b) {
            if (Leaf.Util.isEmptyValue(b))
                return a;
            if (typeof a == typeof b) {
                return b;
            }
            if (Array.isArray(a) && Array.isArray(b)) {
                let diff = Util.arrayDiff(a, b);
                return [...a, ...diff.right];
            }
            if (typeof b == "object") {
                if (!a)
                    return b;
                for (let key in b) {
                    a[key] = this.mergeUnsafe(a[key], b[key]);
                }
                return a;
            }
            return b;
        }
        static isMobile() {
            if (globalThis.navigator && navigator.userAgent) {
                return (navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/Windows Phone/i)) && true || false;
            }
            else {
                return false;
            }
        }
        static isEmptyValue(v) {
            if (typeof v === "undefined" || v === null) {
                return true;
            }
            return false;
        }
        static getObjectValue(obj, path) {
            let parent = obj;
            let parts = typeof path == "string" && path.split(".").filter(item => !!item) || path;
            while (!Util.isEmptyValue(parent) && parts.length > 0) {
                let part = parts.shift();
                parent = parent[part];
            }
            return parent;
        }
        static getObjectValues(obj, routes) {
            let parent = obj;
            let parts = routes.slice();
            const values = [];
            while (!Util.isEmptyValue(parent) && parts.length > 0) {
                let part = parts.shift();
                if (part == "*") {
                    for (let key in parent) {
                        values.push(this.getObjectValues(parent[key], parts.slice()));
                    }
                }
                else if (part == "[]" && Array.isArray(parent)) {
                    for (let value of parent) {
                        values.push(this.getObjectValues(value, parts.slice()));
                    }
                }
                else {
                    parent = parent[part];
                }
            }
            return values;
        }
        static buildObjectMap(obj, map = {}) {
            if (!obj) {
                return map;
            }
            const routeStack = [];
            const objStack = [];
            let cur = obj;
            const curRoutes = [];
            const isFinalValue = (v) => {
                return Array.isArray(v) || !v || typeof v !== "object" || v instanceof Date || v instanceof RegExp || v.constructor && v.constructor !== Object;
            };
            const nextKey = () => {
                const lastKeys = routeStack[routeStack.length - 1];
                if (lastKeys.length == 0)
                    return false;
                const key = lastKeys.shift();
                curRoutes.push(key);
                objStack.push(cur);
                cur = cur[key];
                return true;
            };
            while (true) {
                if (isFinalValue(cur)) {
                    if (objStack.length == 0)
                        return cur;
                    map[curRoutes.join(".")] = cur;
                    cur = objStack.pop();
                    curRoutes.pop();
                }
                else {
                    const keys = Object.keys(cur);
                    if (keys.length > 0) {
                        routeStack.push(keys);
                    }
                }
                while (!nextKey()) {
                    routeStack.pop();
                    curRoutes.pop();
                    cur = objStack.pop();
                    if (routeStack.length == 0)
                        return map;
                }
            }
        }
        static reconstructObjectMap(map) {
            let result = {};
            Object.keys(map).forEach(key => {
                let value = map[key];
                let routes = key.split(".");
                let node = result;
                let ck = null;
                while (ck = routes.shift()) {
                    if (routes.length == 0) {
                        node[ck] = value;
                        break;
                    }
                    if (typeof node[ck] == "undefined" || node[ck] === null) {
                        node[ck] = {};
                    }
                    node = node[ck];
                }
            });
            return result;
        }
    }
    Leaf.Util = Util;
    Leaf.Property.define(Util, "browser", {
        get: (cache) => {
            if (!cache.value) {
                cache.value = Util.getBrowserInfo();
            }
            return cache.value;
        }
    });
    class DataCache {
        constructor(getData) {
            this.getData = getData;
            this.isLoading = false;
            this.isError = false;
            this.error = null;
            this.ready = new Leaf.ReadyBehavior();
            this.data = null;
            this.callbacks = Leaf.SharedCallbacks.create();
            this.go();
        }
        go() {
            if (this.isLoading)
                return;
            this.isLoading = true;
            this.getData((err, result) => {
                this.isLoading = false;
                if (err) {
                    this.isError = true;
                    this.error = err;
                }
                this.data = result;
                this.ready.yes();
                this.callbacks(this.error, result);
            });
        }
        get(callback) {
            if (this.ready.isReady) {
                callback(this.error, this.data);
            }
            else {
                this.callbacks.push(callback);
            }
        }
        retry() {
            if (!this.ready.isReady)
                return;
            this.ready.no();
            this.isError = false;
            this.error = null;
            this.data = null;
            this.go();
        }
    }
    Leaf.DataCache = DataCache;
    Leaf.SharedCallbacks = {
        create() {
            let fn = function (...args) {
                let cbs = fn.callbacks.slice(0);
                fn.clear();
                cbs.forEach(function (callback) {
                    callback(...args);
                });
            };
            fn.callbacks = [];
            fn.push = function (callback) {
                fn.callbacks.push(callback);
                fn.count = fn.callbacks.length;
            };
            fn.promise = function () {
                return new Promise((res, rej) => {
                    this.push(function (err, result) {
                        if (err) {
                            rej(err);
                        }
                        else {
                            res(result);
                        }
                    });
                });
            };
            fn.clear = function () {
                fn.callbacks.length = 0;
                fn.count = 0;
            };
            return fn;
        },
    };
    class Transaction {
        constructor() {
            this.queue = [];
            this.isTransacting = false;
        }
        transact(handler, callback) {
            if (this.isTransacting) {
                this.queue.push(() => {
                    this.transact(handler, callback);
                });
                return;
            }
            this.isTransacting = true;
            handler = Leaf.Util.once(handler);
            let fn = ((...args) => {
                this.isTransacting = false;
                handler(...args);
                this.check();
            });
            callback(fn);
        }
        check() {
            if (this.queue.length == 0)
                return;
            let fn = this.queue.shift();
            fn();
        }
    }
    Leaf.Transaction = Transaction;
    class BinarySearch {
        static get(arr, index) {
            if (arr.get) {
                return arr.get(index);
            }
            else {
                return arr[index];
            }
        }
        // Must be found
        static search(arr, solver, start = 0, end = arr.length) {
            if (start == end)
                return -1;
            let mid = Math.floor((start + end) / 2);
            let item = this.get(arr, mid);
            let sig = solver(item, mid, arr);
            if (sig == 0)
                return mid;
            if (sig < 0) {
                if (start == mid)
                    return -1;
                return this.search(arr, solver, start, mid);
            }
            else if (sig > 0) {
                if (mid + 1 == end)
                    return -1;
                return this.search(arr, solver, mid + 1, end);
            }
            throw new Error(`InvalidReturnValue of ${sig}`);
        }
        static searchLeftMost(arr, solver, start = 0, end = arr.length) {
            let result = this.search(arr, solver);
            if (result == -1)
                return result;
            while (result > 0 && solver(this.get(arr, result - 1), result - 1, arr) == 0) {
                result -= 1;
            }
            return result;
        }
        static searchRightMost(arr, solver, start = 0, end = arr.length) {
            let result = this.search(arr, solver);
            if (result == -1)
                return result;
            while (result < arr.length - 1 && solver(this.get(arr, result + 1), result + 1, arr) == 0) {
                result += 1;
            }
            return result;
        }
        // Return the nearest
        static edgeSearch(arr, solver, start = 0, end = arr.length) {
            if (arr.length == 0)
                return -1;
            if (start == end)
                return start;
            let mid = Math.floor((start + end) / 2);
            let item = this.get(arr, mid);
            let sig = solver(item, mid, arr);
            if (sig == 0)
                return mid;
            if (sig < 0) {
                if (start == mid)
                    return mid;
                return this.edgeSearch(arr, solver, start, mid);
            }
            else if (sig > 0) {
                if (mid + 1 == end)
                    return mid;
                return this.edgeSearch(arr, solver, mid + 1, end);
            }
            throw new Error(`InvalidReturnValue of ${sig}`);
        }
        static edgeSearchLeftMost(arr, solver, start = 0, end = arr.length) {
            let result = this.edgeSearch(arr, solver);
            if (result == -1)
                return result;
            let miss = solver(this.get(arr, result), result, arr);
            // make latter condition result > 0 true(use recursion to make logic consist)
            if (miss != 0) {
                if (miss > 0) {
                    result = result + 1;
                }
            }
            while (result > 0 && solver(this.get(arr, result - 1), result - 1, arr) == 0) {
                result -= 1;
            }
            return Math.max(0, result);
        }
        static edgeSearchRightMost(arr, solver, start = 0, end = arr.length) {
            let result = this.edgeSearch(arr, solver);
            if (result == -1)
                return result;
            let miss = solver(this.get(arr, result), result, arr);
            if (miss != 0) {
                if (miss < 0) {
                    result = result - 1;
                }
            }
            while (result < arr.length - 1 && solver(this.get(arr, result + 1), result + 1, arr) == 0) {
                result += 1;
            }
            return Math.min(result, arr.length - 1);
        }
    }
    Leaf.BinarySearch = BinarySearch;
})(Leaf || (Leaf = {}));
var Leaf;
(function (Leaf) {
    class ReadyBehavior {
        constructor() {
            this.isReady = false;
            this.readyCallbacks = Leaf.SharedCallbacks.create();
            this.counter = 0;
            this.debug = false;
            this.events = new Leaf.EventEmitter();
        }
        yes() {
            //if (this.isReady) {
            //    throw new Error("Already ready")
            //}
            if (this.counter++ > 0 && this.debug) {
                console.trace();
            }
            this.isReady = true;
            this.events.emit("ready");
            this.readyCallbacks();
        }
        wait() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.isReady)
                    return true;
                return new Promise((res, rej) => {
                    this.whenReady((err) => {
                        if (err) {
                            rej(err);
                        }
                        else {
                            res(null);
                        }
                    });
                });
            });
        }
        error(err) {
            this.readyCallbacks(err);
        }
        no() {
            if (!this.isReady) {
                throw new Error("Not ready");
            }
            this.isReady = false;
            this.events.emit("unready");
            // flush ready callbacks any way
            this.readyCallbacks(new Error("Won't ready, ready.no() is specified"));
        }
        whenReady(cb) {
            if (this.isReady) {
                cb();
            }
            else {
                this.readyCallbacks.push(cb);
            }
        }
    }
    Leaf.ReadyBehavior = ReadyBehavior;
    class FrameBehavior {
        constructor() {
            this.interval = 1000;
            this.isStart = false;
            this.timer = null;
            this.timeMode = "between";
        }
        setInterval(interval) {
            this.interval = interval;
            return this;
        }
        frame(fn) {
            this.framer = fn;
            return this;
        }
        start() {
            if (this.isStart)
                return;
            this.isStart = true;
            if (this.doingFinish) {
                this.doingFinish.then(() => {
                    this.doingFinish = this.keepDoing();
                });
                this.doingFinish.catch(() => {
                    this.doingFinish = this.keepDoing();
                });
            }
            else {
                this.doingFinish = this.keepDoing();
            }
            return this;
        }
        stop() {
            if (!this.isStart)
                return;
            this.isStart = false;
            return this;
        }
        keepDoing() {
            return __awaiter(this, void 0, void 0, function* () {
                let last = Date.now();
                while (true) {
                    if (!this.isStart) {
                        this.doingFinish = null;
                        return;
                    }
                    let begin = Date.now();
                    if (this.framer) {
                        let delta = Date.now() - last;
                        last = Date.now();
                        yield this.framer(delta);
                    }
                    let pass = Date.now() - begin;
                    let interval = this.interval;
                    if (this.timeMode == "include") {
                        interval = Math.max(0, interval - pass);
                    }
                    yield Leaf.Util.sleep(interval);
                }
            });
        }
        mode(mode) {
            this.timeMode = mode;
            return this;
        }
    }
    Leaf.FrameBehavior = FrameBehavior;
    class KeepRunningBehavior {
        constructor(name) {
            this.name = name;
            this.lock = new Leaf.Lock();
            this._isStart = false;
            this.errorRecoverInterval = 1000 * 10;
            this.running = null;
            this.events = new Leaf.EventEmitter();
        }
        run(fn) {
            this.runner = fn;
            return this;
        }
        get isStart() {
            return this._isStart;
        }
        stop() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.isStart)
                    return;
                yield this.lock.lock();
                try {
                    this._isStart = false;
                    yield this.running;
                    this.running = null;
                }
                finally {
                    this.lock.release();
                }
            });
        }
        start() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.isStart)
                    return;
                yield this.lock.lock();
                this._isStart = true;
                try {
                    this.running = this.keepSync();
                }
                finally {
                    this.lock.release();
                }
                return this;
            });
        }
        keepSync() {
            return __awaiter(this, void 0, void 0, function* () {
                while (this.isStart) {
                    try {
                        let result = yield this.runner();
                        if (result > 0) {
                            yield new Promise(res => {
                                this.timer = setTimeout(() => {
                                    res(null);
                                }, result);
                            });
                        }
                    }
                    catch (e) {
                        console.error(this.name || "Runner:", e);
                        this.events.emit("error", e);
                        yield new Promise(res => {
                            this.timer = setTimeout(res, this.errorRecoverInterval);
                        });
                    }
                }
                return false;
            });
        }
    }
    Leaf.KeepRunningBehavior = KeepRunningBehavior;
    const OncePerObjectSymbol = Leaf.ensureGlobal("OncePerObjectSymbol", () => Symbol("OncePerObjectSymbol"));
    class OncePerObjectBehavior {
        constructor(root) {
            this.root = root;
            this.symbol = Symbol();
            if (root[OncePerObjectSymbol])
                return root[OncePerObjectSymbol];
            root[OncePerObjectSymbol] = this;
        }
        isTouched(target) {
            if (!target)
                return false;
            if (target[this.symbol] === this)
                return true;
            return false;
        }
        touch(target, fn) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.isTouched(target))
                    return;
                target[this.symbol] = this;
                if (!fn)
                    return;
                return yield fn();
            });
        }
        untouch(target) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!target)
                    return;
                if (this.isTouched(target))
                    delete target[this.symbol];
            });
        }
    }
    Leaf.OncePerObjectBehavior = OncePerObjectBehavior;
})(Leaf || (Leaf = {}));
var Leaf;
(function (Leaf) {
    class Debouncer {
        constructor(option) {
            this.option = option;
            this.previousEmit = 0;
            this.timer = null;
            this.idleExecuteImmediately = true;
        }
        debounce(fn) {
            this.clear();
            if (this.idleExecuteImmediately && Date.now() - this.previousEmit > this.option.maxTime) {
                this.previousEmit = Date.now();
                fn();
                return;
            }
            this.timer = setTimeout(() => {
                this.previousEmit = Date.now();
                fn();
            }, this.option.time);
        }
        clear() {
            clearTimeout(this.timer);
        }
    }
    Leaf.Debouncer = Debouncer;
    class GroupDebouncer {
        constructor(option) {
            this.option = option;
            this.debouncers = {};
        }
        debounce(name, fn) {
            if (!this.debouncers[name]) {
                this.debouncers[name] = new Debouncer(this.option);
            }
            this.debouncers[name].debounce(fn);
        }
    }
    Leaf.GroupDebouncer = GroupDebouncer;
})(Leaf || (Leaf = {}));
var Leaf;
(function (Leaf) {
    function once() {
        return (fn, ctx) => {
            let runned = false;
            return function (...args) {
                if (runned)
                    return;
                runned = true;
                return fn.apply(this, args);
            };
        };
    }
    Leaf.once = once;
    function bound() {
        return (fn, ctx) => {
            if (ctx.private)
                throw new Error("bound not supported on private");
            ctx.addInitializer(function () {
                this[ctx.name] = fn.bind(this);
            });
        };
    }
    Leaf.bound = bound;
    Leaf.LockSymbol = Leaf.ensureGlobal("LockSymbol", () => Symbol("Leaf.LockSymbol"));
    function lockByOption(baseName, name, ...names) {
        return (fn, ctx) => {
            if (ctx.private)
                throw new Error("lock not supported on private");
            const allNames = [name, ...names];
            const optionToLockName = (option) => {
                if (!option) {
                    throw new Error("lock by option missing options");
                }
                for (let key of allNames) {
                    if (!option[key]) {
                        throw new Error(`lock by option missing option ${key}`);
                    }
                }
                const signature = allNames.map(key => option[key].toString()).join("-");
                if (!signature) {
                    throw new Error("lock by option signature is empty");
                }
                return [baseName, signature].filter(Boolean).join(":");
            };
            ctx.addInitializer(function () {
                if (!this[Leaf.LockSymbol])
                    this[Leaf.LockSymbol] = new Leaf.Lock();
                const self = this;
                this[Leaf.LockSymbol]["id"] = this[Leaf.LockSymbol]["id"] || Math.random().toString().slice(4, 9);
                this[ctx.name] = function (...args) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const lockSignature = optionToLockName(args[0]);
                        yield self[Leaf.LockSymbol].lock(lockSignature);
                        try {
                            return yield fn.apply(this, args);
                        }
                        finally {
                            self[Leaf.LockSymbol].release(lockSignature);
                        }
                    });
                };
            });
        };
    }
    Leaf.lockByOption = lockByOption;
    function lock(name) {
        return (fn, ctx) => {
            if (ctx.private)
                throw new Error("lock not supported on private");
            ctx.addInitializer(function () {
                if (!this[Leaf.LockSymbol])
                    this[Leaf.LockSymbol] = new Leaf.Lock();
                const self = this;
                this[Leaf.LockSymbol]["id"] = this[Leaf.LockSymbol]["id"] || Math.random().toString().slice(4, 9);
                this[ctx.name] = function (...args) {
                    return __awaiter(this, void 0, void 0, function* () {
                        yield self[Leaf.LockSymbol].lock(name);
                        try {
                            return yield fn.apply(this, args);
                        }
                        finally {
                            self[Leaf.LockSymbol].release(name);
                        }
                    });
                };
            });
        };
    }
    Leaf.lock = lock;
    Leaf.CacheSymbol = Leaf.ensureGlobal("CacheSymbol", () => Symbol("Leaf.CacheSymbol"));
    function cache() {
        return (fn, ctx) => {
            if (ctx.kind !== "getter")
                throw new Error("cache only support getter");
            return function () {
                const cache = this[Leaf.CacheSymbol] = this[Leaf.CacheSymbol] || {};
                const v = cache[ctx.name];
                if (typeof v !== "undefined")
                    return v;
                cache[ctx.name] = fn.apply(this);
                return cache[ctx.name];
            };
        };
    }
    Leaf.cache = cache;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts" />
var Leaf;
(function (Leaf) {
    class DataSource {
        constructor(_name, _fields = []) {
            this._name = _name;
            this._fields = _fields;
            this.events = new Leaf.EventEmitter();
            // instance id
            this.id = Date.now().toString() + Math.random().toString();
            this._data = {};
            for (let field of this._fields) {
                this.define(field);
            }
            Object.defineProperty(this, "fields", {
                get: () => {
                    return this._fields.slice(0);
                }
            });
            Object.defineProperty(this, "data", {
                get: () => {
                    return this;
                },
                set: (values) => {
                    this.sets(values);
                }
            });
        }
        define(name, defaultValue = null) {
            Object.defineProperty(this, name, {
                get: () => {
                    return this.get(name);
                },
                set: (value) => {
                    return this.set(name, value);
                }
            });
        }
        hasKey(key) {
            return this._fields.indexOf(key) >= 0;
        }
        sets(obj) {
            if (!obj) {
                return;
            }
            if (obj instanceof DataSource) {
                obj = obj.toJSON();
            }
            let changed = false;
            let diff = {};
            for (let key in obj) {
                if (!this.hasKey(key)) {
                    continue;
                }
                let old = this._data[key];
                let value = obj[key];
                if (this.set(key, value, true)) {
                    changed = true;
                    this.events.emit(`change/${key}`, value, old);
                    diff[key] = old;
                }
            }
            if (changed) {
                this.events.emit("change", diff);
            }
        }
        set(key, value, silent) {
            let old = this._data[key];
            if (!this.hasKey(key))
                return false;
            if (Leaf.Util.deepEqual(old, value)) {
                return false;
            }
            this._data[key] = value;
            if (silent)
                return true;
            this.events.emit(`change/${key}`, value, old);
            let diff = {};
            diff[key] = old;
            this.events.emit("change", diff);
            return true;
        }
        get(key) {
            return this._data[key];
        }
        toJSON() {
            return JSON.parse(JSON.stringify(this._data));
        }
    }
    Leaf.DataSource = DataSource;
    class Model extends DataSource {
    }
    Leaf.Model = Model;
    class DataTree {
        constructor(source) {
            this.source = source;
        }
        getNode(path) {
            if (!path)
                return new DataNode(this);
            path = path.trim();
            let routes = path.split(".");
            let parent = this.source.data;
            let valid = false;
            for (let route of routes) {
                if (!this.valueCanBeObject(parent[route])) {
                    return null;
                }
                if (parent[route]) {
                    parent = parent[route];
                }
                else if (this.valueCanBeObject(parent[route])) {
                    parent = {};
                    continue;
                }
                else {
                    return null;
                }
            }
            // Point at something can possibly be a data node
            return new DataNode(this, path);
        }
        valueCanBeObject(v) {
            if (typeof v === "string")
                return false;
            if (typeof v === "boolean")
                return false;
            if (typeof v === "number")
                return false;
            if (typeof v === "undefined")
                return false;
            if (typeof v === "object")
                return true;
            return false;
        }
        getValueByPath(path) {
            if (!path)
                return this.source["_data"];
            path = path.trim();
            let routes = path.split(".");
            let parent = this.source["_data"];
            let valid = false;
            let last = routes.pop();
            for (let route of routes) {
                if (!this.valueCanBeObject(parent[route])) {
                    return undefined;
                }
                if (parent[route]) {
                    parent = parent[route];
                }
                else {
                    return undefined;
                }
            }
            // Point at something can possibly be a data node
            let v = parent[last];
            return v;
        }
        setValueByPath(path, v) {
            if (!path) {
                this.source.sets(v);
                return true;
            }
            path = path.trim();
            let routes = path.split(".");
            let root = routes[0];
            let last = routes.pop();
            let parent = this.source["_data"];
            let valid = false;
            let passed = [];
            for (let route of routes) {
                passed.push(route);
                if (!this.valueCanBeObject(parent[route])) {
                    throw new Error(`Typeof ${typeof parent} at ${passed.join(".")} in path ${path} is not a nestable`);
                }
                if (parent[route]) {
                    parent = parent[route];
                }
                else if (this.valueCanBeObject(parent[route])) {
                    parent[route] = {};
                    parent = parent[route];
                }
            }
            // Point at something can possibly be a data node
            let old = parent[last];
            parent[last] = v;
            this.source.events.emit(`change/${root}`, v, old);
            routes.push(last);
            this.source.events.emit(`change`, {
                [routes.join(".")]: old
            });
            return true;
        }
    }
    Leaf.DataTree = DataTree;
    class DataNode {
        constructor(tree, path = "") {
            this.tree = tree;
            this.path = path;
            Object.defineProperty(this, "v", {
                get: () => this.get(),
                set: (v) => this.set(v)
            });
        }
        getProxyOrValue() {
            let v = this.get();
            if (this.tree.valueCanBeObject(v)) {
                return new Proxy((v), {
                    get: (obj, k) => {
                        if (typeof k !== "string")
                            return;
                        let node = this.tree.getNode(this.path + `${this.path && "."}${k}`);
                        if (node)
                            return node.getProxyOrValue();
                        return obj[k];
                    },
                    set: (obj, k, v) => {
                        if (typeof k !== "string")
                            return;
                        this.tree.setValueByPath(this.path + `${this.path && "."}${k}`, v);
                        return true;
                    }
                });
            }
            return v;
        }
        set(v) {
            return this.tree.setValueByPath(this.path, v);
        }
        get() {
            return this.tree.getValueByPath(this.path);
        }
        toString() {
            return `<DataNode: ${this.get().toString()}>`;
        }
    }
    Leaf.DataNode = DataNode;
    class CleanModel extends Leaf.Model {
        constructor() {
            super(...arguments);
            this._ = this.events.listenBy(this, "change", () => {
                let clean = this.isClean;
                if (Leaf.Util.deepEqual(this.toJSON(), this.cleanData)) {
                    this.isClean = true;
                }
                else {
                    this.isClean = false;
                }
                if (clean !== this.isClean) {
                    this.events.emit("cleanState", this.isClean);
                    if (this.isClean) {
                        this.events.emit("clean");
                    }
                    else {
                        this.events.emit("dirty");
                    }
                }
            });
            this.hook = new Leaf.Hook();
            this.isClean = false;
            this.cleanData = null;
        }
        markAsClean() {
            this.cleanData = this.toJSON();
            this.isClean = true;
            this.events.emit("clean");
            this.events.emit("cleanState", true);
        }
        reset() {
            this.sets(this.cleanData || {});
        }
    }
    Leaf.CleanModel = CleanModel;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts" />
var Leaf;
(function (Leaf) {
    class ViewModel extends Leaf.Model {
        constructor(_name, _fields = []) {
            super(_name, _fields);
            this._name = _name;
            this._fields = _fields;
            this.depChain = new DependencyChain;
            this.tree = new Leaf.DataTree(this);
            this.depChain.events.listenBy(this, "declare", (dep) => {
                console.log("Dependency declare", dep);
                this.events.listenBy(`dep/${dep.src}:${dep.target}`, `change/${dep.src}`, () => {
                    this.events.emit(`depChange/${dep.target}`);
                });
                this.events.listenBy(`dep/${dep.src}:${dep.target}`, `depChange/${dep.src}`, () => {
                    this.events.emit(`depChange/${dep.target}`);
                });
            });
            this.depChain.events.listenBy(this, "revoke", (dep) => {
                this.events.stopListenBy(`dep/${dep.src}:${dep.target}`);
            });
        }
        set(key, value, silent) {
            if (typeof value === "function" || typeof this.get(key) === "function") {
                this.depChain.updateFunctionDependency(key, value);
            }
            return super.set(key, value);
        }
    }
    Leaf.ViewModel = ViewModel;
    class DependencyChain {
        constructor() {
            this.events = new Leaf.EventEmitter();
            this.maxDepth = 10;
            this.dependencyMap = {};
        }
        extractFunctionDependency(fn) {
            if (typeof fn !== "function")
                return [];
            let fnString = fn.toString();
            let reg = /VM\.(\w+)\b/g;
            let match;
            let result = [];
            while (match = reg.exec(fnString)) {
                result.push(match[1]);
            }
            return result;
        }
        updateFunctionDependency(name, fn) {
            let deps = this.extractFunctionDependency(fn);
            this.validateDependency(name, deps);
            let oldDeps = this.dependencyMap[name];
            let diff = Leaf.Util.arrayDiff(deps, oldDeps);
            for (let dep of diff.left) {
                this.events.emit("declare", { target: name, src: dep });
            }
            for (let dep of diff.right) {
                this.events.emit("revoke", { target: name, src: dep });
            }
            this.dependencyMap[name] = deps;
        }
        validateDependency(target, src, depth = 0) {
            if (src.indexOf(target) >= 0) {
                throw new Error(`Recursive dependency ${target}`);
            }
            if (depth > this.maxDepth) {
                throw new Error(`Max dependency depth exceed :${this.maxDepth}`);
            }
            let nextCheck = [];
            for (let item of src) {
                if (this.dependencyMap[item]) {
                    let nextDeps = this.dependencyMap[item];
                    for (let nt of nextDeps) {
                        // already checked
                        if (src.indexOf(nt) >= 0)
                            continue;
                        if (nextCheck.indexOf(nt) >= 0)
                            continue;
                        nextCheck.push(nt);
                    }
                }
            }
            if (nextCheck.length === 0)
                return true;
            return this.validateDependency(target, nextCheck, depth + 1);
        }
    }
    Leaf.DependencyChain = DependencyChain;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts" />
var Leaf;
(function (Leaf) {
    class Namespace {
        constructor() {
            this.Widgets = {};
        }
        include(W, name = W.prototype.widgetName) {
            if (W.prototype instanceof Leaf.Widget) {
                if (this.Widgets[name]) {
                    throw new Error(`Widget namespace conflicting: ${name}`);
                }
                this.Widgets[name] = W;
            }
            else {
                console.warn(W, "not inherit WidgetBase");
            }
        }
        getWidgetByName(name) {
            name = Leaf.Util.slugToCamel(name);
            name = Leaf.Util.capitalize(name);
            for (let widgetName in this.Widgets) {
                let W = this.Widgets[widgetName];
                if (widgetName == name || W["widgetName"] === name || W.prototype.widgetName === name || W.constructor["widgetName"] == name) {
                    return W;
                }
            }
            return null;
        }
        createWidgetByName(name, props) {
            let W = this.getWidgetByName(name);
            if (!W)
                return;
            let w = new W(props);
            return w;
        }
        isTagWidgetName(name, who) {
            name = Leaf.Util.slugToCamel(name);
            name = Leaf.Util.capitalize(name);
            if (name === who.widgetName) {
                return true;
            }
            return false;
        }
        clear() {
            this.Widgets = {};
        }
        has(name) {
            name = Leaf.Util.capitalize(Leaf.Util.slugToCamel(name));
            if (this.Widgets[name])
                return true;
            return false;
        }
    }
    Leaf.Namespace = Namespace;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts"/>
var Leaf;
(function (Leaf) {
    class WidgetCoreDesign {
        constructor(widget) {
            this.widget = widget;
            this.subWidgetPlaceholder = {};
            this.slotsPlaceholder = {};
            this.slotIndexOffset = 0;
        }
    }
    Leaf.WidgetCoreDesign = WidgetCoreDesign;
    class WidgetInitializerDesign {
        constructor(widget) {
            this.widget = widget;
        }
    }
    Leaf.WidgetInitializerDesign = WidgetInitializerDesign;
    class WidgetCore extends WidgetCoreDesign {
        attachElement(el, dynamics) {
            // 1. widget
            // 2. common widget
            // 3. slot
            // 4. normal
            // generally todos
            // 0. create real element if needed
            // 1. bind and sync props
            // 2. bindUI by data id
            let tagName = el.tagName.toLowerCase();
            if (tagName.toLowerCase() === "widget") {
                // widget
                let name = el.getAttribute("data-name");
                let path = el.getAttribute("data-widget");
                if (!name && path) {
                    let last = path.split("/").pop();
                    last = last.split(".")[0];
                    name = last;
                }
                if (!name) {
                    console.error(el, "widget missing name");
                    throw new Error("<widget> missing data-name or data-widget");
                }
                this.defineSubWidget(name, el, dynamics, this.getChildrenAsSlot(el));
            }
            else if (this.widget.namespace.has(tagName) && !this.widget.namespace.isTagWidgetName(tagName, this.widget)) {
                // common widget
                let props = {};
                // none dynamic props
                for (let i = 0; i < el.attributes.length; i++) {
                    let item = el.attributes[i];
                    props[item.name] = item.value;
                }
                // slots
                let customWidget = this.widget.namespace.createWidgetByName(tagName, props);
                // inherit properties
                for (let name in props) {
                    if (!customWidget.node.getAttribute(name)) {
                        // resolve data-id-conflict
                        if (name === "data-id")
                            name = "data-id-of-parent";
                        customWidget.node.setAttribute(name, props[name]);
                    }
                }
                customWidget.core.fillSlots(this.getChildrenAsSlot(el));
                // apply properties latter on this custom widget than this place holder
                el.replaceWith(customWidget.node);
                el = customWidget.node;
                // use the data-id of placeholder to bindUI
                this.checkAndBindUI(el, props["data-id"]);
                // sync props after end of this if statement...
            }
            else if (tagName === "slot") {
                // slot
                let name = el.getAttribute("data-slot");
                this.defineSlot(name, el, dynamics);
                // We also bind UI temperarily until filled
                this.checkAndBindUI(el);
            }
            else {
                // normal
                // Id-for-parent priorier to data-id.
                this.checkAndBindUI(el);
                // Only for element that is not delegated
                if (!el.widget && el.getAttribute("data-list")) {
                    let name = el.getAttribute("data-list");
                    this.defineList(name, el);
                }
            }
            this.attachDynamicProperty(el, dynamics);
            this.syncDynamicProperties(el);
            // Whatever it is, we initialize and sync the properties on it
            return el;
        }
        detachElement(el) {
            if (!el)
                return;
            this.detachDynamicProperty(el);
        }
        ;
        attachText(text, config) {
            for (let item of config.templates) {
                if (item.type !== "value")
                    continue;
                let root = Leaf.CoreLogic.getPropertyRoot(item.content);
                this.widget.ViewModel.events.listenBy(text, [`change/${root}`, `depChange/${root}`], this.syncDynamicText.bind(this, text, config));
            }
            this.syncDynamicText(text, config);
        }
        detachText(text) {
            this.widget.ViewModel.events.stopListenBy(text);
        }
        // Should ignore `data-` properties
        extractDynamicPropertyConfig(el) {
            let properties = {};
            for (let i = 0; i < el.attributes.length; i++) {
                let attr = el.attributes[i];
                let configs = Leaf.CoreLogic.createDynamicValueConfigs(attr.value);
                if (configs && configs.length > 0) {
                    el.removeAttribute(attr.name);
                    properties[attr.name] = {
                        name: attr.name,
                        templates: configs
                    };
                }
            }
            return properties;
        }
        getExistDynamicProperty(el) {
            for (let props of el.propertyConfigs || []) {
                if (props.master === this.widget)
                    return props.rules;
            }
            return null;
        }
        syncDynamicProperties(el) {
            let props = {};
            for (let config of el.propertyConfigs || []) {
                let vm = config.master.ViewModel;
                for (let name in config.rules) {
                    let rule = config.rules[name];
                    let value = Leaf.CoreLogic.explainDynamicString(vm.tree, rule);
                    if (!props[name])
                        props[name] = [];
                    props[name].push(value);
                }
            }
            let result = {};
            for (let name in props) {
                if (props[name].length > 1 && Leaf.CoreLogic.isPropertyMergable(name)) {
                    result[name] = Leaf.CoreLogic.mergeProperty(name, props[name]);
                }
                else {
                    result[name] = props[name].pop();
                }
            }
            for (let name in result) {
                let value = result[name];
                if (value !== el.getAttribute(name)) {
                    el.setAttribute(name, value);
                }
            }
        }
        syncDynamicProperty(el, propertyName) {
            var _a;
            let values = [];
            for (let config of el.propertyConfigs) {
                for (let name in config.rules) {
                    if (name === propertyName) {
                        values.push(Leaf.CoreLogic.explainDynamicString(config.master.ViewModel.tree, config.rules[name]));
                    }
                }
            }
            let value = Leaf.CoreLogic.mergeProperty(propertyName, values);
            if (value.toString() != ((_a = el.getAttribute(propertyName)) === null || _a === void 0 ? void 0 : _a.toString())) {
                el.setAttribute(propertyName, value);
            }
        }
        syncDynamicText(text, rule) {
            // Should add pollyfill for IE8/7
            // https://developer.mozilla.org/en/docs/Web/API/Node/textContent
            let value = text.textContent;
            let strs = rule.templates.map((t) => {
                return this.explain(t);
            });
            let result = strs.join("");
            if (result !== value) {
                text.textContent = result;
            }
        }
        explain(config) {
            return Leaf.CoreLogic.explainDynamicValue(this.widget.ViewModel.tree, config);
        }
        checkAndUnbindUI(el) {
            let id = Leaf.Util.slugToCamel(el.getAttribute("data-id"));
            if (id && this.widget.UI[id] === el) {
                this.unbindUI(id);
            }
        }
        checkAndBindUI(el, name) {
            let id = Leaf.Util.slugToCamel(name || el.getAttribute("data-id"));
            if (id) {
                this.bindUI(el, id);
            }
        }
        bindUI(node, id) {
            if (this.widget.UI[id] === node)
                return;
            this.unbindUI(id);
            this.widget.UI[id] = node;
            this.widget.delegates.applyUIDelegateOwner(id);
        }
        unbindUI(id) {
            this.widget.delegates.clearUIDelegateOwner(id);
            delete this.widget.UI[id];
        }
        defineSubWidget(name, el, dynamics, slots) {
            // I've considered using widget.subWidget[name], but after
            // consider twice, I think directly assign subWidget to widget
            // is a better practice and name collision should be minimum.
            // First set this element to it
            this.subWidgetPlaceholder[name] = {
                holder: el,
                dynamics: dynamics,
                slots
            };
            Leaf.Property.define(this.widget, name, {
                set: (value, cache) => {
                    if ((value instanceof Leaf.Widget || value && value["isWidget"]) || !value) {
                        // First assignment do nothing, it's likely the placeholder <widget>
                        const prev = cache.value;
                        this.setSubWidget(name, value);
                        cache.value = value;
                        this.widget.events.emit("subWidgetReplace", {
                            from: prev,
                            to: value
                        });
                    }
                },
                enumerable: true
            });
        }
        setSubWidget(name, widget) {
            // 0. detach old
            // 1. sync properties
            // 2. bindUI
            // 3. replace element
            // replace
            let oldWidget = this.widget[name];
            let replaceTarget;
            let replaceSrc;
            let isReplaceRoot = false;
            if (oldWidget && oldWidget.node && oldWidget.node.parentElement) {
                replaceTarget = oldWidget.node;
            }
            else {
                replaceTarget = this.subWidgetPlaceholder[name].holder;
                if (replaceTarget === this.widget.node) {
                    isReplaceRoot = true;
                }
            }
            if (widget && widget.node) {
                replaceSrc = widget.node;
            }
            else {
                replaceSrc = this.subWidgetPlaceholder[name].holder;
            }
            // is case replace root, the replaceTarget.parentElement can be null
            if (replaceSrc !== replaceTarget && replaceTarget.parentElement) {
                replaceTarget.parentElement.replaceChild(replaceSrc, replaceTarget);
            }
            // detach old
            if (oldWidget) {
                this.detachElement(oldWidget.node);
                this.checkAndUnbindUI(oldWidget.node);
                if (isReplaceRoot) {
                    this.widget.core.unbindUI("node");
                }
            }
            if (widget) {
                // transfer static property to it
                // transfer dynamic property to it and bind UI
                let holder = this.subWidgetPlaceholder[name];
                this.transferProperties(widget.node, holder.dynamics);
                this.attachElement(widget.node, null);
                widget.core.fillSlots(this.subWidgetPlaceholder[name].slots);
            }
            if (isReplaceRoot) {
                this.widget.node = widget.node;
                this.widget.core.bindUI(widget.node, "node");
            }
        }
        attachDynamicProperty(el, dynamics) {
            if (!el.propertyConfigs)
                el.propertyConfigs = [];
            //console.log("attach", dynamics, el.propertyConfigs)
            let todo = [];
            this.widget.ViewModel.events.stopListenBy(el);
            if (dynamics) {
                el.propertyConfigs.push({ master: this.widget, rules: dynamics });
            }
            for (let config of el.propertyConfigs) {
                // already attached
                if (config.master === this.widget) {
                    todo.push(config.rules);
                }
            }
            if (todo.length > 1) {
                console.warn("Multiple dynamic attaches");
                console.trace();
            }
            for (let dynamics of todo) {
                for (let name in dynamics) {
                    let config = dynamics[name];
                    for (let part of config.templates) {
                        if (part.type === "raw")
                            continue;
                        let root = Leaf.CoreLogic.getPropertyRoot(part.content);
                        this.widget.ViewModel.events.listenBy(el, [`change/${root}`, `depChange/${root}`], this.syncDynamicProperty.bind(this, el, name));
                    }
                }
            }
        }
        detachDynamicProperty(el) {
            // Detach and remove properties
            if (!el)
                return;
            if (!el.propertyConfigs)
                el.propertyConfigs = [];
            el.propertyConfigs = el.propertyConfigs.filter(item => item.master !== this.widget);
            this.widget.ViewModel.events.stopListenBy(el);
        }
        attachDynamicText(text, rule) {
            for (let part of rule.templates) {
                if (part.type === "raw")
                    continue;
                let root = Leaf.CoreLogic.getPropertyRoot(part.content);
                this.widget.ViewModel.events.listenBy(text, [`change/${root}`, `depChange/${root}`], this.syncDynamicText.bind(this, text, rule));
            }
        }
        detachDynamicText(text) {
            this.widget.ViewModel.events.stopListenBy(text);
        }
        extractTemplates(node) {
            let result = {};
            let templates = node.querySelectorAll("template");
            for (let i = 0; i < templates.length; i++) {
                let item = templates[i];
                if (node.contains(item)) {
                    item.parentElement.removeChild(item);
                    let name = item.getAttribute("data-name");
                    if (name) {
                        result[name] = item.innerHTML;
                    }
                }
            }
            return result;
        }
        defineSlot(name, el, dynamics) {
            // refactor slot implementation and abstract it to the same
            // way as subwidget.
            this.slotsPlaceholder[name] = {
                el: el,
                name: name,
                index: this.slotIndexOffset++,
                dynamics: dynamics
            };
        }
        fillSlots(slots) {
            for (let i = 0; i < slots.length; i++) {
                let slot = slots[i];
                let holder = this.getSlotHolder(slot.name, i);
                if (holder) {
                    holder.el.parentElement.replaceChild(slot.el, holder.el);
                    holder.el = slot.el;
                    this.transferProperties(slot.el, holder.dynamics);
                    this.bindUI(slot.el, holder.name);
                }
            }
        }
        extractDynamicStringConfig(content) {
            let config = Leaf.CoreLogic.createDynamicValueConfigs(content);
            return {
                templates: config
            };
        }
        mergeProps(from, to, props) {
            for (let prop of props) {
                let toPropValue = to.getAttribute(prop);
                let fromPropValue = from.getAttribute(prop);
                if (fromPropValue !== toPropValue) {
                    if (Leaf.CoreLogic.isPropertyMergable(prop)) {
                        to.setAttribute(prop, Leaf.CoreLogic.mergeProperty(prop, [fromPropValue, toPropValue]));
                    }
                    else {
                        to.setAttribute(prop, fromPropValue);
                    }
                }
            }
        }
        transferProperties(to, dynamics) {
            if (!to.propertyConfigs)
                to.propertyConfigs = [];
            to.propertyConfigs = to.propertyConfigs.filter(item => item.master !== this.widget);
            dynamics = Leaf.Util.clone(dynamics);
            this.attachDynamicProperty(to, dynamics);
            this.syncDynamicProperties(to);
        }
        defineList(name, el) {
            let list = this.widget[name] = Leaf.Widget.makeList(el);
            let events = ["child/add", "child/remove"];
            for (let event of events) {
                let camelEventName = event.replace(/\/[a-z]/ig, (match) => {
                    return match[1].toUpperCase();
                });
                let handlerName = `on` + Leaf.Util.capitalize(camelEventName) + Leaf.Util.capitalize(name);
                Leaf.Property.define(this.widget, handlerName, {
                    set: (value, cache) => {
                        if (cache.value) {
                            this.widget[name].events.removeEventListener(event, cache.value);
                        }
                        if (value) {
                            cache.value = (...args) => {
                                value.apply(this.widget, args);
                            };
                            this.widget[name].events.on(event, cache.value);
                        }
                        else {
                            cache.value = null;
                        }
                    }
                });
                if (this.widget[handlerName]) {
                    this.widget[handlerName] = this.widget[handlerName];
                }
            }
            list.events.listenBy(this, "child/remove", (child) => {
                child.events.stopListenBy(this);
            });
        }
        getPropsFromElement(el) {
            let result = {};
            let attrs = el.attributes;
            for (let i = 0; i < attrs.length; i++) {
                let item = attrs[i];
                result[item.name] = item.value;
            }
            return result;
        }
        getChildrenAsSlot(el) {
            let slots = [];
            if (el.childNodes.length === 1 && el.childNodes[0] instanceof Text) {
                let result = document.createElement("span");
                result.appendChild(el.childNodes[0]);
                return [{
                        el: result,
                        name: "slot0"
                    }];
            }
            for (let i = 0; i < el.children.length; i++) {
                let item = el.children[i];
                let name = item.getAttribute("data-slot") || `slot${i}`;
                slots.push({ name, el: item });
            }
            return slots;
        }
        getSlotHolder(name, index) {
            for (let s in this.slotsPlaceholder) {
                let item = this.slotsPlaceholder[s];
                if (item.name === name)
                    return item;
            }
            for (let s in this.slotsPlaceholder) {
                let item = this.slotsPlaceholder[s];
                if (item.index === index)
                    return item;
            }
            return null;
        }
    }
    Leaf.WidgetCore = WidgetCore;
    class WidgetInitializer extends WidgetInitializerDesign {
        initTemplate(template) {
            if (!template) {
                template = document.createElement("div");
            }
            // All kind of template
            if (typeof template === "string") {
                let tempNode = document.createElement("div");
                tempNode.innerHTML = template.trim();
                this.widget.node = tempNode.children[0];
                tempNode.removeChild(this.widget.node);
            }
            else if (template instanceof Element) {
                this.widget.node = template;
            }
            else if (typeof template === "function") {
                return this.initTemplate(template());
            }
            if (!this.widget.node) {
                console.error("Invalid Widget.node constructed with template", template);
                throw new Error("BrokenWidgetTemplate");
            }
            //if (this.widget.node.getAttribute("data-id")) {
            //    console.error("Shouldn't bind data-id on root of the any widget you can always refer to them as `node`. `data-id` may latter be assigned by parent widget.");
            //    throw new Error("Invalid data id assignment")
            //}
            if (this.widget.node.nodeType === this.widget.node.TEXT_NODE)
                return;
            this.widget.templates = this.widget.core.extractTemplates(this.widget.node);
            this.traverseAndInitialize(this.widget.node);
            this.widget.core.bindUI(this.widget.node, "node");
            this.widget.node.widget = this.widget;
        }
        traverseAndInitialize(node) {
            if (node instanceof HTMLElement) {
                for (let i = 0; i < node.childNodes.length; i++) {
                    let item = node.childNodes[i];
                    this.traverseAndInitialize(item);
                }
                let config = this.widget.core.extractDynamicPropertyConfig(node);
                this.widget.core.attachElement(node, config);
            }
            else if (node instanceof Text) {
                let config = this.widget.core.extractDynamicStringConfig(node.textContent);
                this.widget.core.attachText(node, config);
            }
        }
        createElement(tagName, properties, children) {
            let el = document.createElement(tagName);
            let frag = document.createDocumentFragment();
            for (let child of children) {
                frag.appendChild(child);
            }
            let dynamics = {};
            for (let name in properties) {
                let v = properties[name];
                if (typeof v === "string") {
                    el.setAttribute(name, v);
                    el[name] = v;
                }
                else {
                    dynamics[name] = v;
                    el.setAttribute(name, Leaf.CoreLogic.explainDynamicString(this.widget.ViewModel.tree, v));
                }
            }
            el.appendChild(frag);
            el = this.widget.core.attachElement(el, dynamics);
            return el;
        }
        createText(rule) {
            let text = document.createTextNode("");
            this.widget.core.attachText(text, rule);
            return text;
        }
    }
    Leaf.WidgetInitializer = WidgetInitializer;
    class WidgetDOMEventDelegator {
        constructor(widget) {
            this.widget = widget;
            this.lazyHandlers = {};
        }
        prepareUIDelegates(uiName) {
            if (this.lazyHandlers[uiName])
                return;
            this.lazyHandlers[uiName] = {};
            let events = Leaf.CoreLogic.AllEvents.slice(0);
            let ui = this.widget.UI[uiName];
            if (ui.widget && ui.widget.providingEvents && ui.widget.providingEvents.length > 0) {
                events = events.concat(ui.widget.providingEvents);
            }
            for (let event of events) {
                this.prepareUIDelegate(uiName, event.name);
            }
        }
        prepareUIDelegate(uiName, eventName) {
            if (this.lazyHandlers[uiName][eventName])
                return;
            this.lazyHandlers[uiName][eventName] = {};
            let handlerName = `on${Leaf.Util.capitalize(eventName)}${Leaf.Util.capitalize(uiName)}`;
            Leaf.Property.define(this.widget, handlerName, {
                set: (v, cache) => {
                    if (typeof v != "function")
                        return;
                    cache.value = v;
                    this.unbindLazyHandler(uiName, eventName);
                    this.provideLazyHandler(uiName, eventName, v);
                    this.bindLazyHandler(uiName, eventName);
                }
            });
            // only set handler, dont' unbind or bind it.
            // apply/clear delegate will do it.
            if (this.widget[handlerName]) {
                this.provideLazyHandler(uiName, eventName, this.widget[handlerName]);
            }
            // for onClick => onClickNode
            if (uiName === "node") {
                let handlerName = `on${Leaf.Util.capitalize(eventName)}`;
                Leaf.Property.define(this, handlerName, {
                    set: (v, cache) => {
                        if (typeof v != "function")
                            return;
                        cache.value = v;
                        this.unbindLazyHandler(uiName, eventName);
                        this.provideLazyHandler(uiName, eventName, v);
                        this.bindLazyHandler(uiName, eventName);
                    }
                });
                if (this.widget[handlerName]) {
                    this.provideLazyHandler(uiName, eventName, this.widget[handlerName]);
                }
            }
        }
        // call unbind/bind/provide carefully, or just don't call them.
        unbindLazyHandler(uiName, eventName) {
            let owner = this.widget.UI[uiName];
            let info = this.lazyHandlers[uiName][eventName] || {};
            if (info.handler) {
                owner.removeEventListener(eventName, info.handler);
            }
        }
        bindLazyHandler(uiName, eventName) {
            let owner = this.widget.UI[uiName];
            let info = this.lazyHandlers[uiName][eventName] || {};
            if (info.handler) {
                owner.addEventListener(eventName, info.handler);
            }
        }
        provideLazyHandler(uiName, eventName, v) {
            let handler = (e) => {
                e.capture = () => {
                    e.stopImmediatePropagation();
                    e.preventDefault();
                };
                v.call(this.widget, e);
            };
            this.lazyHandlers[uiName][eventName].handler = handler;
        }
        clearUIDelegateOwner(id) {
            if (!this.widget.UI[id])
                return;
            let owner = this.widget.UI[id];
            let infos = this.lazyHandlers[id] || {};
            for (let eventName in infos) {
                let info = infos[eventName];
                if (info.handler) {
                    owner.removeEventListener(eventName, info.handler);
                }
            }
        }
        // Carefull call apply UI delegate owner
        // 1. call clear
        // 2. set UI[uiName]
        // 3. call apply
        // Always call them like above.
        // But feel free to call `clear` at any time.
        applyUIDelegateOwner(id) {
            if (!this.widget.UI[id])
                return;
            let owner = this.widget.UI[id];
            this.prepareUIDelegates(id);
            let infos = this.lazyHandlers[id];
            // bind any existing events
            for (let eventName in infos) {
                let info = infos[eventName];
                if (info.handler) {
                    owner.addEventListener(eventName, info.handler);
                }
            }
        }
        delegateTo(name, event) {
            let fnName = `on${Leaf.Util.capitalize(event.type)}${Leaf.Util.capitalize(name)}`;
            let fn = this.widget[fnName];
            if (!fn) {
                return true;
            }
            return fn.call(this.widget, event);
        }
    }
    Leaf.WidgetDOMEventDelegator = WidgetDOMEventDelegator;
    class WidgetSlotBehavior {
        constructor(widget) {
            this.widget = widget;
        }
        fill(...infos) {
            if (infos[0] instanceof Leaf.Widget) {
                this.fillSequentially(...infos);
            }
            else {
                this.fillNamingly(infos[0]);
            }
        }
        fillSequentially(...widgets) {
            let slots = widgets.map(widget => {
                return {
                    name: "#",
                    el: widget.node
                };
            });
            this.widget.core.fillSlots(slots);
        }
        fillNamingly(infos) {
            let slots = Object.keys(infos).map((name) => {
                return {
                    name, el: infos[name].node
                };
            });
            this.widget.core.fillSlots(slots);
        }
    }
    Leaf.WidgetSlotBehavior = WidgetSlotBehavior;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts" />
var Leaf;
(function (Leaf) {
    class Widget {
        // Set custom template for this module
        static setTemplate(template) {
            this.prototype.template = template;
        }
        toString() {
            return `<Widget ${this.package && `(${this.package}):`}${this.widgetName}>`;
        }
        before(who) {
            let node;
            if (who instanceof Widget) {
                node = who.node;
            }
            else {
                node = who;
            }
            if (!node.parentElement)
                return false;
            node.parentElement.insertBefore(this.node, node);
            return true;
        }
        after(who) {
            let node;
            if (who instanceof Widget) {
                node = who.node;
            }
            else {
                node = who;
            }
            if (!node.parentElement)
                return false;
            if (node.nextSibling) {
                node.parentElement.insertBefore(this.node, node.nextSibling);
            }
            else {
                node.parentElement.appendChild(this.node);
            }
            return true;
        }
        prependTo(who) {
            let node;
            if (who instanceof Widget) {
                node = who.node;
            }
            else {
                node = who;
            }
            if (node.children.length === 0) {
                node.appendChild(this.node);
            }
            else {
                let first = node.children[0];
                node.insertBefore(this.node, first);
            }
            return true;
        }
        appendTo(who) {
            let node;
            if (who instanceof Widget) {
                node = who.node;
            }
            else {
                node = who;
            }
            node.appendChild(this.node);
            return true;
        }
        constructor(template, name, _VMFields = []) {
            this.template = template;
            this._VMFields = _VMFields;
            // Global namespace
            this.isWidget = true;
            // Use global namespace by default
            this.namespace = Widget.namespace;
            // If direct parent widget that contains this widget
            this.parent = null;
            // By default every widget has a event emitter
            this.events = new Leaf.EventEmitter();
            // All element with data-id
            this.UI = {};
            // Custom DOM events that this widget may trigger
            this.providingEvents = [];
            // Event that we should delegate (bubble or not)
            this.interestingUnbubblingEvents = Leaf.CoreLogic.UnbubbleEvents.slice(0);
            this.interestingBubblingEvents = Leaf.CoreLogic.BubbleEvents.slice(0);
            this.core = new Leaf.WidgetCore(this);
            this.delegates = new Leaf.WidgetDOMEventDelegator(this);
            this.initializer = new Leaf.WidgetInitializer(this);
            this.package = null;
            if (name) {
                this.widgetName = this.widgetName || (this.constructor.name) || "AnonymouseWidget";
            }
            // Setup ViewModals
            if (!this._VMFields) {
                this._VMFields = [];
            }
            this.ViewModel = new Leaf.ViewModel(this.widgetName, this._VMFields);
            Leaf.Property.define(this, "VM", {
                get: () => {
                    // for nont proxy
                    if (typeof Proxy === "undefined")
                        return this.ViewModel;
                    return this.ViewModel.tree.getNode().getProxyOrValue();
                },
                set: (values) => {
                    return this.ViewModel.sets(values);
                }
            });
            Leaf.Property.define(this, "VMNest", {
                get: () => {
                    return this.ViewModel.tree.getNode().getProxyOrValue();
                },
                set: (values) => {
                    return this.ViewModel.sets(values);
                }
            });
            // If we don't have a template, dont initialize it
            // Maybe we are generated widget, or maybe we gonna do it latter.
            Leaf.Property.define(this, "asSlot", {
                get: () => {
                    if (!this._asSlot)
                        this._asSlot = new Leaf.WidgetSlotBehavior(this);
                    return this._asSlot;
                },
            });
            this.initializer.initTemplate(template);
            Widget.events.emit("create", this);
        }
        static makeList(el) {
            return new Leaf.List(el);
        }
        emitDOMEvent(name, bubble, props = {}) {
            let valid = this.providingEvents.some((info) => {
                return info.name === name;
            });
            if (!valid) {
                throw new Error(`Should add events ${name}to available events at construtor`);
            }
            let e = new CustomEvent(name, {
                bubbles: bubble,
                cancelable: true
            });
            for (let prop in props) {
                e[prop] = props[prop];
            }
            this.node.dispatchEvent(e);
        }
        emitWidgetEvent(name, value = {}) {
            this.events.emit(name, value);
            this.emitDOMEvent(name, false, value);
        }
        include(W) {
            this.namespace.include(W);
        }
        expose(name, remoteName) {
            if (!remoteName) {
                remoteName = name;
            }
            if (typeof this[name] === "function") {
                Object.defineProperty(this.node, remoteName, {
                    get: () => {
                        return this[name].bind(this);
                    }
                });
                return;
            }
            let cap = Leaf.Util.capitalize(name);
            let getterName = `onGet${cap}`;
            let setterName = `onSet${cap}`;
            Object.defineProperty(this.node, remoteName, {
                get: () => {
                    if (this[getterName])
                        return this[getterName]();
                    else
                        return this[name];
                },
                set: (value) => {
                    if (this[setterName])
                        return this[setterName](value);
                    else
                        return this[name] = value;
                }
            });
        }
        makeList(who) {
            let el;
            let name;
            if (typeof who === "string") {
                el = this.UI[who];
                name = who;
            }
            else {
                for (let prop in this.UI) {
                    if (this.UI[prop] === who) {
                        el = who;
                        name = prop;
                        break;
                    }
                }
                if (!name) {
                    return;
                }
            }
            let list = Leaf.Widget.makeList(el);
            list.events.listenBy(this, "child/add", (item) => {
                let fn = this[`onChildAdd${Leaf.Util.capitalize(name)}`];
                if (fn) {
                    fn.call(this, item);
                }
            });
            list.events.listenBy(this, "child/remove", (item) => {
                let fn = this[`onChildRemove${Leaf.Util.capitalize(name)}`];
                if (fn) {
                    fn.call(this, item);
                }
            });
            if (!this[name]) {
                this[name] = list;
            }
            return list;
        }
        behave(handler) {
            // This may not work property in browser without defineProperty
            for (let key in handler) {
                this[key] = handler[key];
            }
        }
    }
    Widget.namespace = new Leaf.Namespace();
    Widget.events = Leaf.ensureGlobal("WidgetEvents", () => new Leaf.EventEmitter());
    Leaf.Widget = Widget;
    class GeneratedWidget extends Widget {
        constructor(generator, name, _VMFields = []) {
            super(null, name, _VMFields);
            this.generator = generator;
            this._VMFields = _VMFields;
            this.BindedWidgets = [];
            this.BindedLists = [];
            this.TestDatas = [];
            this.InitialData = null;
            this.initGeneratedTemplate(generator.call(this));
        }
        initGeneratedTemplate(node) {
            this.node = node;
            this.core.bindUI(this.node, "node");
            if (!this.node.widget) {
                // in case it's a shared node by it's child
                // the child will own it
                this.node.widget = this;
            }
        }
        _e(tagName, properties, children) {
            return this.initializer.createElement(tagName, properties, children);
        }
        _t(rule) {
            return this.initializer.createText(rule);
        }
        renderRecursive(data = {}, R = this["R"] || {}) {
            for (let widget of this.BindedWidgets) {
                if (!this[widget.name]) {
                    let Cons = this.resolveWidgetByPath(R, widget.path);
                    if (!Cons) {
                        //console.error("Invalid constructor", widget.path)
                        continue;
                    }
                    this[widget.name] = new Cons();
                }
                if (data[widget.name] && this[widget.name]["renderRecursive"]) {
                    this[widget.name]["renderRecursive"](data[widget.name]);
                }
            }
            for (let list of this.BindedLists) {
                if (this[list.name] && Array.isArray(data[list.name])) {
                    let Cons = this.resolveWidgetByPath(R, list.reference);
                    if (!Cons)
                        continue;
                    this[list.name].empty();
                    for (let sub of data[list.name]) {
                        let child = new Cons();
                        this[list.name].push(child);
                        if (child["renderRecursive"]) {
                            child["renderRecursive"](sub);
                        }
                        else {
                            child.VM = sub;
                        }
                    }
                }
            }
            for (let name of this._VMFields) {
                if (data[name]) {
                    this.VM[name] = data[name];
                }
            }
        }
        resolveWidgetByPath(R, path) {
            if (!path)
                return null;
            let routes = path.split("/").filter(item => item);
            let cur = R;
            for (let route of routes) {
                route = Leaf.Util.capitalize(route);
                if (!cur[route])
                    return null;
                cur = cur[route];
            }
            return cur;
        }
    }
    Leaf.GeneratedWidget = GeneratedWidget;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts" />
/// <reference path="widget.ts" />
var Leaf;
(function (Leaf) {
    class List extends Leaf.Widget {
        constructor(el) {
            super(el, "List");
            this._length = 0;
            this.length = 0;
            let arrayFnsNames = ["map", "forEach", "slice", "every", "some", "filter"];
            for (let name of arrayFnsNames) {
                this[name] = (...args) => {
                    let arr = this.toArray();
                    return arr[name].apply(arr, args);
                };
            }
            Object.defineProperty(this, "length", {
                get: () => {
                    return this._length;
                },
                set: (v) => {
                    let toRemove = [];
                    if (v > this._length) {
                        throw new Error("can't asign length larger than the orig");
                    }
                    if (typeof v != "number") {
                        throw new TypeError();
                    }
                    for (let i = v; i < this._length; i++) {
                        toRemove.push(this[i]);
                        delete this[i];
                    }
                    this._length = v;
                    for (let item of toRemove) {
                        this.detach(item);
                    }
                }
            });
            this._length = 0;
        }
        fill(datas, Cons) {
            this.empty();
            for (let item of datas) {
                let widget = new Cons(item);
                for (let name of widget._VMFields) {
                    if (typeof item[name] !== "undefined") {
                        widget.VM[name] = item[name];
                    }
                }
                widget.ListItemData = item;
                this.push(widget);
            }
        }
        empty() {
            let toRemove = [];
            for (let i = 0; i < this._length; i++) {
                toRemove.push(this[i]);
                delete this[i];
            }
            for (let item of toRemove) {
                this.detach(item);
            }
            this._length = 0;
        }
        indexOf(item) {
            for (let i = 0; i < this._length; i++) {
                if (this[i] === item) {
                    return i;
                }
            }
            return -1;
        }
        check(item) {
            if (!(item instanceof Leaf.Widget)) {
                throw new Error("List expect item to be Widget");
            }
            for (let i = 0; i < this._length; i++) {
                if (this[i] === item) {
                    throw new Error("Duplicate ListItem");
                }
            }
            return true;
        }
        push(...items) {
            for (let item of items) {
                this.check(item);
                this[this._length] = item;
                if (this._length != 0) {
                    item.after(this[this._length - 1]);
                }
                else {
                    item.appendTo(this.node);
                }
                this._length += 1;
                this.attach(item);
            }
        }
        pop() {
            if (this._length === 0)
                return null;
            this._length -= 1;
            let item = this[this._length];
            delete this[this._length];
            return item;
        }
        unshift(item) {
            this.check(item);
            if (this._length === 0) {
                item.prependTo(this.node);
                this[0] = item;
                this._length = 1;
                this.attach(item);
                return;
            }
            for (let index = this._length; index > 0; index -= 1) {
                this[index] = this[index - 1];
            }
            this[0] = item;
            this._length += 1;
            item.before(this[1]);
            this.attach(item);
            return this._length;
        }
        shift() {
            let result = this[0];
            for (let index = 0; index < this._length; index++) {
                this[index] = this[index + 1];
            }
            this._length -= 1;
            this.detach(result);
            return result;
        }
        splice(index, count, ...toAdd) {
            let result = [];
            let toRemoves = [];
            if (typeof count != "number" || index + count > this._length) {
                count === this._length - index;
            }
            for (let i = 0; i < count; i++) {
                let item = this[index + i];
                toRemoves.push(item);
                result.push(item);
            }
            let toAddFinal = toAdd;
            let frag = document.createDocumentFragment();
            toAddFinal.forEach((item) => {
                this.check(item);
                frag.appendChild(item.node);
            });
            if (index < this._length && this._length > 0) {
                this.node.insertBefore(frag, this[index].node);
            }
            else {
                this.node.appendChild(frag);
            }
            // make a hole
            let increase = toAddFinal.length - count;
            if (increase < 0) {
                for (let origin = index + count; origin < this._length; origin++) {
                    this[origin + increase] = this[origin];
                }
            }
            else if (increase > 0) {
                for (let origin = this._length - 1; origin > index + count - 1; origin--) {
                    this[origin + increase] = this[origin];
                }
            }
            // fill the hole
            for (let offset = 0; offset < toAddFinal.length; offset++) {
                let item = toAddFinal[offset];
                this[index + offset] = item;
            }
            this._length += increase;
            for (let item of toRemoves) {
                this.detach(item);
            }
            for (let item of toAddFinal) {
                this.attach(item);
            }
            return result;
        }
        removeItem(item) {
            let index = this.indexOf(item);
            if (index < 0)
                return;
            this.splice(index, 1);
            return item;
        }
        attach(item) {
            item["parentList"] = this;
            if (item["onPresent"])
                item["onPresent"]();
            this.events.emit("child/add", item);
            this.events.emit("child/change");
        }
        detach(item) {
            item["parentList"] = null;
            let node = item.node;
            if (node && node.parentElement === this.node) {
                this.node.removeChild(node);
            }
            if (item["onHang"])
                item["onHang"]();
            this.events.emit("child/remove", item);
            this.events.emit("child/change");
        }
        toArray() {
            let result = [];
            for (let i = 0; i < this._length; i++) {
                result.push(this[i]);
            }
            return result;
        }
    }
    Leaf.List = List;
})(Leaf || (Leaf = {}));
/// <reference path="../leaf.ts"/>
var Leaf;
(function (Leaf) {
    let CoreLogic;
    (function (CoreLogic) {
        function createDynamicValueConfigs(templateString) {
            let templates = [];
            let reg = /\{\{\s*!?([a-z0-9\.]+(:[a-z0-9\-]+)?)\s*\}\}/ig;
            let match;
            let lastIndex = 0;
            let hasValue = false;
            while (match = reg.exec(templateString)) {
                if (match.index > lastIndex) {
                    templates.push({
                        type: "raw",
                        content: templateString.slice(lastIndex, match.index)
                    });
                }
                let content = match[0].slice(2).slice(0, -2);
                if (!content)
                    continue;
                let [k, v] = content.split(":").map((item) => { return item.trim(); });
                let reverse = false;
                if (k[0] == "!") {
                    k = k.slice(1);
                    reverse = true;
                }
                templates.push({
                    type: "value",
                    content: k,
                    value: v,
                    reverse: reverse
                });
                hasValue = true;
                lastIndex = match.index + match[0].length;
            }
            if (lastIndex < templateString.length) {
                templates.push({
                    type: "raw",
                    content: templateString.slice(lastIndex)
                });
            }
            return templates;
        }
        CoreLogic.createDynamicValueConfigs = createDynamicValueConfigs;
        CoreLogic.MergablePropertyNames = ["class"];
        function isPropertyMergable(name) {
            return CoreLogic.MergablePropertyNames.indexOf(name) >= 0;
        }
        CoreLogic.isPropertyMergable = isPropertyMergable;
        function mergeProperty(name, values) {
            if (name === "class") {
                let names = [];
                for (let value of values) {
                    let todos = value.split(" ").map(item => item.trim()).filter(item => !!item);
                    for (name of todos) {
                        if (names.indexOf(name) < 0)
                            names.push(name);
                    }
                }
                return names.join(" ");
            }
            else {
                return values.join(" ");
            }
        }
        CoreLogic.mergeProperty = mergeProperty;
        CoreLogic.BubbleEvents = ["click", "mouseup", "mousedown", "mousemove", "mouseleave", "mouseenter", "mouseover", "keydown", "keyup", "keypress", "touchstart", "touchend", "touchmove", "input"].map((name) => {
            return { name, bubble: true };
        });
        CoreLogic.UnbubbleEvents = [{
                name: "focus",
                bubble: false,
                target: ["input", "textarea"]
            }, {
                name: "blur",
                bubble: false,
                target: ["input", "textarea"]
            }, {
                name: "submit",
                bubble: false,
                target: ["form"]
            }, {
                name: "change",
                bubble: false,
                target: ["input", "textarea", "select"]
            }];
        CoreLogic.AllEvents = CoreLogic.BubbleEvents.concat(CoreLogic.UnbubbleEvents);
        function explainDynamicString(model, config) {
            let result = [];
            for (let item of config.templates) {
                result.push(explainDynamicValue(model, item));
            }
            return result.join("");
        }
        CoreLogic.explainDynamicString = explainDynamicString;
        function explainDynamicValue(tree, config) {
            if (config.type === "raw") {
                return config.content;
            }
            else {
                let mayReverse = (v) => {
                    if (typeof v === "boolean") {
                        if (config.reverse)
                            return !v;
                        return v;
                    }
                    if (typeof v === "undefined") {
                        return !!config.reverse;
                    }
                    return v;
                };
                let vmValue = tree.getValueByPath(config.content);
                if (typeof vmValue === "function") {
                    vmValue = vmValue();
                }
                let value = config.value || null;
                // for {{class}} value as true, use name as className
                let rev = mayReverse(vmValue);
                if (rev === true) {
                    if (value) {
                        return value;
                    }
                    value = Leaf.Util.camelToSlug(config.content);
                    return value;
                }
                else if (rev === false) {
                    return "";
                }
                if (rev && rev.toString() && value) {
                    return value;
                }
                if (typeof vmValue === "undefined" || vmValue === null) {
                    return "";
                }
                return vmValue.toString() || "";
            }
        }
        CoreLogic.explainDynamicValue = explainDynamicValue;
        function getPropertyRoot(str) {
            return str.split(".")[0];
        }
        CoreLogic.getPropertyRoot = getPropertyRoot;
    })(CoreLogic = Leaf.CoreLogic || (Leaf.CoreLogic = {}));
})(Leaf || (Leaf = {}));
/// <reference path="leaf.ts"/[""]
var Leaf;
(function (Leaf) {
    let Key;
    (function (Key) {
        Key["0"] = 48;
        Key["1"] = 49;
        Key["2"] = 50;
        Key["3"] = 51;
        Key["4"] = 52;
        Key["5"] = 53;
        Key["6"] = 54;
        Key["7"] = 55;
        Key["8"] = 56;
        Key["9"] = 57;
        Key.cmd = 224;
        let browser = Leaf.Util.browser;
        if (browser) {
            if (browser.name === "firefox") {
                Key.cmd = 224;
            }
            else if (browser.name === "opera") {
                Key.cmd = 17;
            }
            else {
                Key.cmd = 91;
            }
        }
        else {
            Key.cmd = 91;
        }
        Key.a = 65;
        Key.b = 66;
        Key.c = 67;
        Key.d = 68;
        Key.e = 69;
        Key.f = 70;
        Key.g = 71;
        Key.h = 72;
        Key.i = 73;
        Key.j = 74;
        Key.k = 75;
        Key.l = 76;
        Key.m = 77;
        Key.n = 78;
        Key.o = 79;
        Key.p = 80;
        Key.q = 81;
        Key.r = 82;
        Key.s = 83;
        Key.t = 84;
        Key.u = 85;
        Key.v = 86;
        Key.w = 87;
        Key.x = 88;
        Key.y = 89;
        Key.z = 90;
        Key.space = 32;
        Key.shift = 16;
        Key.ctrl = 17;
        Key.alt = 18;
        Key.left = 37;
        Key.up = 38;
        Key.right = 39;
        Key.down = 40;
        Key.enter = 13;
        Key.backspace = 8;
        Key.escape = 27;
        Key.del = 46;
        Key["delete"] = 46;
        Key.esc = 27;
        Key.pageup = 33;
        Key.pagedown = 34;
        Key.tab = 9;
        Key.home = 36;
        Key.end = 35;
        Key.quote = 222;
        Key.openBracket = 219;
        Key.closeBracket = 221;
        Key.backSlash = 220;
        Key.slash = 191;
        Key.equal = 187;
        Key.comma = 188;
        Key.period = 190;
        Key.dash = 189;
        Key.semicolon = 186;
        Key.graveAccent = 192;
    })(Key = Leaf.Key || (Leaf.Key = {}));
    let Mouse;
    (function (Mouse) {
        Mouse.left = 0;
        Mouse.middle = 1;
        Mouse.right = 2;
    })(Mouse = Leaf.Mouse || (Leaf.Mouse = {}));
})(Leaf || (Leaf = {}));
/// <reference path="./type.d.ts"/>
/// <reference path="./global.ts"/>
/// <reference path="./errors.ts" />
/// <reference path="./core/tag.ts" />
/// <reference path="./core/property.ts" />
/// <reference path="./core/logger.ts" />
/// <reference path="./core/serialize.ts" />
/// <reference path="./core/render.ts" />
/// <reference path="./core/time.ts"/>
/// <reference path="./core/events.ts" />
/// <reference path="./core/situations.ts" />
/// <reference path="./core/hooker.ts" />
/// <reference path="./core/states.ts" />
/// <reference path="./core/apiFactory.ts" />
/// <reference path="./core/rpcCenter.ts" />
/// <reference path="./core/async.ts"/>
/// <reference path="./core/service.ts"/>
/// <reference path="./core/referencer.ts"/>
/// <reference path="./util/util.ts" />
/// <reference path="./util/behavior.ts"/>
/// <reference path="./util/debounce.ts"/>
/// <reference path="./util/decorator.ts"/>
/// <reference path="./widget/types.ts"/>
/// <reference path="./widget/model.ts" />
/// <reference path="./widget/viewModel.ts" />
/// <reference path="./widget/namespace.ts" />
/// <reference path="./widget/widgetBase.ts" />
/// <reference path="./widget/widget.ts" />
/// <reference path="./widget/list.ts" />
/// <reference path="./widget/coreLogic.ts"/>
/// <reference path="./etc.ts"/>
var Leaf;
(function (Leaf) {
    if (true) {
        module.exports = Leaf.ensureGlobal("Leaf", () => {
            return Leaf;
        });
    }
    globalThis["Leaf"] = Leaf.ensureGlobal("Leaf", () => {
        return Leaf;
    });
})(Leaf || (Leaf = {}));


/***/ }),

/***/ "./node_modules/path/path.js":
/*!***********************************!*\
  !*** ./node_modules/path/path.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.




var isWindows = process.platform === 'win32';
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");


// resolves . and .. elements in a path array with directory names there
// must be no slashes or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  var res = [];
  for (var i = 0; i < parts.length; i++) {
    var p = parts[i];

    // ignore empty parts
    if (!p || p === '.')
      continue;

    if (p === '..') {
      if (res.length && res[res.length - 1] !== '..') {
        res.pop();
      } else if (allowAboveRoot) {
        res.push('..');
      }
    } else {
      res.push(p);
    }
  }

  return res;
}

// returns an array with empty elements removed from either end of the input
// array or the original array if no elements need to be removed
function trimArray(arr) {
  var lastIndex = arr.length - 1;
  var start = 0;
  for (; start <= lastIndex; start++) {
    if (arr[start])
      break;
  }

  var end = lastIndex;
  for (; end >= 0; end--) {
    if (arr[end])
      break;
  }

  if (start === 0 && end === lastIndex)
    return arr;
  if (start > end)
    return [];
  return arr.slice(start, end + 1);
}

// Regex to split a windows path into three parts: [*, device, slash,
// tail] windows-only
var splitDeviceRe =
    /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;

// Regex to split the tail part of the above into [*, dir, basename, ext]
var splitTailRe =
    /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;

var win32 = {};

// Function to split a filename into [root, dir, basename, ext]
function win32SplitPath(filename) {
  // Separate device+slash from tail
  var result = splitDeviceRe.exec(filename),
      device = (result[1] || '') + (result[2] || ''),
      tail = result[3] || '';
  // Split the tail into dir, basename and extension
  var result2 = splitTailRe.exec(tail),
      dir = result2[1],
      basename = result2[2],
      ext = result2[3];
  return [device, dir, basename, ext];
}

function win32StatPath(path) {
  var result = splitDeviceRe.exec(path),
      device = result[1] || '',
      isUnc = !!device && device[1] !== ':';
  return {
    device: device,
    isUnc: isUnc,
    isAbsolute: isUnc || !!result[2], // UNC paths are always absolute
    tail: result[3]
  };
}

function normalizeUNCRoot(device) {
  return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
}

// path.resolve([from ...], to)
win32.resolve = function() {
  var resolvedDevice = '',
      resolvedTail = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1; i--) {
    var path;
    if (i >= 0) {
      path = arguments[i];
    } else if (!resolvedDevice) {
      path = process.cwd();
    } else {
      // Windows has the concept of drive-specific current working
      // directories. If we've resolved a drive letter but not yet an
      // absolute path, get cwd for that drive. We're sure the device is not
      // an unc path at this points, because unc paths are always absolute.
      path = process.env['=' + resolvedDevice];
      // Verify that a drive-local cwd was found and that it actually points
      // to our drive. If not, default to the drive's root.
      if (!path || path.substr(0, 3).toLowerCase() !==
          resolvedDevice.toLowerCase() + '\\') {
        path = resolvedDevice + '\\';
      }
    }

    // Skip empty and invalid entries
    if (!util.isString(path)) {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    var result = win32StatPath(path),
        device = result.device,
        isUnc = result.isUnc,
        isAbsolute = result.isAbsolute,
        tail = result.tail;

    if (device &&
        resolvedDevice &&
        device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      // This path points to another device so it is not applicable
      continue;
    }

    if (!resolvedDevice) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = tail + '\\' + resolvedTail;
      resolvedAbsolute = isAbsolute;
    }

    if (resolvedDevice && resolvedAbsolute) {
      break;
    }
  }

  // Convert slashes to backslashes when `resolvedDevice` points to an UNC
  // root. Also squash multiple slashes into a single one where appropriate.
  if (isUnc) {
    resolvedDevice = normalizeUNCRoot(resolvedDevice);
  }

  // At this point the path should be resolved to a full absolute path,
  // but handle relative paths to be safe (might happen when process.cwd()
  // fails)

  // Normalize the tail path
  resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/),
                                !resolvedAbsolute).join('\\');

  return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
         '.';
};


win32.normalize = function(path) {
  var result = win32StatPath(path),
      device = result.device,
      isUnc = result.isUnc,
      isAbsolute = result.isAbsolute,
      tail = result.tail,
      trailingSlash = /[\\\/]$/.test(tail);

  // Normalize the tail path
  tail = normalizeArray(tail.split(/[\\\/]+/), !isAbsolute).join('\\');

  if (!tail && !isAbsolute) {
    tail = '.';
  }
  if (tail && trailingSlash) {
    tail += '\\';
  }

  // Convert slashes to backslashes when `device` points to an UNC root.
  // Also squash multiple slashes into a single one where appropriate.
  if (isUnc) {
    device = normalizeUNCRoot(device);
  }

  return device + (isAbsolute ? '\\' : '') + tail;
};


win32.isAbsolute = function(path) {
  return win32StatPath(path).isAbsolute;
};

win32.join = function() {
  var paths = [];
  for (var i = 0; i < arguments.length; i++) {
    var arg = arguments[i];
    if (!util.isString(arg)) {
      throw new TypeError('Arguments to path.join must be strings');
    }
    if (arg) {
      paths.push(arg);
    }
  }

  var joined = paths.join('\\');

  // Make sure that the joined path doesn't start with two slashes, because
  // normalize() will mistake it for an UNC path then.
  //
  // This step is skipped when it is very clear that the user actually
  // intended to point at an UNC path. This is assumed when the first
  // non-empty string arguments starts with exactly two slashes followed by
  // at least one more non-slash character.
  //
  // Note that for normalize() to treat a path as an UNC path it needs to
  // have at least 2 components, so we don't filter for that here.
  // This means that the user can use join to construct UNC paths from
  // a server name and a share name; for example:
  //   path.join('//server', 'share') -> '\\\\server\\share\')
  if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
    joined = joined.replace(/^[\\\/]{2,}/, '\\');
  }

  return win32.normalize(joined);
};


// path.relative(from, to)
// it will solve the relative path from 'from' to 'to', for instance:
// from = 'C:\\orandea\\test\\aaa'
// to = 'C:\\orandea\\impl\\bbb'
// The output of the function should be: '..\\..\\impl\\bbb'
win32.relative = function(from, to) {
  from = win32.resolve(from);
  to = win32.resolve(to);

  // windows is not case sensitive
  var lowerFrom = from.toLowerCase();
  var lowerTo = to.toLowerCase();

  var toParts = trimArray(to.split('\\'));

  var lowerFromParts = trimArray(lowerFrom.split('\\'));
  var lowerToParts = trimArray(lowerTo.split('\\'));

  var length = Math.min(lowerFromParts.length, lowerToParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (lowerFromParts[i] !== lowerToParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  if (samePartsLength == 0) {
    return to;
  }

  var outputParts = [];
  for (var i = samePartsLength; i < lowerFromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('\\');
};


win32._makeLong = function(path) {
  // Note: this will *probably* throw somewhere.
  if (!util.isString(path))
    return path;

  if (!path) {
    return '';
  }

  var resolvedPath = win32.resolve(path);

  if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
    // path is local filesystem path, which needs to be converted
    // to long UNC path.
    return '\\\\?\\' + resolvedPath;
  } else if (/^\\\\[^?.]/.test(resolvedPath)) {
    // path is network UNC path, which needs to be converted
    // to long UNC path.
    return '\\\\?\\UNC\\' + resolvedPath.substring(2);
  }

  return path;
};


win32.dirname = function(path) {
  var result = win32SplitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


win32.basename = function(path, ext) {
  var f = win32SplitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


win32.extname = function(path) {
  return win32SplitPath(path)[3];
};


win32.format = function(pathObject) {
  if (!util.isObject(pathObject)) {
    throw new TypeError(
        "Parameter 'pathObject' must be an object, not " + typeof pathObject
    );
  }

  var root = pathObject.root || '';

  if (!util.isString(root)) {
    throw new TypeError(
        "'pathObject.root' must be a string or undefined, not " +
        typeof pathObject.root
    );
  }

  var dir = pathObject.dir;
  var base = pathObject.base || '';
  if (!dir) {
    return base;
  }
  if (dir[dir.length - 1] === win32.sep) {
    return dir + base;
  }
  return dir + win32.sep + base;
};


win32.parse = function(pathString) {
  if (!util.isString(pathString)) {
    throw new TypeError(
        "Parameter 'pathString' must be a string, not " + typeof pathString
    );
  }
  var allParts = win32SplitPath(pathString);
  if (!allParts || allParts.length !== 4) {
    throw new TypeError("Invalid path '" + pathString + "'");
  }
  return {
    root: allParts[0],
    dir: allParts[0] + allParts[1].slice(0, -1),
    base: allParts[2],
    ext: allParts[3],
    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
  };
};


win32.sep = '\\';
win32.delimiter = ';';


// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var posix = {};


function posixSplitPath(filename) {
  return splitPathRe.exec(filename).slice(1);
}


// path.resolve([from ...], to)
// posix version
posix.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (!util.isString(path)) {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path[0] === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(resolvedPath.split('/'),
                                !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
posix.normalize = function(path) {
  var isAbsolute = posix.isAbsolute(path),
      trailingSlash = path && path[path.length - 1] === '/';

  // Normalize the path
  path = normalizeArray(path.split('/'), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
posix.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
posix.join = function() {
  var path = '';
  for (var i = 0; i < arguments.length; i++) {
    var segment = arguments[i];
    if (!util.isString(segment)) {
      throw new TypeError('Arguments to path.join must be strings');
    }
    if (segment) {
      if (!path) {
        path += segment;
      } else {
        path += '/' + segment;
      }
    }
  }
  return posix.normalize(path);
};


// path.relative(from, to)
// posix version
posix.relative = function(from, to) {
  from = posix.resolve(from).substr(1);
  to = posix.resolve(to).substr(1);

  var fromParts = trimArray(from.split('/'));
  var toParts = trimArray(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};


posix._makeLong = function(path) {
  return path;
};


posix.dirname = function(path) {
  var result = posixSplitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


posix.basename = function(path, ext) {
  var f = posixSplitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


posix.extname = function(path) {
  return posixSplitPath(path)[3];
};


posix.format = function(pathObject) {
  if (!util.isObject(pathObject)) {
    throw new TypeError(
        "Parameter 'pathObject' must be an object, not " + typeof pathObject
    );
  }

  var root = pathObject.root || '';

  if (!util.isString(root)) {
    throw new TypeError(
        "'pathObject.root' must be a string or undefined, not " +
        typeof pathObject.root
    );
  }

  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';
  var base = pathObject.base || '';
  return dir + base;
};


posix.parse = function(pathString) {
  if (!util.isString(pathString)) {
    throw new TypeError(
        "Parameter 'pathString' must be a string, not " + typeof pathString
    );
  }
  var allParts = posixSplitPath(pathString);
  if (!allParts || allParts.length !== 4) {
    throw new TypeError("Invalid path '" + pathString + "'");
  }
  allParts[1] = allParts[1] || '';
  allParts[2] = allParts[2] || '';
  allParts[3] = allParts[3] || '';

  return {
    root: allParts[0],
    dir: allParts[0] + allParts[1].slice(0, -1),
    base: allParts[2],
    ext: allParts[3],
    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
  };
};


posix.sep = '/';
posix.delimiter = ':';


if (isWindows)
  module.exports = win32;
else /* posix */
  module.exports = posix;

module.exports.posix = posix;
module.exports.win32 = win32;


/***/ }),

/***/ "./node_modules/pdfjs-dist/build/pdf.js":
/*!**********************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2023 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = root.pdfjsLib = factory();
	else {}
})(globalThis, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.RenderingIntentFlag = exports.PromiseCapability = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.MAX_IMAGE_SIZE_TO_CACHE = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.BASELINE_FACTOR = exports.AnnotationType = exports.AnnotationReplyType = exports.AnnotationPrefix = exports.AnnotationMode = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;
exports.assert = assert;
exports.bytesToString = bytesToString;
exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
exports.getModificationDate = getModificationDate;
exports.getUuid = getUuid;
exports.getVerbosityLevel = getVerbosityLevel;
exports.info = info;
exports.isArrayBuffer = isArrayBuffer;
exports.isArrayEqual = isArrayEqual;
exports.isNodeJS = void 0;
exports.normalizeUnicode = normalizeUnicode;
exports.objectFromMap = objectFromMap;
exports.objectSize = objectSize;
exports.setVerbosityLevel = setVerbosityLevel;
exports.shadow = shadow;
exports.string32 = string32;
exports.stringToBytes = stringToBytes;
exports.stringToPDFString = stringToPDFString;
exports.stringToUTF8String = stringToUTF8String;
exports.unreachable = unreachable;
exports.utf8StringToString = utf8StringToString;
exports.warn = warn;
const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
exports.isNodeJS = isNodeJS;
const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
const MAX_IMAGE_SIZE_TO_CACHE = 10e6;
exports.MAX_IMAGE_SIZE_TO_CACHE = MAX_IMAGE_SIZE_TO_CACHE;
const LINE_FACTOR = 1.35;
exports.LINE_FACTOR = LINE_FACTOR;
const LINE_DESCENT_FACTOR = 0.35;
exports.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
exports.BASELINE_FACTOR = BASELINE_FACTOR;
const RenderingIntentFlag = {
  ANY: 0x01,
  DISPLAY: 0x02,
  PRINT: 0x04,
  SAVE: 0x08,
  ANNOTATIONS_FORMS: 0x10,
  ANNOTATIONS_STORAGE: 0x20,
  ANNOTATIONS_DISABLE: 0x40,
  OPLIST: 0x100
};
exports.RenderingIntentFlag = RenderingIntentFlag;
const AnnotationMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
};
exports.AnnotationMode = AnnotationMode;
const AnnotationEditorPrefix = "pdfjs_internal_editor_";
exports.AnnotationEditorPrefix = AnnotationEditorPrefix;
const AnnotationEditorType = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  STAMP: 13,
  INK: 15
};
exports.AnnotationEditorType = AnnotationEditorType;
const AnnotationEditorParamsType = {
  RESIZE: 1,
  CREATE: 2,
  FREETEXT_SIZE: 11,
  FREETEXT_COLOR: 12,
  FREETEXT_OPACITY: 13,
  INK_COLOR: 21,
  INK_THICKNESS: 22,
  INK_OPACITY: 23
};
exports.AnnotationEditorParamsType = AnnotationEditorParamsType;
const PermissionFlag = {
  PRINT: 0x04,
  MODIFY_CONTENTS: 0x08,
  COPY: 0x10,
  MODIFY_ANNOTATIONS: 0x20,
  FILL_INTERACTIVE_FORMS: 0x100,
  COPY_FOR_ACCESSIBILITY: 0x200,
  ASSEMBLE: 0x400,
  PRINT_HIGH_QUALITY: 0x800
};
exports.PermissionFlag = PermissionFlag;
const TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
exports.TextRenderingMode = TextRenderingMode;
const ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
exports.ImageKind = ImageKind;
const AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
exports.AnnotationType = AnnotationType;
const AnnotationReplyType = {
  GROUP: "Group",
  REPLY: "R"
};
exports.AnnotationReplyType = AnnotationReplyType;
const AnnotationFlag = {
  INVISIBLE: 0x01,
  HIDDEN: 0x02,
  PRINT: 0x04,
  NOZOOM: 0x08,
  NOROTATE: 0x10,
  NOVIEW: 0x20,
  READONLY: 0x40,
  LOCKED: 0x80,
  TOGGLENOVIEW: 0x100,
  LOCKEDCONTENTS: 0x200
};
exports.AnnotationFlag = AnnotationFlag;
const AnnotationFieldFlag = {
  READONLY: 0x0000001,
  REQUIRED: 0x0000002,
  NOEXPORT: 0x0000004,
  MULTILINE: 0x0001000,
  PASSWORD: 0x0002000,
  NOTOGGLETOOFF: 0x0004000,
  RADIO: 0x0008000,
  PUSHBUTTON: 0x0010000,
  COMBO: 0x0020000,
  EDIT: 0x0040000,
  SORT: 0x0080000,
  FILESELECT: 0x0100000,
  MULTISELECT: 0x0200000,
  DONOTSPELLCHECK: 0x0400000,
  DONOTSCROLL: 0x0800000,
  COMB: 0x1000000,
  RICHTEXT: 0x2000000,
  RADIOSINUNISON: 0x2000000,
  COMMITONSELCHANGE: 0x4000000
};
exports.AnnotationFieldFlag = AnnotationFieldFlag;
const AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
const AnnotationActionEventType = {
  E: "Mouse Enter",
  X: "Mouse Exit",
  D: "Mouse Down",
  U: "Mouse Up",
  Fo: "Focus",
  Bl: "Blur",
  PO: "PageOpen",
  PC: "PageClose",
  PV: "PageVisible",
  PI: "PageInvisible",
  K: "Keystroke",
  F: "Format",
  V: "Validate",
  C: "Calculate"
};
exports.AnnotationActionEventType = AnnotationActionEventType;
const DocumentActionEventType = {
  WC: "WillClose",
  WS: "WillSave",
  DS: "DidSave",
  WP: "WillPrint",
  DP: "DidPrint"
};
exports.DocumentActionEventType = DocumentActionEventType;
const PageActionEventType = {
  O: "PageOpen",
  C: "PageClose"
};
exports.PageActionEventType = PageActionEventType;
const VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
exports.VerbosityLevel = VerbosityLevel;
const CMapCompressionType = {
  NONE: 0,
  BINARY: 1
};
exports.CMapCompressionType = CMapCompressionType;
const OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};
exports.OPS = OPS;
const PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
exports.PasswordResponses = PasswordResponses;
let verbosity = VerbosityLevel.WARNINGS;
function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}
function getVerbosityLevel() {
  return verbosity;
}
function info(msg) {
  if (verbosity >= VerbosityLevel.INFOS) {
    console.log(`Info: ${msg}`);
  }
}
function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.log(`Warning: ${msg}`);
  }
}
function unreachable(msg) {
  throw new Error(msg);
}
function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}
function _isValidProtocol(url) {
  switch (url?.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return true;
    default:
      return false;
  }
}
function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
  if (!url) {
    return null;
  }
  try {
    if (options && typeof url === "string") {
      if (options.addDefaultProtocol && url.startsWith("www.")) {
        const dots = url.match(/\./g);
        if (dots?.length >= 2) {
          url = `http://${url}`;
        }
      }
      if (options.tryConvertEncoding) {
        try {
          url = stringToUTF8String(url);
        } catch {}
      }
    }
    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
    if (_isValidProtocol(absoluteUrl)) {
      return absoluteUrl;
    }
  } catch {}
  return null;
}
function shadow(obj, prop, value, nonSerializable = false) {
  Object.defineProperty(obj, prop, {
    value,
    enumerable: !nonSerializable,
    configurable: true,
    writable: false
  });
  return value;
}
const BaseException = function BaseExceptionClosure() {
  function BaseException(message, name) {
    if (this.constructor === BaseException) {
      unreachable("Cannot initialize BaseException.");
    }
    this.message = message;
    this.name = name;
  }
  BaseException.prototype = new Error();
  BaseException.constructor = BaseException;
  return BaseException;
}();
exports.BaseException = BaseException;
class PasswordException extends BaseException {
  constructor(msg, code) {
    super(msg, "PasswordException");
    this.code = code;
  }
}
exports.PasswordException = PasswordException;
class UnknownErrorException extends BaseException {
  constructor(msg, details) {
    super(msg, "UnknownErrorException");
    this.details = details;
  }
}
exports.UnknownErrorException = UnknownErrorException;
class InvalidPDFException extends BaseException {
  constructor(msg) {
    super(msg, "InvalidPDFException");
  }
}
exports.InvalidPDFException = InvalidPDFException;
class MissingPDFException extends BaseException {
  constructor(msg) {
    super(msg, "MissingPDFException");
  }
}
exports.MissingPDFException = MissingPDFException;
class UnexpectedResponseException extends BaseException {
  constructor(msg, status) {
    super(msg, "UnexpectedResponseException");
    this.status = status;
  }
}
exports.UnexpectedResponseException = UnexpectedResponseException;
class FormatError extends BaseException {
  constructor(msg) {
    super(msg, "FormatError");
  }
}
exports.FormatError = FormatError;
class AbortException extends BaseException {
  constructor(msg) {
    super(msg, "AbortException");
  }
}
exports.AbortException = AbortException;
function bytesToString(bytes) {
  if (typeof bytes !== "object" || bytes?.length === undefined) {
    unreachable("Invalid argument for bytesToString");
  }
  const length = bytes.length;
  const MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  const strBuf = [];
  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    const chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join("");
}
function stringToBytes(str) {
  if (typeof str !== "string") {
    unreachable("Invalid argument for stringToBytes");
  }
  const length = str.length;
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xff;
  }
  return bytes;
}
function string32(value) {
  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
}
function objectSize(obj) {
  return Object.keys(obj).length;
}
function objectFromMap(map) {
  const obj = Object.create(null);
  for (const [key, value] of map) {
    obj[key] = value;
  }
  return obj;
}
function isLittleEndian() {
  const buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}
function isEvalSupported() {
  try {
    new Function("");
    return true;
  } catch {
    return false;
  }
}
class FeatureTest {
  static get isLittleEndian() {
    return shadow(this, "isLittleEndian", isLittleEndian());
  }
  static get isEvalSupported() {
    return shadow(this, "isEvalSupported", isEvalSupported());
  }
  static get isOffscreenCanvasSupported() {
    return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
  }
  static get platform() {
    if (typeof navigator === "undefined") {
      return shadow(this, "platform", {
        isWin: false,
        isMac: false
      });
    }
    return shadow(this, "platform", {
      isWin: navigator.platform.includes("Win"),
      isMac: navigator.platform.includes("Mac")
    });
  }
  static get isCSSRoundSupported() {
    return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
  }
}
exports.FeatureTest = FeatureTest;
const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, "0"));
class Util {
  static makeHexColor(r, g, b) {
    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
  }
  static scaleMinMax(transform, minMax) {
    let temp;
    if (transform[0]) {
      if (transform[0] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[1];
        minMax[1] = temp;
      }
      minMax[0] *= transform[0];
      minMax[1] *= transform[0];
      if (transform[3] < 0) {
        temp = minMax[2];
        minMax[2] = minMax[3];
        minMax[3] = temp;
      }
      minMax[2] *= transform[3];
      minMax[3] *= transform[3];
    } else {
      temp = minMax[0];
      minMax[0] = minMax[2];
      minMax[2] = temp;
      temp = minMax[1];
      minMax[1] = minMax[3];
      minMax[3] = temp;
      if (transform[1] < 0) {
        temp = minMax[2];
        minMax[2] = minMax[3];
        minMax[3] = temp;
      }
      minMax[2] *= transform[1];
      minMax[3] *= transform[1];
      if (transform[2] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[1];
        minMax[1] = temp;
      }
      minMax[0] *= transform[2];
      minMax[1] *= transform[2];
    }
    minMax[0] += transform[4];
    minMax[1] += transform[4];
    minMax[2] += transform[5];
    minMax[3] += transform[5];
  }
  static transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  }
  static applyTransform(p, m) {
    const xt = p[0] * m[0] + p[1] * m[2] + m[4];
    const yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  }
  static applyInverseTransform(p, m) {
    const d = m[0] * m[3] - m[1] * m[2];
    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  }
  static getAxialAlignedBoundingBox(r, m) {
    const p1 = this.applyTransform(r, m);
    const p2 = this.applyTransform(r.slice(2, 4), m);
    const p3 = this.applyTransform([r[0], r[3]], m);
    const p4 = this.applyTransform([r[2], r[1]], m);
    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  }
  static inverseTransform(m) {
    const d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  }
  static singularValueDecompose2dScale(m) {
    const transpose = [m[0], m[2], m[1], m[3]];
    const a = m[0] * transpose[0] + m[1] * transpose[2];
    const b = m[0] * transpose[1] + m[1] * transpose[3];
    const c = m[2] * transpose[0] + m[3] * transpose[2];
    const d = m[2] * transpose[1] + m[3] * transpose[3];
    const first = (a + d) / 2;
    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
    const sx = first + second || 1;
    const sy = first - second || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  }
  static normalizeRect(rect) {
    const r = rect.slice(0);
    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }
    return r;
  }
  static intersect(rect1, rect2) {
    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
    if (xLow > xHigh) {
      return null;
    }
    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
    if (yLow > yHigh) {
      return null;
    }
    return [xLow, yLow, xHigh, yHigh];
  }
  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
    const tvalues = [],
      bounds = [[], []];
    let a, b, c, t, t1, t2, b2ac, sqrtb2ac;
    for (let i = 0; i < 2; ++i) {
      if (i === 0) {
        b = 6 * x0 - 12 * x1 + 6 * x2;
        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c = 3 * x1 - 3 * x0;
      } else {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }
      if (Math.abs(a) < 1e-12) {
        if (Math.abs(b) < 1e-12) {
          continue;
        }
        t = -c / b;
        if (0 < t && t < 1) {
          tvalues.push(t);
        }
        continue;
      }
      b2ac = b * b - 4 * c * a;
      sqrtb2ac = Math.sqrt(b2ac);
      if (b2ac < 0) {
        continue;
      }
      t1 = (-b + sqrtb2ac) / (2 * a);
      if (0 < t1 && t1 < 1) {
        tvalues.push(t1);
      }
      t2 = (-b - sqrtb2ac) / (2 * a);
      if (0 < t2 && t2 < 1) {
        tvalues.push(t2);
      }
    }
    let j = tvalues.length,
      mt;
    const jlen = j;
    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    }
    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    bounds[0].length = bounds[1].length = jlen + 2;
    return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
  }
}
exports.Util = Util;
const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];
function stringToPDFString(str) {
  if (str[0] >= "\xEF") {
    let encoding;
    if (str[0] === "\xFE" && str[1] === "\xFF") {
      encoding = "utf-16be";
    } else if (str[0] === "\xFF" && str[1] === "\xFE") {
      encoding = "utf-16le";
    } else if (str[0] === "\xEF" && str[1] === "\xBB" && str[2] === "\xBF") {
      encoding = "utf-8";
    }
    if (encoding) {
      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = stringToBytes(str);
        return decoder.decode(buffer);
      } catch (ex) {
        warn(`stringToPDFString: "${ex}".`);
      }
    }
  }
  const strBuf = [];
  for (let i = 0, ii = str.length; i < ii; i++) {
    const code = PDFStringTranslateTable[str.charCodeAt(i)];
    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
  }
  return strBuf.join("");
}
function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}
function utf8StringToString(str) {
  return unescape(encodeURIComponent(str));
}
function isArrayBuffer(v) {
  return typeof v === "object" && v?.byteLength !== undefined;
}
function isArrayEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (let i = 0, ii = arr1.length; i < ii; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function getModificationDate(date = new Date()) {
  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
  return buffer.join("");
}
class PromiseCapability {
  #settled = false;
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = data => {
        this.#settled = true;
        resolve(data);
      };
      this.reject = reason => {
        this.#settled = true;
        reject(reason);
      };
    });
  }
  get settled() {
    return this.#settled;
  }
}
exports.PromiseCapability = PromiseCapability;
let NormalizeRegex = null;
let NormalizationMap = null;
function normalizeUnicode(str) {
  if (!NormalizeRegex) {
    NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
    NormalizationMap = new Map([["", "t"]]);
  }
  return str.replaceAll(NormalizeRegex, (_, p1, p2) => {
    return p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2);
  });
}
function getUuid() {
  if (typeof crypto !== "undefined" && typeof crypto?.randomUUID === "function") {
    return crypto.randomUUID();
  }
  const buf = new Uint8Array(32);
  if (typeof crypto !== "undefined" && typeof crypto?.getRandomValues === "function") {
    crypto.getRandomValues(buf);
  } else {
    for (let i = 0; i < 32; i++) {
      buf[i] = Math.floor(Math.random() * 255);
    }
  }
  return bytesToString(buf);
}
const AnnotationPrefix = "pdfjs_internal_id_";
exports.AnnotationPrefix = AnnotationPrefix;

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
Object.defineProperty(exports, "SVGGraphics", ({
  enumerable: true,
  get: function () {
    return _displaySvg.SVGGraphics;
  }
}));
exports.build = void 0;
exports.getDocument = getDocument;
exports.version = void 0;
var _util = __w_pdfjs_require__(1);
var _annotation_storage = __w_pdfjs_require__(3);
var _display_utils = __w_pdfjs_require__(6);
var _font_loader = __w_pdfjs_require__(9);
var _displayNode_utils = __w_pdfjs_require__(10);
var _canvas = __w_pdfjs_require__(11);
var _worker_options = __w_pdfjs_require__(14);
var _message_handler = __w_pdfjs_require__(15);
var _metadata = __w_pdfjs_require__(16);
var _optional_content_config = __w_pdfjs_require__(17);
var _transport_stream = __w_pdfjs_require__(18);
var _displayFetch_stream = __w_pdfjs_require__(19);
var _displayNetwork = __w_pdfjs_require__(22);
var _displayNode_stream = __w_pdfjs_require__(23);
var _displaySvg = __w_pdfjs_require__(24);
var _xfa_text = __w_pdfjs_require__(25);
const DEFAULT_RANGE_CHUNK_SIZE = 65536;
const RENDERING_CANCELLED_TIMEOUT = 100;
const DELAYED_CLEANUP_TIMEOUT = 5000;
const DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
exports.DefaultCanvasFactory = DefaultCanvasFactory;
const DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
const DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;
exports.DefaultFilterFactory = DefaultFilterFactory;
const DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;
exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
function getDocument(src) {
  if (typeof src === "string" || src instanceof URL) {
    src = {
      url: src
    };
  } else if ((0, _util.isArrayBuffer)(src)) {
    src = {
      data: src
    };
  }
  if (typeof src !== "object") {
    throw new Error("Invalid parameter in getDocument, need parameter object.");
  }
  if (!src.url && !src.data && !src.range) {
    throw new Error("Invalid parameter object: need either .data, .range or .url");
  }
  const task = new PDFDocumentLoadingTask();
  const {
    docId
  } = task;
  const url = src.url ? getUrlProp(src.url) : null;
  const data = src.data ? getDataProp(src.data) : null;
  const httpHeaders = src.httpHeaders || null;
  const withCredentials = src.withCredentials === true;
  const password = src.password ?? null;
  const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;
  const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
  let worker = src.worker instanceof PDFWorker ? src.worker : null;
  const verbosity = src.verbosity;
  const docBaseUrl = typeof src.docBaseUrl === "string" && !(0, _display_utils.isDataScheme)(src.docBaseUrl) ? src.docBaseUrl : null;
  const cMapUrl = typeof src.cMapUrl === "string" ? src.cMapUrl : null;
  const cMapPacked = src.cMapPacked !== false;
  const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;
  const standardFontDataUrl = typeof src.standardFontDataUrl === "string" ? src.standardFontDataUrl : null;
  const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;
  const ignoreErrors = src.stopAtErrors !== true;
  const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;
  const isEvalSupported = src.isEvalSupported !== false;
  const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === "boolean" ? src.isOffscreenCanvasSupported : !_util.isNodeJS;
  const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;
  const disableFontFace = typeof src.disableFontFace === "boolean" ? src.disableFontFace : _util.isNodeJS;
  const fontExtraProperties = src.fontExtraProperties === true;
  const enableXfa = src.enableXfa === true;
  const ownerDocument = src.ownerDocument || globalThis.document;
  const disableRange = src.disableRange === true;
  const disableStream = src.disableStream === true;
  const disableAutoFetch = src.disableAutoFetch === true;
  const pdfBug = src.pdfBug === true;
  const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;
  const useSystemFonts = typeof src.useSystemFonts === "boolean" ? src.useSystemFonts : !_util.isNodeJS && !disableFontFace;
  const useWorkerFetch = typeof src.useWorkerFetch === "boolean" ? src.useWorkerFetch : CMapReaderFactory === _display_utils.DOMCMapReaderFactory && StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && (0, _display_utils.isValidFetchUrl)(cMapUrl, document.baseURI) && (0, _display_utils.isValidFetchUrl)(standardFontDataUrl, document.baseURI);
  const canvasFactory = src.canvasFactory || new DefaultCanvasFactory({
    ownerDocument
  });
  const filterFactory = src.filterFactory || new DefaultFilterFactory({
    docId,
    ownerDocument
  });
  const styleElement = null;
  (0, _util.setVerbosityLevel)(verbosity);
  const transportFactory = {
    canvasFactory,
    filterFactory
  };
  if (!useWorkerFetch) {
    transportFactory.cMapReaderFactory = new CMapReaderFactory({
      baseUrl: cMapUrl,
      isCompressed: cMapPacked
    });
    transportFactory.standardFontDataFactory = new StandardFontDataFactory({
      baseUrl: standardFontDataUrl
    });
  }
  if (!worker) {
    const workerParams = {
      verbosity,
      port: _worker_options.GlobalWorkerOptions.workerPort
    };
    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
    task._worker = worker;
  }
  const fetchDocParams = {
    docId,
    apiVersion: '3.11.174',
    data,
    password,
    disableAutoFetch,
    rangeChunkSize,
    length,
    docBaseUrl,
    enableXfa,
    evaluatorOptions: {
      maxImageSize,
      disableFontFace,
      ignoreErrors,
      isEvalSupported,
      isOffscreenCanvasSupported,
      canvasMaxAreaInBytes,
      fontExtraProperties,
      useSystemFonts,
      cMapUrl: useWorkerFetch ? cMapUrl : null,
      standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null
    }
  };
  const transportParams = {
    ignoreErrors,
    isEvalSupported,
    disableFontFace,
    fontExtraProperties,
    enableXfa,
    ownerDocument,
    disableAutoFetch,
    pdfBug,
    styleElement
  };
  worker.promise.then(function () {
    if (task.destroyed) {
      throw new Error("Loading aborted");
    }
    const workerIdPromise = _fetchDocument(worker, fetchDocParams);
    const networkStreamPromise = new Promise(function (resolve) {
      let networkStream;
      if (rangeTransport) {
        networkStream = new _transport_stream.PDFDataTransportStream({
          length,
          initialData: rangeTransport.initialData,
          progressiveDone: rangeTransport.progressiveDone,
          contentDispositionFilename: rangeTransport.contentDispositionFilename,
          disableRange,
          disableStream
        }, rangeTransport);
      } else if (!data) {
        const createPDFNetworkStream = params => {
          if (_util.isNodeJS) {
            return new _displayNode_stream.PDFNodeStream(params);
          }
          return (0, _display_utils.isValidFetchUrl)(params.url) ? new _displayFetch_stream.PDFFetchStream(params) : new _displayNetwork.PDFNetworkStream(params);
        };
        networkStream = createPDFNetworkStream({
          url,
          length,
          httpHeaders,
          withCredentials,
          rangeChunkSize,
          disableRange,
          disableStream
        });
      }
      resolve(networkStream);
    });
    return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {
      if (task.destroyed) {
        throw new Error("Loading aborted");
      }
      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
      const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);
      task._transport = transport;
      messageHandler.send("Ready", null);
    });
  }).catch(task._capability.reject);
  return task;
}
async function _fetchDocument(worker, source) {
  if (worker.destroyed) {
    throw new Error("Worker was destroyed");
  }
  const workerId = await worker.messageHandler.sendWithPromise("GetDocRequest", source, source.data ? [source.data.buffer] : null);
  if (worker.destroyed) {
    throw new Error("Worker was destroyed");
  }
  return workerId;
}
function getUrlProp(val) {
  if (val instanceof URL) {
    return val.href;
  }
  try {
    return new URL(val, window.location).href;
  } catch {
    if (_util.isNodeJS && typeof val === "string") {
      return val;
    }
  }
  throw new Error("Invalid PDF url data: " + "either string or URL-object is expected in the url property.");
}
function getDataProp(val) {
  if (_util.isNodeJS && typeof Buffer !== "undefined" && val instanceof Buffer) {
    throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
  }
  if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {
    return val;
  }
  if (typeof val === "string") {
    return (0, _util.stringToBytes)(val);
  }
  if (typeof val === "object" && !isNaN(val?.length) || (0, _util.isArrayBuffer)(val)) {
    return new Uint8Array(val);
  }
  throw new Error("Invalid PDF binary data: either TypedArray, " + "string, or array-like object is expected in the data property.");
}
class PDFDocumentLoadingTask {
  static #docId = 0;
  constructor() {
    this._capability = new _util.PromiseCapability();
    this._transport = null;
    this._worker = null;
    this.docId = `d${PDFDocumentLoadingTask.#docId++}`;
    this.destroyed = false;
    this.onPassword = null;
    this.onProgress = null;
  }
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    this.destroyed = true;
    try {
      if (this._worker?.port) {
        this._worker._pendingDestroy = true;
      }
      await this._transport?.destroy();
    } catch (ex) {
      if (this._worker?.port) {
        delete this._worker._pendingDestroy;
      }
      throw ex;
    }
    this._transport = null;
    if (this._worker) {
      this._worker.destroy();
      this._worker = null;
    }
  }
}
exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
class PDFDataRangeTransport {
  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
    this.length = length;
    this.initialData = initialData;
    this.progressiveDone = progressiveDone;
    this.contentDispositionFilename = contentDispositionFilename;
    this._rangeListeners = [];
    this._progressListeners = [];
    this._progressiveReadListeners = [];
    this._progressiveDoneListeners = [];
    this._readyCapability = new _util.PromiseCapability();
  }
  addRangeListener(listener) {
    this._rangeListeners.push(listener);
  }
  addProgressListener(listener) {
    this._progressListeners.push(listener);
  }
  addProgressiveReadListener(listener) {
    this._progressiveReadListeners.push(listener);
  }
  addProgressiveDoneListener(listener) {
    this._progressiveDoneListeners.push(listener);
  }
  onDataRange(begin, chunk) {
    for (const listener of this._rangeListeners) {
      listener(begin, chunk);
    }
  }
  onDataProgress(loaded, total) {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressListeners) {
        listener(loaded, total);
      }
    });
  }
  onDataProgressiveRead(chunk) {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressiveReadListeners) {
        listener(chunk);
      }
    });
  }
  onDataProgressiveDone() {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressiveDoneListeners) {
        listener();
      }
    });
  }
  transportReady() {
    this._readyCapability.resolve();
  }
  requestDataRange(begin, end) {
    (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {}
}
exports.PDFDataRangeTransport = PDFDataRangeTransport;
class PDFDocumentProxy {
  constructor(pdfInfo, transport) {
    this._pdfInfo = pdfInfo;
    this._transport = transport;
    Object.defineProperty(this, "getJavaScript", {
      value: () => {
        (0, _display_utils.deprecated)("`PDFDocumentProxy.getJavaScript`, " + "please use `PDFDocumentProxy.getJSActions` instead.");
        return this.getJSActions().then(js => {
          if (!js) {
            return js;
          }
          const jsArr = [];
          for (const name in js) {
            jsArr.push(...js[name]);
          }
          return jsArr;
        });
      }
    });
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(pageNumber) {
    return this._transport.getPage(pageNumber);
  }
  getPageIndex(ref) {
    return this._transport.getPageIndex(ref);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(id) {
    return this._transport.getDestination(id);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig() {
    return this._transport.getOptionalContentConfig();
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(keepLoadedFonts = false) {
    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
}
exports.PDFDocumentProxy = PDFDocumentProxy;
class PDFPageProxy {
  #delayedCleanupTimeout = null;
  #pendingCleanup = false;
  constructor(pageIndex, pageInfo, transport, pdfBug = false) {
    this._pageIndex = pageIndex;
    this._pageInfo = pageInfo;
    this._transport = transport;
    this._stats = pdfBug ? new _display_utils.StatTimer() : null;
    this._pdfBug = pdfBug;
    this.commonObjs = transport.commonObjs;
    this.objs = new PDFObjects();
    this._maybeCleanupAfterRender = false;
    this._intentStates = new Map();
    this.destroyed = false;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({
    scale,
    rotation = this.rotate,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  } = {}) {
    return new _display_utils.PageViewport({
      viewBox: this.view,
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }
  getAnnotations({
    intent = "display"
  } = {}) {
    const intentArgs = this._transport.getRenderingIntent(intent);
    return this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    return this._transport._htmlForXfa?.children[this._pageIndex] || null;
  }
  render({
    canvasContext,
    viewport,
    intent = "display",
    annotationMode = _util.AnnotationMode.ENABLE,
    transform = null,
    background = null,
    optionalContentConfigPromise = null,
    annotationCanvasMap = null,
    pageColors = null,
    printAnnotationStorage = null
  }) {
    this._stats?.time("Overall");
    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);
    this.#pendingCleanup = false;
    this.#abortDelayedCleanup();
    if (!optionalContentConfigPromise) {
      optionalContentConfigPromise = this._transport.getOptionalContentConfig();
    }
    let intentState = this._intentStates.get(intentArgs.cacheKey);
    if (!intentState) {
      intentState = Object.create(null);
      this._intentStates.set(intentArgs.cacheKey, intentState);
    }
    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }
    const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);
    if (!intentState.displayReadyCapability) {
      intentState.displayReadyCapability = new _util.PromiseCapability();
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };
      this._stats?.time("Page Request");
      this._pumpOperatorList(intentArgs);
    }
    const complete = error => {
      intentState.renderTasks.delete(internalRenderTask);
      if (this._maybeCleanupAfterRender || intentPrint) {
        this.#pendingCleanup = true;
      }
      this.#tryCleanup(!intentPrint);
      if (error) {
        internalRenderTask.capability.reject(error);
        this._abortOperatorList({
          intentState,
          reason: error instanceof Error ? error : new Error(error)
        });
      } else {
        internalRenderTask.capability.resolve();
      }
      this._stats?.timeEnd("Rendering");
      this._stats?.timeEnd("Overall");
    };
    const internalRenderTask = new InternalRenderTask({
      callback: complete,
      params: {
        canvasContext,
        viewport,
        transform,
        background
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap,
      operatorList: intentState.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: this._transport.canvasFactory,
      filterFactory: this._transport.filterFactory,
      useRequestAnimationFrame: !intentPrint,
      pdfBug: this._pdfBug,
      pageColors
    });
    (intentState.renderTasks ||= new Set()).add(internalRenderTask);
    const renderTask = internalRenderTask.task;
    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
      if (this.destroyed) {
        complete();
        return;
      }
      this._stats?.time("Rendering");
      internalRenderTask.initializeGraphics({
        transparency,
        optionalContentConfig
      });
      internalRenderTask.operatorListChanged();
    }).catch(complete);
    return renderTask;
  }
  getOperatorList({
    intent = "display",
    annotationMode = _util.AnnotationMode.ENABLE,
    printAnnotationStorage = null
  } = {}) {
    function operatorListChanged() {
      if (intentState.operatorList.lastChunk) {
        intentState.opListReadCapability.resolve(intentState.operatorList);
        intentState.renderTasks.delete(opListTask);
      }
    }
    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);
    let intentState = this._intentStates.get(intentArgs.cacheKey);
    if (!intentState) {
      intentState = Object.create(null);
      this._intentStates.set(intentArgs.cacheKey, intentState);
    }
    let opListTask;
    if (!intentState.opListReadCapability) {
      opListTask = Object.create(null);
      opListTask.operatorListChanged = operatorListChanged;
      intentState.opListReadCapability = new _util.PromiseCapability();
      (intentState.renderTasks ||= new Set()).add(opListTask);
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };
      this._stats?.time("Page Request");
      this._pumpOperatorList(intentArgs);
    }
    return intentState.opListReadCapability.promise;
  }
  streamTextContent({
    includeMarkedContent = false,
    disableNormalization = false
  } = {}) {
    const TEXT_CONTENT_CHUNK_SIZE = 100;
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      includeMarkedContent: includeMarkedContent === true,
      disableNormalization: disableNormalization === true
    }, {
      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
      size(textContent) {
        return textContent.items.length;
      }
    });
  }
  getTextContent(params = {}) {
    if (this._transport._htmlForXfa) {
      return this.getXfa().then(xfa => {
        return _xfa_text.XfaText.textContent(xfa);
      });
    }
    const readableStream = this.streamTextContent(params);
    return new Promise(function (resolve, reject) {
      function pump() {
        reader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            resolve(textContent);
            return;
          }
          Object.assign(textContent.styles, value.styles);
          textContent.items.push(...value.items);
          pump();
        }, reject);
      }
      const reader = readableStream.getReader();
      const textContent = {
        items: [],
        styles: Object.create(null)
      };
      pump();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = true;
    const waitOn = [];
    for (const intentState of this._intentStates.values()) {
      this._abortOperatorList({
        intentState,
        reason: new Error("Page was destroyed."),
        force: true
      });
      if (intentState.opListReadCapability) {
        continue;
      }
      for (const internalRenderTask of intentState.renderTasks) {
        waitOn.push(internalRenderTask.completed);
        internalRenderTask.cancel();
      }
    }
    this.objs.clear();
    this.#pendingCleanup = false;
    this.#abortDelayedCleanup();
    return Promise.all(waitOn);
  }
  cleanup(resetStats = false) {
    this.#pendingCleanup = true;
    const success = this.#tryCleanup(false);
    if (resetStats && success) {
      this._stats &&= new _display_utils.StatTimer();
    }
    return success;
  }
  #tryCleanup(delayed = false) {
    this.#abortDelayedCleanup();
    if (!this.#pendingCleanup || this.destroyed) {
      return false;
    }
    if (delayed) {
      this.#delayedCleanupTimeout = setTimeout(() => {
        this.#delayedCleanupTimeout = null;
        this.#tryCleanup(false);
      }, DELAYED_CLEANUP_TIMEOUT);
      return false;
    }
    for (const {
      renderTasks,
      operatorList
    } of this._intentStates.values()) {
      if (renderTasks.size > 0 || !operatorList.lastChunk) {
        return false;
      }
    }
    this._intentStates.clear();
    this.objs.clear();
    this.#pendingCleanup = false;
    return true;
  }
  #abortDelayedCleanup() {
    if (this.#delayedCleanupTimeout) {
      clearTimeout(this.#delayedCleanupTimeout);
      this.#delayedCleanupTimeout = null;
    }
  }
  _startRenderPage(transparency, cacheKey) {
    const intentState = this._intentStates.get(cacheKey);
    if (!intentState) {
      return;
    }
    this._stats?.timeEnd("Page Request");
    intentState.displayReadyCapability?.resolve(transparency);
  }
  _renderPageChunk(operatorListChunk, intentState) {
    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
    }
    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
    for (const internalRenderTask of intentState.renderTasks) {
      internalRenderTask.operatorListChanged();
    }
    if (operatorListChunk.lastChunk) {
      this.#tryCleanup(true);
    }
  }
  _pumpOperatorList({
    renderingIntent,
    cacheKey,
    annotationStorageSerializable
  }) {
    const {
      map,
      transfers
    } = annotationStorageSerializable;
    const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: renderingIntent,
      cacheKey,
      annotationStorage: map
    }, transfers);
    const reader = readableStream.getReader();
    const intentState = this._intentStates.get(cacheKey);
    intentState.streamReader = reader;
    const pump = () => {
      reader.read().then(({
        value,
        done
      }) => {
        if (done) {
          intentState.streamReader = null;
          return;
        }
        if (this._transport.destroyed) {
          return;
        }
        this._renderPageChunk(value, intentState);
        pump();
      }, reason => {
        intentState.streamReader = null;
        if (this._transport.destroyed) {
          return;
        }
        if (intentState.operatorList) {
          intentState.operatorList.lastChunk = true;
          for (const internalRenderTask of intentState.renderTasks) {
            internalRenderTask.operatorListChanged();
          }
          this.#tryCleanup(true);
        }
        if (intentState.displayReadyCapability) {
          intentState.displayReadyCapability.reject(reason);
        } else if (intentState.opListReadCapability) {
          intentState.opListReadCapability.reject(reason);
        } else {
          throw reason;
        }
      });
    };
    pump();
  }
  _abortOperatorList({
    intentState,
    reason,
    force = false
  }) {
    if (!intentState.streamReader) {
      return;
    }
    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }
    if (!force) {
      if (intentState.renderTasks.size > 0) {
        return;
      }
      if (reason instanceof _display_utils.RenderingCancelledException) {
        let delay = RENDERING_CANCELLED_TIMEOUT;
        if (reason.extraDelay > 0 && reason.extraDelay < 1000) {
          delay += reason.extraDelay;
        }
        intentState.streamReaderCancelTimeout = setTimeout(() => {
          intentState.streamReaderCancelTimeout = null;
          this._abortOperatorList({
            intentState,
            reason,
            force: true
          });
        }, delay);
        return;
      }
    }
    intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {});
    intentState.streamReader = null;
    if (this._transport.destroyed) {
      return;
    }
    for (const [curCacheKey, curIntentState] of this._intentStates) {
      if (curIntentState === intentState) {
        this._intentStates.delete(curCacheKey);
        break;
      }
    }
    this.cleanup();
  }
  get stats() {
    return this._stats;
  }
}
exports.PDFPageProxy = PDFPageProxy;
class LoopbackPort {
  #listeners = new Set();
  #deferred = Promise.resolve();
  postMessage(obj, transfer) {
    const event = {
      data: structuredClone(obj, transfer ? {
        transfer
      } : null)
    };
    this.#deferred.then(() => {
      for (const listener of this.#listeners) {
        listener.call(this, event);
      }
    });
  }
  addEventListener(name, listener) {
    this.#listeners.add(listener);
  }
  removeEventListener(name, listener) {
    this.#listeners.delete(listener);
  }
  terminate() {
    this.#listeners.clear();
  }
}
exports.LoopbackPort = LoopbackPort;
const PDFWorkerUtil = {
  isWorkerDisabled: false,
  fallbackWorkerSrc: null,
  fakeWorkerId: 0
};
exports.PDFWorkerUtil = PDFWorkerUtil;
{
  if (_util.isNodeJS && "function" === "function") {
    PDFWorkerUtil.isWorkerDisabled = true;
    PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
  } else if (typeof document === "object") {
    const pdfjsFilePath = document?.currentScript?.src;
    if (pdfjsFilePath) {
      PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
    }
  }
  PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) {
    let base;
    try {
      base = new URL(baseUrl);
      if (!base.origin || base.origin === "null") {
        return false;
      }
    } catch {
      return false;
    }
    const other = new URL(otherUrl, base);
    return base.origin === other.origin;
  };
  PDFWorkerUtil.createCDNWrapper = function (url) {
    const wrapper = `importScripts("${url}");`;
    return URL.createObjectURL(new Blob([wrapper]));
  };
}
class PDFWorker {
  static #workerPorts;
  constructor({
    name = null,
    port = null,
    verbosity = (0, _util.getVerbosityLevel)()
  } = {}) {
    this.name = name;
    this.destroyed = false;
    this.verbosity = verbosity;
    this._readyCapability = new _util.PromiseCapability();
    this._port = null;
    this._webWorker = null;
    this._messageHandler = null;
    if (port) {
      if (PDFWorker.#workerPorts?.has(port)) {
        throw new Error("Cannot use more than one PDFWorker per port.");
      }
      (PDFWorker.#workerPorts ||= new WeakMap()).set(port, this);
      this._initializeFromPort(port);
      return;
    }
    this._initialize();
  }
  get promise() {
    return this._readyCapability.promise;
  }
  get port() {
    return this._port;
  }
  get messageHandler() {
    return this._messageHandler;
  }
  _initializeFromPort(port) {
    this._port = port;
    this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
    this._messageHandler.on("ready", function () {});
    this._readyCapability.resolve();
    this._messageHandler.send("configure", {
      verbosity: this.verbosity
    });
  }
  _initialize() {
    if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {
      let {
        workerSrc
      } = PDFWorker;
      try {
        if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
          workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
        }
        const worker = new Worker(workerSrc);
        const messageHandler = new _message_handler.MessageHandler("main", "worker", worker);
        const terminateEarly = () => {
          worker.removeEventListener("error", onWorkerError);
          messageHandler.destroy();
          worker.terminate();
          if (this.destroyed) {
            this._readyCapability.reject(new Error("Worker was destroyed"));
          } else {
            this._setupFakeWorker();
          }
        };
        const onWorkerError = () => {
          if (!this._webWorker) {
            terminateEarly();
          }
        };
        worker.addEventListener("error", onWorkerError);
        messageHandler.on("test", data => {
          worker.removeEventListener("error", onWorkerError);
          if (this.destroyed) {
            terminateEarly();
            return;
          }
          if (data) {
            this._messageHandler = messageHandler;
            this._port = worker;
            this._webWorker = worker;
            this._readyCapability.resolve();
            messageHandler.send("configure", {
              verbosity: this.verbosity
            });
          } else {
            this._setupFakeWorker();
            messageHandler.destroy();
            worker.terminate();
          }
        });
        messageHandler.on("ready", data => {
          worker.removeEventListener("error", onWorkerError);
          if (this.destroyed) {
            terminateEarly();
            return;
          }
          try {
            sendTest();
          } catch {
            this._setupFakeWorker();
          }
        });
        const sendTest = () => {
          const testObj = new Uint8Array();
          messageHandler.send("test", testObj, [testObj.buffer]);
        };
        sendTest();
        return;
      } catch {
        (0, _util.info)("The worker has been disabled.");
      }
    }
    this._setupFakeWorker();
  }
  _setupFakeWorker() {
    if (!PDFWorkerUtil.isWorkerDisabled) {
      (0, _util.warn)("Setting up fake worker.");
      PDFWorkerUtil.isWorkerDisabled = true;
    }
    PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {
      if (this.destroyed) {
        this._readyCapability.reject(new Error("Worker was destroyed"));
        return;
      }
      const port = new LoopbackPort();
      this._port = port;
      const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;
      const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
      WorkerMessageHandler.setup(workerHandler, port);
      const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
      this._messageHandler = messageHandler;
      this._readyCapability.resolve();
      messageHandler.send("configure", {
        verbosity: this.verbosity
      });
    }).catch(reason => {
      this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
    });
  }
  destroy() {
    this.destroyed = true;
    if (this._webWorker) {
      this._webWorker.terminate();
      this._webWorker = null;
    }
    PDFWorker.#workerPorts?.delete(this._port);
    this._port = null;
    if (this._messageHandler) {
      this._messageHandler.destroy();
      this._messageHandler = null;
    }
  }
  static fromPort(params) {
    if (!params?.port) {
      throw new Error("PDFWorker.fromPort - invalid method signature.");
    }
    const cachedPort = this.#workerPorts?.get(params.port);
    if (cachedPort) {
      if (cachedPort._pendingDestroy) {
        throw new Error("PDFWorker.fromPort - the worker is being destroyed.\n" + "Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      }
      return cachedPort;
    }
    return new PDFWorker(params);
  }
  static get workerSrc() {
    if (_worker_options.GlobalWorkerOptions.workerSrc) {
      return _worker_options.GlobalWorkerOptions.workerSrc;
    }
    if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
      if (!_util.isNodeJS) {
        (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
      }
      return PDFWorkerUtil.fallbackWorkerSrc;
    }
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get _mainThreadWorkerMessageHandler() {
    try {
      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
    } catch {
      return null;
    }
  }
  static get _setupFakeWorkerGlobal() {
    const loader = async () => {
      const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
      if (mainWorkerMessageHandler) {
        return mainWorkerMessageHandler;
      }
      if (_util.isNodeJS && "function" === "function") {
        const worker = eval("require")(this.workerSrc);
        return worker.WorkerMessageHandler;
      }
      await (0, _display_utils.loadScript)(this.workerSrc);
      return window.pdfjsWorker.WorkerMessageHandler;
    };
    return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
  }
}
exports.PDFWorker = PDFWorker;
class WorkerTransport {
  #methodPromises = new Map();
  #pageCache = new Map();
  #pagePromises = new Map();
  #passwordCapability = null;
  constructor(messageHandler, loadingTask, networkStream, params, factory) {
    this.messageHandler = messageHandler;
    this.loadingTask = loadingTask;
    this.commonObjs = new PDFObjects();
    this.fontLoader = new _font_loader.FontLoader({
      ownerDocument: params.ownerDocument,
      styleElement: params.styleElement
    });
    this._params = params;
    this.canvasFactory = factory.canvasFactory;
    this.filterFactory = factory.filterFactory;
    this.cMapReaderFactory = factory.cMapReaderFactory;
    this.standardFontDataFactory = factory.standardFontDataFactory;
    this.destroyed = false;
    this.destroyCapability = null;
    this._networkStream = networkStream;
    this._fullReader = null;
    this._lastProgress = null;
    this.downloadInfoCapability = new _util.PromiseCapability();
    this.setupMessageHandler();
  }
  #cacheSimpleMethod(name, data = null) {
    const cachedPromise = this.#methodPromises.get(name);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise(name, data);
    this.#methodPromises.set(name, promise);
    return promise;
  }
  get annotationStorage() {
    return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
  }
  getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {
    let renderingIntent = _util.RenderingIntentFlag.DISPLAY;
    let annotationStorageSerializable = _annotation_storage.SerializableEmpty;
    switch (intent) {
      case "any":
        renderingIntent = _util.RenderingIntentFlag.ANY;
        break;
      case "display":
        break;
      case "print":
        renderingIntent = _util.RenderingIntentFlag.PRINT;
        break;
      default:
        (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);
    }
    switch (annotationMode) {
      case _util.AnnotationMode.DISABLE:
        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
        break;
      case _util.AnnotationMode.ENABLE:
        break;
      case _util.AnnotationMode.ENABLE_FORMS:
        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
        break;
      case _util.AnnotationMode.ENABLE_STORAGE:
        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
        const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
        annotationStorageSerializable = annotationStorage.serializable;
        break;
      default:
        (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
    }
    if (isOpList) {
      renderingIntent += _util.RenderingIntentFlag.OPLIST;
    }
    return {
      renderingIntent,
      cacheKey: `${renderingIntent}_${annotationStorageSerializable.hash}`,
      annotationStorageSerializable
    };
  }
  destroy() {
    if (this.destroyCapability) {
      return this.destroyCapability.promise;
    }
    this.destroyed = true;
    this.destroyCapability = new _util.PromiseCapability();
    this.#passwordCapability?.reject(new Error("Worker was destroyed during onPassword callback"));
    const waitOn = [];
    for (const page of this.#pageCache.values()) {
      waitOn.push(page._destroy());
    }
    this.#pageCache.clear();
    this.#pagePromises.clear();
    if (this.hasOwnProperty("annotationStorage")) {
      this.annotationStorage.resetModified();
    }
    const terminated = this.messageHandler.sendWithPromise("Terminate", null);
    waitOn.push(terminated);
    Promise.all(waitOn).then(() => {
      this.commonObjs.clear();
      this.fontLoader.clear();
      this.#methodPromises.clear();
      this.filterFactory.destroy();
      this._networkStream?.cancelAllRequests(new _util.AbortException("Worker was terminated."));
      if (this.messageHandler) {
        this.messageHandler.destroy();
        this.messageHandler = null;
      }
      this.destroyCapability.resolve();
    }, this.destroyCapability.reject);
    return this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const {
      messageHandler,
      loadingTask
    } = this;
    messageHandler.on("GetReader", (data, sink) => {
      (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
      this._fullReader = this._networkStream.getFullReader();
      this._fullReader.onProgress = evt => {
        this._lastProgress = {
          loaded: evt.loaded,
          total: evt.total
        };
      };
      sink.onPull = () => {
        this._fullReader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }
          (0, _util.assert)(value instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch(reason => {
          sink.error(reason);
        });
      };
      sink.onCancel = reason => {
        this._fullReader.cancel(reason);
        sink.ready.catch(readyReason => {
          if (this.destroyed) {
            return;
          }
          throw readyReason;
        });
      };
    });
    messageHandler.on("ReaderHeadersReady", data => {
      const headersCapability = new _util.PromiseCapability();
      const fullReader = this._fullReader;
      fullReader.headersReady.then(() => {
        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
          if (this._lastProgress) {
            loadingTask.onProgress?.(this._lastProgress);
          }
          fullReader.onProgress = evt => {
            loadingTask.onProgress?.({
              loaded: evt.loaded,
              total: evt.total
            });
          };
        }
        headersCapability.resolve({
          isStreamingSupported: fullReader.isStreamingSupported,
          isRangeSupported: fullReader.isRangeSupported,
          contentLength: fullReader.contentLength
        });
      }, headersCapability.reject);
      return headersCapability.promise;
    });
    messageHandler.on("GetRangeReader", (data, sink) => {
      (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
      if (!rangeReader) {
        sink.close();
        return;
      }
      sink.onPull = () => {
        rangeReader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }
          (0, _util.assert)(value instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch(reason => {
          sink.error(reason);
        });
      };
      sink.onCancel = reason => {
        rangeReader.cancel(reason);
        sink.ready.catch(readyReason => {
          if (this.destroyed) {
            return;
          }
          throw readyReason;
        });
      };
    });
    messageHandler.on("GetDoc", ({
      pdfInfo
    }) => {
      this._numPages = pdfInfo.numPages;
      this._htmlForXfa = pdfInfo.htmlForXfa;
      delete pdfInfo.htmlForXfa;
      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
    });
    messageHandler.on("DocException", function (ex) {
      let reason;
      switch (ex.name) {
        case "PasswordException":
          reason = new _util.PasswordException(ex.message, ex.code);
          break;
        case "InvalidPDFException":
          reason = new _util.InvalidPDFException(ex.message);
          break;
        case "MissingPDFException":
          reason = new _util.MissingPDFException(ex.message);
          break;
        case "UnexpectedResponseException":
          reason = new _util.UnexpectedResponseException(ex.message, ex.status);
          break;
        case "UnknownErrorException":
          reason = new _util.UnknownErrorException(ex.message, ex.details);
          break;
        default:
          (0, _util.unreachable)("DocException - expected a valid Error.");
      }
      loadingTask._capability.reject(reason);
    });
    messageHandler.on("PasswordRequest", exception => {
      this.#passwordCapability = new _util.PromiseCapability();
      if (loadingTask.onPassword) {
        const updatePassword = password => {
          if (password instanceof Error) {
            this.#passwordCapability.reject(password);
          } else {
            this.#passwordCapability.resolve({
              password
            });
          }
        };
        try {
          loadingTask.onPassword(updatePassword, exception.code);
        } catch (ex) {
          this.#passwordCapability.reject(ex);
        }
      } else {
        this.#passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
      }
      return this.#passwordCapability.promise;
    });
    messageHandler.on("DataLoaded", data => {
      loadingTask.onProgress?.({
        loaded: data.length,
        total: data.length
      });
      this.downloadInfoCapability.resolve(data);
    });
    messageHandler.on("StartRenderPage", data => {
      if (this.destroyed) {
        return;
      }
      const page = this.#pageCache.get(data.pageIndex);
      page._startRenderPage(data.transparency, data.cacheKey);
    });
    messageHandler.on("commonobj", ([id, type, exportedData]) => {
      if (this.destroyed) {
        return;
      }
      if (this.commonObjs.has(id)) {
        return;
      }
      switch (type) {
        case "Font":
          const params = this._params;
          if ("error" in exportedData) {
            const exportedError = exportedData.error;
            (0, _util.warn)(`Error during font loading: ${exportedError}`);
            this.commonObjs.resolve(id, exportedError);
            break;
          }
          const inspectFont = params.pdfBug && globalThis.FontInspector?.enabled ? (font, url) => globalThis.FontInspector.fontAdded(font, url) : null;
          const font = new _font_loader.FontFaceObject(exportedData, {
            isEvalSupported: params.isEvalSupported,
            disableFontFace: params.disableFontFace,
            ignoreErrors: params.ignoreErrors,
            inspectFont
          });
          this.fontLoader.bind(font).catch(reason => {
            return messageHandler.sendWithPromise("FontFallback", {
              id
            });
          }).finally(() => {
            if (!params.fontExtraProperties && font.data) {
              font.data = null;
            }
            this.commonObjs.resolve(id, font);
          });
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(id, exportedData);
          break;
        default:
          throw new Error(`Got unknown common object type ${type}`);
      }
    });
    messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
      if (this.destroyed) {
        return;
      }
      const pageProxy = this.#pageCache.get(pageIndex);
      if (pageProxy.objs.has(id)) {
        return;
      }
      switch (type) {
        case "Image":
          pageProxy.objs.resolve(id, imageData);
          if (imageData) {
            let length;
            if (imageData.bitmap) {
              const {
                width,
                height
              } = imageData;
              length = width * height * 4;
            } else {
              length = imageData.data?.length || 0;
            }
            if (length > _util.MAX_IMAGE_SIZE_TO_CACHE) {
              pageProxy._maybeCleanupAfterRender = true;
            }
          }
          break;
        case "Pattern":
          pageProxy.objs.resolve(id, imageData);
          break;
        default:
          throw new Error(`Got unknown object type ${type}`);
      }
    });
    messageHandler.on("DocProgress", data => {
      if (this.destroyed) {
        return;
      }
      loadingTask.onProgress?.({
        loaded: data.loaded,
        total: data.total
      });
    });
    messageHandler.on("FetchBuiltInCMap", data => {
      if (this.destroyed) {
        return Promise.reject(new Error("Worker was destroyed."));
      }
      if (!this.cMapReaderFactory) {
        return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
      }
      return this.cMapReaderFactory.fetch(data);
    });
    messageHandler.on("FetchStandardFontData", data => {
      if (this.destroyed) {
        return Promise.reject(new Error("Worker was destroyed."));
      }
      if (!this.standardFontDataFactory) {
        return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
      }
      return this.standardFontDataFactory.fetch(data);
    });
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    if (this.annotationStorage.size <= 0) {
      (0, _util.warn)("saveDocument called while `annotationStorage` is empty, " + "please use the getData-method instead.");
    }
    const {
      map,
      transfers
    } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: map,
      filename: this._fullReader?.filename ?? null
    }, transfers).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(pageNumber) {
    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
      return Promise.reject(new Error("Invalid page request."));
    }
    const pageIndex = pageNumber - 1,
      cachedPromise = this.#pagePromises.get(pageIndex);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex
    }).then(pageInfo => {
      if (this.destroyed) {
        throw new Error("Transport destroyed");
      }
      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
      this.#pageCache.set(pageIndex, page);
      return page;
    });
    this.#pagePromises.set(pageIndex, promise);
    return promise;
  }
  getPageIndex(ref) {
    if (typeof ref !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
      return Promise.reject(new Error("Invalid pageIndex request."));
    }
    return this.messageHandler.sendWithPromise("GetPageIndex", {
      num: ref.num,
      gen: ref.gen
    });
  }
  getAnnotations(pageIndex, intent) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex,
      intent
    });
  }
  getFieldObjects() {
    return this.#cacheSimpleMethod("GetFieldObjects");
  }
  hasJSActions() {
    return this.#cacheSimpleMethod("HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(id) {
    if (typeof id !== "string") {
      return Promise.reject(new Error("Invalid destination request."));
    }
    return this.messageHandler.sendWithPromise("GetDestination", {
      id
    });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getDocJSActions() {
    return this.#cacheSimpleMethod("GetDocJSActions");
  }
  getPageJSActions(pageIndex) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex
    });
  }
  getStructTree(pageIndex) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex
    });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig() {
    return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(results => {
      return new _optional_content_config.OptionalContentConfig(results);
    });
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const name = "GetMetadata",
      cachedPromise = this.#methodPromises.get(name);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise(name, null).then(results => {
      return {
        info: results[0],
        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
        contentDispositionFilename: this._fullReader?.filename ?? null,
        contentLength: this._fullReader?.contentLength ?? null
      };
    });
    this.#methodPromises.set(name, promise);
    return promise;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(keepLoadedFonts = false) {
    if (this.destroyed) {
      return;
    }
    await this.messageHandler.sendWithPromise("Cleanup", null);
    for (const page of this.#pageCache.values()) {
      const cleanupSuccessful = page.cleanup();
      if (!cleanupSuccessful) {
        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
      }
    }
    this.commonObjs.clear();
    if (!keepLoadedFonts) {
      this.fontLoader.clear();
    }
    this.#methodPromises.clear();
    this.filterFactory.destroy(true);
  }
  get loadingParams() {
    const {
      disableAutoFetch,
      enableXfa
    } = this._params;
    return (0, _util.shadow)(this, "loadingParams", {
      disableAutoFetch,
      enableXfa
    });
  }
}
class PDFObjects {
  #objs = Object.create(null);
  #ensureObj(objId) {
    return this.#objs[objId] ||= {
      capability: new _util.PromiseCapability(),
      data: null
    };
  }
  get(objId, callback = null) {
    if (callback) {
      const obj = this.#ensureObj(objId);
      obj.capability.promise.then(() => callback(obj.data));
      return null;
    }
    const obj = this.#objs[objId];
    if (!obj?.capability.settled) {
      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
    }
    return obj.data;
  }
  has(objId) {
    const obj = this.#objs[objId];
    return obj?.capability.settled || false;
  }
  resolve(objId, data = null) {
    const obj = this.#ensureObj(objId);
    obj.data = data;
    obj.capability.resolve();
  }
  clear() {
    for (const objId in this.#objs) {
      const {
        data
      } = this.#objs[objId];
      data?.bitmap?.close();
    }
    this.#objs = Object.create(null);
  }
}
class RenderTask {
  #internalRenderTask = null;
  constructor(internalRenderTask) {
    this.#internalRenderTask = internalRenderTask;
    this.onContinue = null;
  }
  get promise() {
    return this.#internalRenderTask.capability.promise;
  }
  cancel(extraDelay = 0) {
    this.#internalRenderTask.cancel(null, extraDelay);
  }
  get separateAnnots() {
    const {
      separateAnnots
    } = this.#internalRenderTask.operatorList;
    if (!separateAnnots) {
      return false;
    }
    const {
      annotationCanvasMap
    } = this.#internalRenderTask;
    return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;
  }
}
exports.RenderTask = RenderTask;
class InternalRenderTask {
  static #canvasInUse = new WeakSet();
  constructor({
    callback,
    params,
    objs,
    commonObjs,
    annotationCanvasMap,
    operatorList,
    pageIndex,
    canvasFactory,
    filterFactory,
    useRequestAnimationFrame = false,
    pdfBug = false,
    pageColors = null
  }) {
    this.callback = callback;
    this.params = params;
    this.objs = objs;
    this.commonObjs = commonObjs;
    this.annotationCanvasMap = annotationCanvasMap;
    this.operatorListIdx = null;
    this.operatorList = operatorList;
    this._pageIndex = pageIndex;
    this.canvasFactory = canvasFactory;
    this.filterFactory = filterFactory;
    this._pdfBug = pdfBug;
    this.pageColors = pageColors;
    this.running = false;
    this.graphicsReadyCallback = null;
    this.graphicsReady = false;
    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
    this.cancelled = false;
    this.capability = new _util.PromiseCapability();
    this.task = new RenderTask(this);
    this._cancelBound = this.cancel.bind(this);
    this._continueBound = this._continue.bind(this);
    this._scheduleNextBound = this._scheduleNext.bind(this);
    this._nextBound = this._next.bind(this);
    this._canvas = params.canvasContext.canvas;
  }
  get completed() {
    return this.capability.promise.catch(function () {});
  }
  initializeGraphics({
    transparency = false,
    optionalContentConfig
  }) {
    if (this.cancelled) {
      return;
    }
    if (this._canvas) {
      if (InternalRenderTask.#canvasInUse.has(this._canvas)) {
        throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
      }
      InternalRenderTask.#canvasInUse.add(this._canvas);
    }
    if (this._pdfBug && globalThis.StepperManager?.enabled) {
      this.stepper = globalThis.StepperManager.create(this._pageIndex);
      this.stepper.init(this.operatorList);
      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
    }
    const {
      canvasContext,
      viewport,
      transform,
      background
    } = this.params;
    this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
      optionalContentConfig
    }, this.annotationCanvasMap, this.pageColors);
    this.gfx.beginDrawing({
      transform,
      viewport,
      transparency,
      background
    });
    this.operatorListIdx = 0;
    this.graphicsReady = true;
    this.graphicsReadyCallback?.();
  }
  cancel(error = null, extraDelay = 0) {
    this.running = false;
    this.cancelled = true;
    this.gfx?.endDrawing();
    InternalRenderTask.#canvasInUse.delete(this._canvas);
    this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));
  }
  operatorListChanged() {
    if (!this.graphicsReady) {
      this.graphicsReadyCallback ||= this._continueBound;
      return;
    }
    this.stepper?.updateOperatorList(this.operatorList);
    if (this.running) {
      return;
    }
    this._continue();
  }
  _continue() {
    this.running = true;
    if (this.cancelled) {
      return;
    }
    if (this.task.onContinue) {
      this.task.onContinue(this._scheduleNextBound);
    } else {
      this._scheduleNext();
    }
  }
  _scheduleNext() {
    if (this._useRequestAnimationFrame) {
      window.requestAnimationFrame(() => {
        this._nextBound().catch(this._cancelBound);
      });
    } else {
      Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
  }
  async _next() {
    if (this.cancelled) {
      return;
    }
    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
    if (this.operatorListIdx === this.operatorList.argsArray.length) {
      this.running = false;
      if (this.operatorList.lastChunk) {
        this.gfx.endDrawing();
        InternalRenderTask.#canvasInUse.delete(this._canvas);
        this.callback();
      }
    }
  }
}
const version = '3.11.174';
exports.version = version;
const build = 'ce8716743';
exports.build = build;

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SerializableEmpty = exports.PrintAnnotationStorage = exports.AnnotationStorage = void 0;
var _util = __w_pdfjs_require__(1);
var _editor = __w_pdfjs_require__(4);
var _murmurhash = __w_pdfjs_require__(8);
const SerializableEmpty = Object.freeze({
  map: null,
  hash: "",
  transfers: undefined
});
exports.SerializableEmpty = SerializableEmpty;
class AnnotationStorage {
  #modified = false;
  #storage = new Map();
  constructor() {
    this.onSetModified = null;
    this.onResetModified = null;
    this.onAnnotationEditor = null;
  }
  getValue(key, defaultValue) {
    const value = this.#storage.get(key);
    if (value === undefined) {
      return defaultValue;
    }
    return Object.assign(defaultValue, value);
  }
  getRawValue(key) {
    return this.#storage.get(key);
  }
  remove(key) {
    this.#storage.delete(key);
    if (this.#storage.size === 0) {
      this.resetModified();
    }
    if (typeof this.onAnnotationEditor === "function") {
      for (const value of this.#storage.values()) {
        if (value instanceof _editor.AnnotationEditor) {
          return;
        }
      }
      this.onAnnotationEditor(null);
    }
  }
  setValue(key, value) {
    const obj = this.#storage.get(key);
    let modified = false;
    if (obj !== undefined) {
      for (const [entry, val] of Object.entries(value)) {
        if (obj[entry] !== val) {
          modified = true;
          obj[entry] = val;
        }
      }
    } else {
      modified = true;
      this.#storage.set(key, value);
    }
    if (modified) {
      this.#setModified();
    }
    if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === "function") {
      this.onAnnotationEditor(value.constructor._type);
    }
  }
  has(key) {
    return this.#storage.has(key);
  }
  getAll() {
    return this.#storage.size > 0 ? (0, _util.objectFromMap)(this.#storage) : null;
  }
  setAll(obj) {
    for (const [key, val] of Object.entries(obj)) {
      this.setValue(key, val);
    }
  }
  get size() {
    return this.#storage.size;
  }
  #setModified() {
    if (!this.#modified) {
      this.#modified = true;
      if (typeof this.onSetModified === "function") {
        this.onSetModified();
      }
    }
  }
  resetModified() {
    if (this.#modified) {
      this.#modified = false;
      if (typeof this.onResetModified === "function") {
        this.onResetModified();
      }
    }
  }
  get print() {
    return new PrintAnnotationStorage(this);
  }
  get serializable() {
    if (this.#storage.size === 0) {
      return SerializableEmpty;
    }
    const map = new Map(),
      hash = new _murmurhash.MurmurHash3_64(),
      transfers = [];
    const context = Object.create(null);
    let hasBitmap = false;
    for (const [key, val] of this.#storage) {
      const serialized = val instanceof _editor.AnnotationEditor ? val.serialize(false, context) : val;
      if (serialized) {
        map.set(key, serialized);
        hash.update(`${key}:${JSON.stringify(serialized)}`);
        hasBitmap ||= !!serialized.bitmap;
      }
    }
    if (hasBitmap) {
      for (const value of map.values()) {
        if (value.bitmap) {
          transfers.push(value.bitmap);
        }
      }
    }
    return map.size > 0 ? {
      map,
      hash: hash.hexdigest(),
      transfers
    } : SerializableEmpty;
  }
}
exports.AnnotationStorage = AnnotationStorage;
class PrintAnnotationStorage extends AnnotationStorage {
  #serializable;
  constructor(parent) {
    super();
    const {
      map,
      hash,
      transfers
    } = parent.serializable;
    const clone = structuredClone(map, transfers ? {
      transfer: transfers
    } : null);
    this.#serializable = {
      map: clone,
      hash,
      transfers
    };
  }
  get print() {
    (0, _util.unreachable)("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return this.#serializable;
  }
}
exports.PrintAnnotationStorage = PrintAnnotationStorage;

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AnnotationEditor = void 0;
var _tools = __w_pdfjs_require__(5);
var _util = __w_pdfjs_require__(1);
var _display_utils = __w_pdfjs_require__(6);
class AnnotationEditor {
  #altText = "";
  #altTextDecorative = false;
  #altTextButton = null;
  #altTextTooltip = null;
  #altTextTooltipTimeout = null;
  #keepAspectRatio = false;
  #resizersDiv = null;
  #boundFocusin = this.focusin.bind(this);
  #boundFocusout = this.focusout.bind(this);
  #hasBeenClicked = false;
  #isEditing = false;
  #isInEditMode = false;
  _initialOptions = Object.create(null);
  _uiManager = null;
  _focusEventsAllowed = true;
  _l10nPromise = null;
  #isDraggable = false;
  #zIndex = AnnotationEditor._zIndex++;
  static _borderLineWidth = -1;
  static _colorManager = new _tools.ColorManager();
  static _zIndex = 1;
  static SMALL_EDITOR_SIZE = 0;
  constructor(parameters) {
    if (this.constructor === AnnotationEditor) {
      (0, _util.unreachable)("Cannot initialize AnnotationEditor.");
    }
    this.parent = parameters.parent;
    this.id = parameters.id;
    this.width = this.height = null;
    this.pageIndex = parameters.parent.pageIndex;
    this.name = parameters.name;
    this.div = null;
    this._uiManager = parameters.uiManager;
    this.annotationElementId = null;
    this._willKeepAspectRatio = false;
    this._initialOptions.isCentered = parameters.isCentered;
    this._structTreeParentId = null;
    const {
      rotation,
      rawDims: {
        pageWidth,
        pageHeight,
        pageX,
        pageY
      }
    } = this.parent.viewport;
    this.rotation = rotation;
    this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
    this.pageDimensions = [pageWidth, pageHeight];
    this.pageTranslation = [pageX, pageY];
    const [width, height] = this.parentDimensions;
    this.x = parameters.x / width;
    this.y = parameters.y / height;
    this.isAttachedToDOM = false;
    this.deleted = false;
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  static get _defaultLineColor() {
    return (0, _util.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(editor) {
    const fakeEditor = new FakeEditor({
      id: editor.parent.getNextId(),
      parent: editor.parent,
      uiManager: editor._uiManager
    });
    fakeEditor.annotationElementId = editor.annotationElementId;
    fakeEditor.deleted = true;
    fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
  }
  static initialize(l10n, options = null) {
    AnnotationEditor._l10nPromise ||= new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map(str => [str, l10n.get(str)]));
    if (options?.strings) {
      for (const str of options.strings) {
        AnnotationEditor._l10nPromise.set(str, l10n.get(str));
      }
    }
    if (AnnotationEditor._borderLineWidth !== -1) {
      return;
    }
    const style = getComputedStyle(document.documentElement);
    AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(_type, _value) {}
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(mime) {
    return false;
  }
  static paste(item, parent) {
    (0, _util.unreachable)("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return this.#isDraggable;
  }
  set _isDraggable(value) {
    this.#isDraggable = value;
    this.div?.classList.toggle("draggable", value);
  }
  center() {
    const [pageWidth, pageHeight] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * pageHeight / (pageWidth * 2);
        this.y += this.width * pageWidth / (pageHeight * 2);
        break;
      case 180:
        this.x += this.width / 2;
        this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * pageHeight / (pageWidth * 2);
        this.y -= this.width * pageWidth / (pageHeight * 2);
        break;
      default:
        this.x -= this.width / 2;
        this.y -= this.height / 2;
        break;
    }
    this.fixAndSetPosition();
  }
  addCommands(params) {
    this._uiManager.addCommands(params);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = this.#zIndex;
  }
  setParent(parent) {
    if (parent !== null) {
      this.pageIndex = parent.pageIndex;
      this.pageDimensions = parent.pageDimensions;
    }
    this.parent = parent;
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    if (!this.#hasBeenClicked) {
      this.parent.setSelected(this);
    } else {
      this.#hasBeenClicked = false;
    }
  }
  focusout(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    if (!this.isAttachedToDOM) {
      return;
    }
    const target = event.relatedTarget;
    if (target?.closest(`#${this.id}`)) {
      return;
    }
    event.preventDefault();
    if (!this.parent?.isMultipleSelection) {
      this.commitOrRemove();
    }
  }
  commitOrRemove() {
    if (this.isEmpty()) {
      this.remove();
    } else {
      this.commit();
    }
  }
  commit() {
    this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(x, y, tx, ty) {
    const [width, height] = this.parentDimensions;
    [tx, ty] = this.screenToPageTranslation(tx, ty);
    this.x = (x + tx) / width;
    this.y = (y + ty) / height;
    this.fixAndSetPosition();
  }
  #translate([width, height], x, y) {
    [x, y] = this.screenToPageTranslation(x, y);
    this.x += x / width;
    this.y += y / height;
    this.fixAndSetPosition();
  }
  translate(x, y) {
    this.#translate(this.parentDimensions, x, y);
  }
  translateInPage(x, y) {
    this.#translate(this.pageDimensions, x, y);
    this.div.scrollIntoView({
      block: "nearest"
    });
  }
  drag(tx, ty) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.x += tx / parentWidth;
    this.y += ty / parentHeight;
    if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const {
        x,
        y
      } = this.div.getBoundingClientRect();
      if (this.parent.findNewParent(this, x, y)) {
        this.x -= Math.floor(this.x);
        this.y -= Math.floor(this.y);
      }
    }
    let {
      x,
      y
    } = this;
    const [bx, by] = this.#getBaseTranslation();
    x += bx;
    y += by;
    this.div.style.left = `${(100 * x).toFixed(2)}%`;
    this.div.style.top = `${(100 * y).toFixed(2)}%`;
    this.div.scrollIntoView({
      block: "nearest"
    });
  }
  #getBaseTranslation() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const {
      _borderLineWidth
    } = AnnotationEditor;
    const x = _borderLineWidth / parentWidth;
    const y = _borderLineWidth / parentHeight;
    switch (this.rotation) {
      case 90:
        return [-x, y];
      case 180:
        return [x, y];
      case 270:
        return [x, -y];
      default:
        return [-x, -y];
    }
  }
  fixAndSetPosition() {
    const [pageWidth, pageHeight] = this.pageDimensions;
    let {
      x,
      y,
      width,
      height
    } = this;
    width *= pageWidth;
    height *= pageHeight;
    x *= pageWidth;
    y *= pageHeight;
    switch (this.rotation) {
      case 0:
        x = Math.max(0, Math.min(pageWidth - width, x));
        y = Math.max(0, Math.min(pageHeight - height, y));
        break;
      case 90:
        x = Math.max(0, Math.min(pageWidth - height, x));
        y = Math.min(pageHeight, Math.max(width, y));
        break;
      case 180:
        x = Math.min(pageWidth, Math.max(width, x));
        y = Math.min(pageHeight, Math.max(height, y));
        break;
      case 270:
        x = Math.min(pageWidth, Math.max(height, x));
        y = Math.max(0, Math.min(pageHeight - width, y));
        break;
    }
    this.x = x /= pageWidth;
    this.y = y /= pageHeight;
    const [bx, by] = this.#getBaseTranslation();
    x += bx;
    y += by;
    const {
      style
    } = this.div;
    style.left = `${(100 * x).toFixed(2)}%`;
    style.top = `${(100 * y).toFixed(2)}%`;
    this.moveInDOM();
  }
  static #rotatePoint(x, y, angle) {
    switch (angle) {
      case 90:
        return [y, -x];
      case 180:
        return [-x, -y];
      case 270:
        return [-y, x];
      default:
        return [x, y];
    }
  }
  screenToPageTranslation(x, y) {
    return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);
  }
  pageTranslationToScreen(x, y) {
    return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);
  }
  #getRotationMatrix(rotation) {
    switch (rotation) {
      case 90:
        {
          const [pageWidth, pageHeight] = this.pageDimensions;
          return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];
        }
      case 180:
        return [-1, 0, 0, -1];
      case 270:
        {
          const [pageWidth, pageHeight] = this.pageDimensions;
          return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];
        }
      default:
        return [1, 0, 0, 1];
    }
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const {
      parentScale,
      pageDimensions: [pageWidth, pageHeight]
    } = this;
    const scaledWidth = pageWidth * parentScale;
    const scaledHeight = pageHeight * parentScale;
    return _util.FeatureTest.isCSSRoundSupported ? [Math.round(scaledWidth), Math.round(scaledHeight)] : [scaledWidth, scaledHeight];
  }
  setDims(width, height) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.div.style.width = `${(100 * width / parentWidth).toFixed(2)}%`;
    if (!this.#keepAspectRatio) {
      this.div.style.height = `${(100 * height / parentHeight).toFixed(2)}%`;
    }
    this.#altTextButton?.classList.toggle("small", width < AnnotationEditor.SMALL_EDITOR_SIZE || height < AnnotationEditor.SMALL_EDITOR_SIZE);
  }
  fixDims() {
    const {
      style
    } = this.div;
    const {
      height,
      width
    } = style;
    const widthPercent = width.endsWith("%");
    const heightPercent = !this.#keepAspectRatio && height.endsWith("%");
    if (widthPercent && heightPercent) {
      return;
    }
    const [parentWidth, parentHeight] = this.parentDimensions;
    if (!widthPercent) {
      style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;
    }
    if (!this.#keepAspectRatio && !heightPercent) {
      style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;
    }
  }
  getInitialTranslation() {
    return [0, 0];
  }
  #createResizers() {
    if (this.#resizersDiv) {
      return;
    }
    this.#resizersDiv = document.createElement("div");
    this.#resizersDiv.classList.add("resizers");
    const classes = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
    if (!this._willKeepAspectRatio) {
      classes.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft");
    }
    for (const name of classes) {
      const div = document.createElement("div");
      this.#resizersDiv.append(div);
      div.classList.add("resizer", name);
      div.addEventListener("pointerdown", this.#resizerPointerdown.bind(this, name));
      div.addEventListener("contextmenu", _display_utils.noContextMenu);
    }
    this.div.prepend(this.#resizersDiv);
  }
  #resizerPointerdown(name, event) {
    event.preventDefault();
    const {
      isMac
    } = _util.FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    const boundResizerPointermove = this.#resizerPointermove.bind(this, name);
    const savedDraggable = this._isDraggable;
    this._isDraggable = false;
    const pointerMoveOptions = {
      passive: true,
      capture: true
    };
    window.addEventListener("pointermove", boundResizerPointermove, pointerMoveOptions);
    const savedX = this.x;
    const savedY = this.y;
    const savedWidth = this.width;
    const savedHeight = this.height;
    const savedParentCursor = this.parent.div.style.cursor;
    const savedCursor = this.div.style.cursor;
    this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;
    const pointerUpCallback = () => {
      this._isDraggable = savedDraggable;
      window.removeEventListener("pointerup", pointerUpCallback);
      window.removeEventListener("blur", pointerUpCallback);
      window.removeEventListener("pointermove", boundResizerPointermove, pointerMoveOptions);
      this.parent.div.style.cursor = savedParentCursor;
      this.div.style.cursor = savedCursor;
      const newX = this.x;
      const newY = this.y;
      const newWidth = this.width;
      const newHeight = this.height;
      if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {
        return;
      }
      this.addCommands({
        cmd: () => {
          this.width = newWidth;
          this.height = newHeight;
          this.x = newX;
          this.y = newY;
          const [parentWidth, parentHeight] = this.parentDimensions;
          this.setDims(parentWidth * newWidth, parentHeight * newHeight);
          this.fixAndSetPosition();
        },
        undo: () => {
          this.width = savedWidth;
          this.height = savedHeight;
          this.x = savedX;
          this.y = savedY;
          const [parentWidth, parentHeight] = this.parentDimensions;
          this.setDims(parentWidth * savedWidth, parentHeight * savedHeight);
          this.fixAndSetPosition();
        },
        mustExec: true
      });
    };
    window.addEventListener("pointerup", pointerUpCallback);
    window.addEventListener("blur", pointerUpCallback);
  }
  #resizerPointermove(name, event) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const savedX = this.x;
    const savedY = this.y;
    const savedWidth = this.width;
    const savedHeight = this.height;
    const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;
    const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;
    const round = x => Math.round(x * 10000) / 10000;
    const rotationMatrix = this.#getRotationMatrix(this.rotation);
    const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];
    const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);
    const invTransf = (x, y) => [invRotationMatrix[0] * x + invRotationMatrix[2] * y, invRotationMatrix[1] * x + invRotationMatrix[3] * y];
    let getPoint;
    let getOpposite;
    let isDiagonal = false;
    let isHorizontal = false;
    switch (name) {
      case "topLeft":
        isDiagonal = true;
        getPoint = (w, h) => [0, 0];
        getOpposite = (w, h) => [w, h];
        break;
      case "topMiddle":
        getPoint = (w, h) => [w / 2, 0];
        getOpposite = (w, h) => [w / 2, h];
        break;
      case "topRight":
        isDiagonal = true;
        getPoint = (w, h) => [w, 0];
        getOpposite = (w, h) => [0, h];
        break;
      case "middleRight":
        isHorizontal = true;
        getPoint = (w, h) => [w, h / 2];
        getOpposite = (w, h) => [0, h / 2];
        break;
      case "bottomRight":
        isDiagonal = true;
        getPoint = (w, h) => [w, h];
        getOpposite = (w, h) => [0, 0];
        break;
      case "bottomMiddle":
        getPoint = (w, h) => [w / 2, h];
        getOpposite = (w, h) => [w / 2, 0];
        break;
      case "bottomLeft":
        isDiagonal = true;
        getPoint = (w, h) => [0, h];
        getOpposite = (w, h) => [w, 0];
        break;
      case "middleLeft":
        isHorizontal = true;
        getPoint = (w, h) => [0, h / 2];
        getOpposite = (w, h) => [w, h / 2];
        break;
    }
    const point = getPoint(savedWidth, savedHeight);
    const oppositePoint = getOpposite(savedWidth, savedHeight);
    let transfOppositePoint = transf(...oppositePoint);
    const oppositeX = round(savedX + transfOppositePoint[0]);
    const oppositeY = round(savedY + transfOppositePoint[1]);
    let ratioX = 1;
    let ratioY = 1;
    let [deltaX, deltaY] = this.screenToPageTranslation(event.movementX, event.movementY);
    [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);
    if (isDiagonal) {
      const oldDiag = Math.hypot(savedWidth, savedHeight);
      ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
    } else if (isHorizontal) {
      ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;
    } else {
      ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;
    }
    const newWidth = round(savedWidth * ratioX);
    const newHeight = round(savedHeight * ratioY);
    transfOppositePoint = transf(...getOpposite(newWidth, newHeight));
    const newX = oppositeX - transfOppositePoint[0];
    const newY = oppositeY - transfOppositePoint[1];
    this.width = newWidth;
    this.height = newHeight;
    this.x = newX;
    this.y = newY;
    this.setDims(parentWidth * newWidth, parentHeight * newHeight);
    this.fixAndSetPosition();
  }
  async addAltTextButton() {
    if (this.#altTextButton) {
      return;
    }
    const altText = this.#altTextButton = document.createElement("button");
    altText.className = "altText";
    const msg = await AnnotationEditor._l10nPromise.get("editor_alt_text_button_label");
    altText.textContent = msg;
    altText.setAttribute("aria-label", msg);
    altText.tabIndex = "0";
    altText.addEventListener("contextmenu", _display_utils.noContextMenu);
    altText.addEventListener("pointerdown", event => event.stopPropagation());
    altText.addEventListener("click", event => {
      event.preventDefault();
      this._uiManager.editAltText(this);
    }, {
      capture: true
    });
    altText.addEventListener("keydown", event => {
      if (event.target === altText && event.key === "Enter") {
        event.preventDefault();
        this._uiManager.editAltText(this);
      }
    });
    this.#setAltTextButtonState();
    this.div.append(altText);
    if (!AnnotationEditor.SMALL_EDITOR_SIZE) {
      const PERCENT = 40;
      AnnotationEditor.SMALL_EDITOR_SIZE = Math.min(128, Math.round(altText.getBoundingClientRect().width * (1 + PERCENT / 100)));
    }
  }
  async #setAltTextButtonState() {
    const button = this.#altTextButton;
    if (!button) {
      return;
    }
    if (!this.#altText && !this.#altTextDecorative) {
      button.classList.remove("done");
      this.#altTextTooltip?.remove();
      return;
    }
    AnnotationEditor._l10nPromise.get("editor_alt_text_edit_button_label").then(msg => {
      button.setAttribute("aria-label", msg);
    });
    let tooltip = this.#altTextTooltip;
    if (!tooltip) {
      this.#altTextTooltip = tooltip = document.createElement("span");
      tooltip.className = "tooltip";
      tooltip.setAttribute("role", "tooltip");
      const id = tooltip.id = `alt-text-tooltip-${this.id}`;
      button.setAttribute("aria-describedby", id);
      const DELAY_TO_SHOW_TOOLTIP = 100;
      button.addEventListener("mouseenter", () => {
        this.#altTextTooltipTimeout = setTimeout(() => {
          this.#altTextTooltipTimeout = null;
          this.#altTextTooltip.classList.add("show");
          this._uiManager._eventBus.dispatch("reporttelemetry", {
            source: this,
            details: {
              type: "editing",
              subtype: this.editorType,
              data: {
                action: "alt_text_tooltip"
              }
            }
          });
        }, DELAY_TO_SHOW_TOOLTIP);
      });
      button.addEventListener("mouseleave", () => {
        clearTimeout(this.#altTextTooltipTimeout);
        this.#altTextTooltipTimeout = null;
        this.#altTextTooltip?.classList.remove("show");
      });
    }
    button.classList.add("done");
    tooltip.innerText = this.#altTextDecorative ? await AnnotationEditor._l10nPromise.get("editor_alt_text_decorative_tooltip") : this.#altText;
    if (!tooltip.parentNode) {
      button.append(tooltip);
    }
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  get altTextData() {
    return {
      altText: this.#altText,
      decorative: this.#altTextDecorative
    };
  }
  set altTextData({
    altText,
    decorative
  }) {
    if (this.#altText === altText && this.#altTextDecorative === decorative) {
      return;
    }
    this.#altText = altText;
    this.#altTextDecorative = decorative;
    this.#setAltTextButtonState();
  }
  render() {
    this.div = document.createElement("div");
    this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
    this.div.className = this.name;
    this.div.setAttribute("id", this.id);
    this.div.setAttribute("tabIndex", 0);
    this.setInForeground();
    this.div.addEventListener("focusin", this.#boundFocusin);
    this.div.addEventListener("focusout", this.#boundFocusout);
    const [parentWidth, parentHeight] = this.parentDimensions;
    if (this.parentRotation % 180 !== 0) {
      this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;
      this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;
    }
    const [tx, ty] = this.getInitialTranslation();
    this.translate(tx, ty);
    (0, _tools.bindEvents)(this, this.div, ["pointerdown"]);
    return this.div;
  }
  pointerdown(event) {
    const {
      isMac
    } = _util.FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      event.preventDefault();
      return;
    }
    this.#hasBeenClicked = true;
    this.#setUpDragSession(event);
  }
  #setUpDragSession(event) {
    if (!this._isDraggable) {
      return;
    }
    const isSelected = this._uiManager.isSelected(this);
    this._uiManager.setUpDragSession();
    let pointerMoveOptions, pointerMoveCallback;
    if (isSelected) {
      pointerMoveOptions = {
        passive: true,
        capture: true
      };
      pointerMoveCallback = e => {
        const [tx, ty] = this.screenToPageTranslation(e.movementX, e.movementY);
        this._uiManager.dragSelectedEditors(tx, ty);
      };
      window.addEventListener("pointermove", pointerMoveCallback, pointerMoveOptions);
    }
    const pointerUpCallback = () => {
      window.removeEventListener("pointerup", pointerUpCallback);
      window.removeEventListener("blur", pointerUpCallback);
      if (isSelected) {
        window.removeEventListener("pointermove", pointerMoveCallback, pointerMoveOptions);
      }
      this.#hasBeenClicked = false;
      if (!this._uiManager.endDragSession()) {
        const {
          isMac
        } = _util.FeatureTest.platform;
        if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
          this.parent.toggleSelected(this);
        } else {
          this.parent.setSelected(this);
        }
      }
    };
    window.addEventListener("pointerup", pointerUpCallback);
    window.addEventListener("blur", pointerUpCallback);
  }
  moveInDOM() {
    this.parent?.moveEditorInDOM(this);
  }
  _setParentAndPosition(parent, x, y) {
    parent.changeParent(this);
    this.x = x;
    this.y = y;
    this.fixAndSetPosition();
  }
  getRect(tx, ty) {
    const scale = this.parentScale;
    const [pageWidth, pageHeight] = this.pageDimensions;
    const [pageX, pageY] = this.pageTranslation;
    const shiftX = tx / scale;
    const shiftY = ty / scale;
    const x = this.x * pageWidth;
    const y = this.y * pageHeight;
    const width = this.width * pageWidth;
    const height = this.height * pageHeight;
    switch (this.rotation) {
      case 0:
        return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];
      case 90:
        return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];
      case 180:
        return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];
      case 270:
        return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(rect, pageHeight) {
    const [x1, y1, x2, y2] = rect;
    const width = x2 - x1;
    const height = y2 - y1;
    switch (this.rotation) {
      case 0:
        return [x1, pageHeight - y2, width, height];
      case 90:
        return [x1, pageHeight - y1, height, width];
      case 180:
        return [x2, pageHeight - y1, width, height];
      case 270:
        return [x2, pageHeight - y2, height, width];
      default:
        throw new Error("Invalid rotation");
    }
  }
  onceAdded() {}
  isEmpty() {
    return false;
  }
  enableEditMode() {
    this.#isInEditMode = true;
  }
  disableEditMode() {
    this.#isInEditMode = false;
  }
  isInEditMode() {
    return this.#isInEditMode;
  }
  shouldGetKeyboardEvents() {
    return false;
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  rebuild() {
    this.div?.addEventListener("focusin", this.#boundFocusin);
    this.div?.addEventListener("focusout", this.#boundFocusout);
  }
  serialize(isForCopying = false, context = null) {
    (0, _util.unreachable)("An editor must be serializable");
  }
  static deserialize(data, parent, uiManager) {
    const editor = new this.prototype.constructor({
      parent,
      id: parent.getNextId(),
      uiManager
    });
    editor.rotation = data.rotation;
    const [pageWidth, pageHeight] = editor.pageDimensions;
    const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
    editor.x = x / pageWidth;
    editor.y = y / pageHeight;
    editor.width = width / pageWidth;
    editor.height = height / pageHeight;
    return editor;
  }
  remove() {
    this.div.removeEventListener("focusin", this.#boundFocusin);
    this.div.removeEventListener("focusout", this.#boundFocusout);
    if (!this.isEmpty()) {
      this.commit();
    }
    if (this.parent) {
      this.parent.remove(this);
    } else {
      this._uiManager.removeEditor(this);
    }
    this.#altTextButton?.remove();
    this.#altTextButton = null;
    this.#altTextTooltip = null;
  }
  get isResizable() {
    return false;
  }
  makeResizable() {
    if (this.isResizable) {
      this.#createResizers();
      this.#resizersDiv.classList.remove("hidden");
    }
  }
  select() {
    this.makeResizable();
    this.div?.classList.add("selectedEditor");
  }
  unselect() {
    this.#resizersDiv?.classList.add("hidden");
    this.div?.classList.remove("selectedEditor");
    if (this.div?.contains(document.activeElement)) {
      this._uiManager.currentLayer.div.focus();
    }
  }
  updateParams(type, value) {}
  disableEditing() {
    if (this.#altTextButton) {
      this.#altTextButton.hidden = true;
    }
  }
  enableEditing() {
    if (this.#altTextButton) {
      this.#altTextButton.hidden = false;
    }
  }
  enterInEditMode() {}
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return this.#isEditing;
  }
  set isEditing(value) {
    this.#isEditing = value;
    if (!this.parent) {
      return;
    }
    if (value) {
      this.parent.setSelected(this);
      this.parent.setActiveEditor(this);
    } else {
      this.parent.setActiveEditor(null);
    }
  }
  setAspectRatio(width, height) {
    this.#keepAspectRatio = true;
    const aspectRatio = width / height;
    const {
      style
    } = this.div;
    style.aspectRatio = aspectRatio;
    style.height = "auto";
  }
  static get MIN_SIZE() {
    return 16;
  }
}
exports.AnnotationEditor = AnnotationEditor;
class FakeEditor extends AnnotationEditor {
  constructor(params) {
    super(params);
    this.annotationElementId = params.annotationElementId;
    this.deleted = true;
  }
  serialize() {
    return {
      id: this.annotationElementId,
      deleted: true,
      pageIndex: this.pageIndex
    };
  }
}

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.KeyboardManager = exports.CommandManager = exports.ColorManager = exports.AnnotationEditorUIManager = void 0;
exports.bindEvents = bindEvents;
exports.opacityToHex = opacityToHex;
var _util = __w_pdfjs_require__(1);
var _display_utils = __w_pdfjs_require__(6);
function bindEvents(obj, element, names) {
  for (const name of names) {
    element.addEventListener(name, obj[name].bind(obj));
  }
}
function opacityToHex(opacity) {
  return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, "0");
}
class IdManager {
  #id = 0;
  getId() {
    return `${_util.AnnotationEditorPrefix}${this.#id++}`;
  }
}
class ImageManager {
  #baseId = (0, _util.getUuid)();
  #id = 0;
  #cache = null;
  static get _isSVGFittingCanvas() {
    const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
    const canvas = new OffscreenCanvas(1, 3);
    const ctx = canvas.getContext("2d");
    const image = new Image();
    image.src = svg;
    const promise = image.decode().then(() => {
      ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
      return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
    });
    return (0, _util.shadow)(this, "_isSVGFittingCanvas", promise);
  }
  async #get(key, rawData) {
    this.#cache ||= new Map();
    let data = this.#cache.get(key);
    if (data === null) {
      return null;
    }
    if (data?.bitmap) {
      data.refCounter += 1;
      return data;
    }
    try {
      data ||= {
        bitmap: null,
        id: `image_${this.#baseId}_${this.#id++}`,
        refCounter: 0,
        isSvg: false
      };
      let image;
      if (typeof rawData === "string") {
        data.url = rawData;
        const response = await fetch(rawData);
        if (!response.ok) {
          throw new Error(response.statusText);
        }
        image = await response.blob();
      } else {
        image = data.file = rawData;
      }
      if (image.type === "image/svg+xml") {
        const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;
        const fileReader = new FileReader();
        const imageElement = new Image();
        const imagePromise = new Promise((resolve, reject) => {
          imageElement.onload = () => {
            data.bitmap = imageElement;
            data.isSvg = true;
            resolve();
          };
          fileReader.onload = async () => {
            const url = data.svgUrl = fileReader.result;
            imageElement.src = (await mustRemoveAspectRatioPromise) ? `${url}#svgView(preserveAspectRatio(none))` : url;
          };
          imageElement.onerror = fileReader.onerror = reject;
        });
        fileReader.readAsDataURL(image);
        await imagePromise;
      } else {
        data.bitmap = await createImageBitmap(image);
      }
      data.refCounter = 1;
    } catch (e) {
      console.error(e);
      data = null;
    }
    this.#cache.set(key, data);
    if (data) {
      this.#cache.set(data.id, data);
    }
    return data;
  }
  async getFromFile(file) {
    const {
      lastModified,
      name,
      size,
      type
    } = file;
    return this.#get(`${lastModified}_${name}_${size}_${type}`, file);
  }
  async getFromUrl(url) {
    return this.#get(url, url);
  }
  async getFromId(id) {
    this.#cache ||= new Map();
    const data = this.#cache.get(id);
    if (!data) {
      return null;
    }
    if (data.bitmap) {
      data.refCounter += 1;
      return data;
    }
    if (data.file) {
      return this.getFromFile(data.file);
    }
    return this.getFromUrl(data.url);
  }
  getSvgUrl(id) {
    const data = this.#cache.get(id);
    if (!data?.isSvg) {
      return null;
    }
    return data.svgUrl;
  }
  deleteId(id) {
    this.#cache ||= new Map();
    const data = this.#cache.get(id);
    if (!data) {
      return;
    }
    data.refCounter -= 1;
    if (data.refCounter !== 0) {
      return;
    }
    data.bitmap = null;
  }
  isValidId(id) {
    return id.startsWith(`image_${this.#baseId}_`);
  }
}
class CommandManager {
  #commands = [];
  #locked = false;
  #maxSize;
  #position = -1;
  constructor(maxSize = 128) {
    this.#maxSize = maxSize;
  }
  add({
    cmd,
    undo,
    mustExec,
    type = NaN,
    overwriteIfSameType = false,
    keepUndo = false
  }) {
    if (mustExec) {
      cmd();
    }
    if (this.#locked) {
      return;
    }
    const save = {
      cmd,
      undo,
      type
    };
    if (this.#position === -1) {
      if (this.#commands.length > 0) {
        this.#commands.length = 0;
      }
      this.#position = 0;
      this.#commands.push(save);
      return;
    }
    if (overwriteIfSameType && this.#commands[this.#position].type === type) {
      if (keepUndo) {
        save.undo = this.#commands[this.#position].undo;
      }
      this.#commands[this.#position] = save;
      return;
    }
    const next = this.#position + 1;
    if (next === this.#maxSize) {
      this.#commands.splice(0, 1);
    } else {
      this.#position = next;
      if (next < this.#commands.length) {
        this.#commands.splice(next);
      }
    }
    this.#commands.push(save);
  }
  undo() {
    if (this.#position === -1) {
      return;
    }
    this.#locked = true;
    this.#commands[this.#position].undo();
    this.#locked = false;
    this.#position -= 1;
  }
  redo() {
    if (this.#position < this.#commands.length - 1) {
      this.#position += 1;
      this.#locked = true;
      this.#commands[this.#position].cmd();
      this.#locked = false;
    }
  }
  hasSomethingToUndo() {
    return this.#position !== -1;
  }
  hasSomethingToRedo() {
    return this.#position < this.#commands.length - 1;
  }
  destroy() {
    this.#commands = null;
  }
}
exports.CommandManager = CommandManager;
class KeyboardManager {
  constructor(callbacks) {
    this.buffer = [];
    this.callbacks = new Map();
    this.allKeys = new Set();
    const {
      isMac
    } = _util.FeatureTest.platform;
    for (const [keys, callback, options = {}] of callbacks) {
      for (const key of keys) {
        const isMacKey = key.startsWith("mac+");
        if (isMac && isMacKey) {
          this.callbacks.set(key.slice(4), {
            callback,
            options
          });
          this.allKeys.add(key.split("+").at(-1));
        } else if (!isMac && !isMacKey) {
          this.callbacks.set(key, {
            callback,
            options
          });
          this.allKeys.add(key.split("+").at(-1));
        }
      }
    }
  }
  #serialize(event) {
    if (event.altKey) {
      this.buffer.push("alt");
    }
    if (event.ctrlKey) {
      this.buffer.push("ctrl");
    }
    if (event.metaKey) {
      this.buffer.push("meta");
    }
    if (event.shiftKey) {
      this.buffer.push("shift");
    }
    this.buffer.push(event.key);
    const str = this.buffer.join("+");
    this.buffer.length = 0;
    return str;
  }
  exec(self, event) {
    if (!this.allKeys.has(event.key)) {
      return;
    }
    const info = this.callbacks.get(this.#serialize(event));
    if (!info) {
      return;
    }
    const {
      callback,
      options: {
        bubbles = false,
        args = [],
        checker = null
      }
    } = info;
    if (checker && !checker(self, event)) {
      return;
    }
    callback.bind(self, ...args)();
    if (!bubbles) {
      event.stopPropagation();
      event.preventDefault();
    }
  }
}
exports.KeyboardManager = KeyboardManager;
class ColorManager {
  static _colorsMapping = new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]);
  get _colors() {
    const colors = new Map([["CanvasText", null], ["Canvas", null]]);
    (0, _display_utils.getColorValues)(colors);
    return (0, _util.shadow)(this, "_colors", colors);
  }
  convert(color) {
    const rgb = (0, _display_utils.getRGB)(color);
    if (!window.matchMedia("(forced-colors: active)").matches) {
      return rgb;
    }
    for (const [name, RGB] of this._colors) {
      if (RGB.every((x, i) => x === rgb[i])) {
        return ColorManager._colorsMapping.get(name);
      }
    }
    return rgb;
  }
  getHexCode(name) {
    const rgb = this._colors.get(name);
    if (!rgb) {
      return name;
    }
    return _util.Util.makeHexColor(...rgb);
  }
}
exports.ColorManager = ColorManager;
class AnnotationEditorUIManager {
  #activeEditor = null;
  #allEditors = new Map();
  #allLayers = new Map();
  #altTextManager = null;
  #annotationStorage = null;
  #commandManager = new CommandManager();
  #currentPageIndex = 0;
  #deletedAnnotationsElementIds = new Set();
  #draggingEditors = null;
  #editorTypes = null;
  #editorsToRescale = new Set();
  #filterFactory = null;
  #idManager = new IdManager();
  #isEnabled = false;
  #isWaiting = false;
  #lastActiveElement = null;
  #mode = _util.AnnotationEditorType.NONE;
  #selectedEditors = new Set();
  #pageColors = null;
  #boundBlur = this.blur.bind(this);
  #boundFocus = this.focus.bind(this);
  #boundCopy = this.copy.bind(this);
  #boundCut = this.cut.bind(this);
  #boundPaste = this.paste.bind(this);
  #boundKeydown = this.keydown.bind(this);
  #boundOnEditingAction = this.onEditingAction.bind(this);
  #boundOnPageChanging = this.onPageChanging.bind(this);
  #boundOnScaleChanging = this.onScaleChanging.bind(this);
  #boundOnRotationChanging = this.onRotationChanging.bind(this);
  #previousStates = {
    isEditing: false,
    isEmpty: true,
    hasSomethingToUndo: false,
    hasSomethingToRedo: false,
    hasSelectedEditor: false
  };
  #translation = [0, 0];
  #translationTimeoutId = null;
  #container = null;
  #viewer = null;
  static TRANSLATE_SMALL = 1;
  static TRANSLATE_BIG = 10;
  static get _keyboardManager() {
    const proto = AnnotationEditorUIManager.prototype;
    const arrowChecker = self => {
      const {
        activeElement
      } = document;
      return activeElement && self.#container.contains(activeElement) && self.hasSomethingToControl();
    };
    const small = this.TRANSLATE_SMALL;
    const big = this.TRANSLATE_BIG;
    return (0, _util.shadow)(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], proto.selectAll], [["ctrl+z", "mac+meta+z"], proto.undo], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], proto.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], proto.delete], [["Escape", "mac+Escape"], proto.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], proto.translateSelectedEditors, {
      args: [-small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto.translateSelectedEditors, {
      args: [-big, 0],
      checker: arrowChecker
    }], [["ArrowRight", "mac+ArrowRight"], proto.translateSelectedEditors, {
      args: [small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto.translateSelectedEditors, {
      args: [big, 0],
      checker: arrowChecker
    }], [["ArrowUp", "mac+ArrowUp"], proto.translateSelectedEditors, {
      args: [0, -small],
      checker: arrowChecker
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto.translateSelectedEditors, {
      args: [0, -big],
      checker: arrowChecker
    }], [["ArrowDown", "mac+ArrowDown"], proto.translateSelectedEditors, {
      args: [0, small],
      checker: arrowChecker
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto.translateSelectedEditors, {
      args: [0, big],
      checker: arrowChecker
    }]]));
  }
  constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors) {
    this.#container = container;
    this.#viewer = viewer;
    this.#altTextManager = altTextManager;
    this._eventBus = eventBus;
    this._eventBus._on("editingaction", this.#boundOnEditingAction);
    this._eventBus._on("pagechanging", this.#boundOnPageChanging);
    this._eventBus._on("scalechanging", this.#boundOnScaleChanging);
    this._eventBus._on("rotationchanging", this.#boundOnRotationChanging);
    this.#annotationStorage = pdfDocument.annotationStorage;
    this.#filterFactory = pdfDocument.filterFactory;
    this.#pageColors = pageColors;
    this.viewParameters = {
      realScale: _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS,
      rotation: 0
    };
  }
  destroy() {
    this.#removeKeyboardManager();
    this.#removeFocusManager();
    this._eventBus._off("editingaction", this.#boundOnEditingAction);
    this._eventBus._off("pagechanging", this.#boundOnPageChanging);
    this._eventBus._off("scalechanging", this.#boundOnScaleChanging);
    this._eventBus._off("rotationchanging", this.#boundOnRotationChanging);
    for (const layer of this.#allLayers.values()) {
      layer.destroy();
    }
    this.#allLayers.clear();
    this.#allEditors.clear();
    this.#editorsToRescale.clear();
    this.#activeEditor = null;
    this.#selectedEditors.clear();
    this.#commandManager.destroy();
    this.#altTextManager.destroy();
  }
  get hcmFilter() {
    return (0, _util.shadow)(this, "hcmFilter", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : "none");
  }
  get direction() {
    return (0, _util.shadow)(this, "direction", getComputedStyle(this.#container).direction);
  }
  editAltText(editor) {
    this.#altTextManager?.editAltText(this, editor);
  }
  onPageChanging({
    pageNumber
  }) {
    this.#currentPageIndex = pageNumber - 1;
  }
  focusMainContainer() {
    this.#container.focus();
  }
  findParent(x, y) {
    for (const layer of this.#allLayers.values()) {
      const {
        x: layerX,
        y: layerY,
        width,
        height
      } = layer.div.getBoundingClientRect();
      if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {
        return layer;
      }
    }
    return null;
  }
  disableUserSelect(value = false) {
    this.#viewer.classList.toggle("noUserSelect", value);
  }
  addShouldRescale(editor) {
    this.#editorsToRescale.add(editor);
  }
  removeShouldRescale(editor) {
    this.#editorsToRescale.delete(editor);
  }
  onScaleChanging({
    scale
  }) {
    this.commitOrRemove();
    this.viewParameters.realScale = scale * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS;
    for (const editor of this.#editorsToRescale) {
      editor.onScaleChanging();
    }
  }
  onRotationChanging({
    pagesRotation
  }) {
    this.commitOrRemove();
    this.viewParameters.rotation = pagesRotation;
  }
  addToAnnotationStorage(editor) {
    if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {
      this.#annotationStorage.setValue(editor.id, editor);
    }
  }
  #addFocusManager() {
    window.addEventListener("focus", this.#boundFocus);
    window.addEventListener("blur", this.#boundBlur);
  }
  #removeFocusManager() {
    window.removeEventListener("focus", this.#boundFocus);
    window.removeEventListener("blur", this.#boundBlur);
  }
  blur() {
    if (!this.hasSelection) {
      return;
    }
    const {
      activeElement
    } = document;
    for (const editor of this.#selectedEditors) {
      if (editor.div.contains(activeElement)) {
        this.#lastActiveElement = [editor, activeElement];
        editor._focusEventsAllowed = false;
        break;
      }
    }
  }
  focus() {
    if (!this.#lastActiveElement) {
      return;
    }
    const [lastEditor, lastActiveElement] = this.#lastActiveElement;
    this.#lastActiveElement = null;
    lastActiveElement.addEventListener("focusin", () => {
      lastEditor._focusEventsAllowed = true;
    }, {
      once: true
    });
    lastActiveElement.focus();
  }
  #addKeyboardManager() {
    window.addEventListener("keydown", this.#boundKeydown, {
      capture: true
    });
  }
  #removeKeyboardManager() {
    window.removeEventListener("keydown", this.#boundKeydown, {
      capture: true
    });
  }
  #addCopyPasteListeners() {
    document.addEventListener("copy", this.#boundCopy);
    document.addEventListener("cut", this.#boundCut);
    document.addEventListener("paste", this.#boundPaste);
  }
  #removeCopyPasteListeners() {
    document.removeEventListener("copy", this.#boundCopy);
    document.removeEventListener("cut", this.#boundCut);
    document.removeEventListener("paste", this.#boundPaste);
  }
  addEditListeners() {
    this.#addKeyboardManager();
    this.#addCopyPasteListeners();
  }
  removeEditListeners() {
    this.#removeKeyboardManager();
    this.#removeCopyPasteListeners();
  }
  copy(event) {
    event.preventDefault();
    this.#activeEditor?.commitOrRemove();
    if (!this.hasSelection) {
      return;
    }
    const editors = [];
    for (const editor of this.#selectedEditors) {
      const serialized = editor.serialize(true);
      if (serialized) {
        editors.push(serialized);
      }
    }
    if (editors.length === 0) {
      return;
    }
    event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
  }
  cut(event) {
    this.copy(event);
    this.delete();
  }
  paste(event) {
    event.preventDefault();
    const {
      clipboardData
    } = event;
    for (const item of clipboardData.items) {
      for (const editorType of this.#editorTypes) {
        if (editorType.isHandlingMimeForPasting(item.type)) {
          editorType.paste(item, this.currentLayer);
          return;
        }
      }
    }
    let data = clipboardData.getData("application/pdfjs");
    if (!data) {
      return;
    }
    try {
      data = JSON.parse(data);
    } catch (ex) {
      (0, _util.warn)(`paste: "${ex.message}".`);
      return;
    }
    if (!Array.isArray(data)) {
      return;
    }
    this.unselectAll();
    const layer = this.currentLayer;
    try {
      const newEditors = [];
      for (const editor of data) {
        const deserializedEditor = layer.deserialize(editor);
        if (!deserializedEditor) {
          return;
        }
        newEditors.push(deserializedEditor);
      }
      const cmd = () => {
        for (const editor of newEditors) {
          this.#addEditorToLayer(editor);
        }
        this.#selectEditors(newEditors);
      };
      const undo = () => {
        for (const editor of newEditors) {
          editor.remove();
        }
      };
      this.addCommands({
        cmd,
        undo,
        mustExec: true
      });
    } catch (ex) {
      (0, _util.warn)(`paste: "${ex.message}".`);
    }
  }
  keydown(event) {
    if (!this.getActive()?.shouldGetKeyboardEvents()) {
      AnnotationEditorUIManager._keyboardManager.exec(this, event);
    }
  }
  onEditingAction(details) {
    if (["undo", "redo", "delete", "selectAll"].includes(details.name)) {
      this[details.name]();
    }
  }
  #dispatchUpdateStates(details) {
    const hasChanged = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value);
    if (hasChanged) {
      this._eventBus.dispatch("annotationeditorstateschanged", {
        source: this,
        details: Object.assign(this.#previousStates, details)
      });
    }
  }
  #dispatchUpdateUI(details) {
    this._eventBus.dispatch("annotationeditorparamschanged", {
      source: this,
      details
    });
  }
  setEditingState(isEditing) {
    if (isEditing) {
      this.#addFocusManager();
      this.#addKeyboardManager();
      this.#addCopyPasteListeners();
      this.#dispatchUpdateStates({
        isEditing: this.#mode !== _util.AnnotationEditorType.NONE,
        isEmpty: this.#isEmpty(),
        hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
        hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
        hasSelectedEditor: false
      });
    } else {
      this.#removeFocusManager();
      this.#removeKeyboardManager();
      this.#removeCopyPasteListeners();
      this.#dispatchUpdateStates({
        isEditing: false
      });
      this.disableUserSelect(false);
    }
  }
  registerEditorTypes(types) {
    if (this.#editorTypes) {
      return;
    }
    this.#editorTypes = types;
    for (const editorType of this.#editorTypes) {
      this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return this.#idManager.getId();
  }
  get currentLayer() {
    return this.#allLayers.get(this.#currentPageIndex);
  }
  getLayer(pageIndex) {
    return this.#allLayers.get(pageIndex);
  }
  get currentPageIndex() {
    return this.#currentPageIndex;
  }
  addLayer(layer) {
    this.#allLayers.set(layer.pageIndex, layer);
    if (this.#isEnabled) {
      layer.enable();
    } else {
      layer.disable();
    }
  }
  removeLayer(layer) {
    this.#allLayers.delete(layer.pageIndex);
  }
  updateMode(mode, editId = null) {
    if (this.#mode === mode) {
      return;
    }
    this.#mode = mode;
    if (mode === _util.AnnotationEditorType.NONE) {
      this.setEditingState(false);
      this.#disableAll();
      return;
    }
    this.setEditingState(true);
    this.#enableAll();
    this.unselectAll();
    for (const layer of this.#allLayers.values()) {
      layer.updateMode(mode);
    }
    if (!editId) {
      return;
    }
    for (const editor of this.#allEditors.values()) {
      if (editor.annotationElementId === editId) {
        this.setSelected(editor);
        editor.enterInEditMode();
        break;
      }
    }
  }
  updateToolbar(mode) {
    if (mode === this.#mode) {
      return;
    }
    this._eventBus.dispatch("switchannotationeditormode", {
      source: this,
      mode
    });
  }
  updateParams(type, value) {
    if (!this.#editorTypes) {
      return;
    }
    if (type === _util.AnnotationEditorParamsType.CREATE) {
      this.currentLayer.addNewEditor(type);
      return;
    }
    for (const editor of this.#selectedEditors) {
      editor.updateParams(type, value);
    }
    for (const editorType of this.#editorTypes) {
      editorType.updateDefaultParams(type, value);
    }
  }
  enableWaiting(mustWait = false) {
    if (this.#isWaiting === mustWait) {
      return;
    }
    this.#isWaiting = mustWait;
    for (const layer of this.#allLayers.values()) {
      if (mustWait) {
        layer.disableClick();
      } else {
        layer.enableClick();
      }
      layer.div.classList.toggle("waiting", mustWait);
    }
  }
  #enableAll() {
    if (!this.#isEnabled) {
      this.#isEnabled = true;
      for (const layer of this.#allLayers.values()) {
        layer.enable();
      }
    }
  }
  #disableAll() {
    this.unselectAll();
    if (this.#isEnabled) {
      this.#isEnabled = false;
      for (const layer of this.#allLayers.values()) {
        layer.disable();
      }
    }
  }
  getEditors(pageIndex) {
    const editors = [];
    for (const editor of this.#allEditors.values()) {
      if (editor.pageIndex === pageIndex) {
        editors.push(editor);
      }
    }
    return editors;
  }
  getEditor(id) {
    return this.#allEditors.get(id);
  }
  addEditor(editor) {
    this.#allEditors.set(editor.id, editor);
  }
  removeEditor(editor) {
    this.#allEditors.delete(editor.id);
    this.unselect(editor);
    if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {
      this.#annotationStorage?.remove(editor.id);
    }
  }
  addDeletedAnnotationElement(editor) {
    this.#deletedAnnotationsElementIds.add(editor.annotationElementId);
    editor.deleted = true;
  }
  isDeletedAnnotationElement(annotationElementId) {
    return this.#deletedAnnotationsElementIds.has(annotationElementId);
  }
  removeDeletedAnnotationElement(editor) {
    this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);
    editor.deleted = false;
  }
  #addEditorToLayer(editor) {
    const layer = this.#allLayers.get(editor.pageIndex);
    if (layer) {
      layer.addOrRebuild(editor);
    } else {
      this.addEditor(editor);
    }
  }
  setActiveEditor(editor) {
    if (this.#activeEditor === editor) {
      return;
    }
    this.#activeEditor = editor;
    if (editor) {
      this.#dispatchUpdateUI(editor.propertiesToUpdate);
    }
  }
  toggleSelected(editor) {
    if (this.#selectedEditors.has(editor)) {
      this.#selectedEditors.delete(editor);
      editor.unselect();
      this.#dispatchUpdateStates({
        hasSelectedEditor: this.hasSelection
      });
      return;
    }
    this.#selectedEditors.add(editor);
    editor.select();
    this.#dispatchUpdateUI(editor.propertiesToUpdate);
    this.#dispatchUpdateStates({
      hasSelectedEditor: true
    });
  }
  setSelected(editor) {
    for (const ed of this.#selectedEditors) {
      if (ed !== editor) {
        ed.unselect();
      }
    }
    this.#selectedEditors.clear();
    this.#selectedEditors.add(editor);
    editor.select();
    this.#dispatchUpdateUI(editor.propertiesToUpdate);
    this.#dispatchUpdateStates({
      hasSelectedEditor: true
    });
  }
  isSelected(editor) {
    return this.#selectedEditors.has(editor);
  }
  unselect(editor) {
    editor.unselect();
    this.#selectedEditors.delete(editor);
    this.#dispatchUpdateStates({
      hasSelectedEditor: this.hasSelection
    });
  }
  get hasSelection() {
    return this.#selectedEditors.size !== 0;
  }
  undo() {
    this.#commandManager.undo();
    this.#dispatchUpdateStates({
      hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
      hasSomethingToRedo: true,
      isEmpty: this.#isEmpty()
    });
  }
  redo() {
    this.#commandManager.redo();
    this.#dispatchUpdateStates({
      hasSomethingToUndo: true,
      hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
      isEmpty: this.#isEmpty()
    });
  }
  addCommands(params) {
    this.#commandManager.add(params);
    this.#dispatchUpdateStates({
      hasSomethingToUndo: true,
      hasSomethingToRedo: false,
      isEmpty: this.#isEmpty()
    });
  }
  #isEmpty() {
    if (this.#allEditors.size === 0) {
      return true;
    }
    if (this.#allEditors.size === 1) {
      for (const editor of this.#allEditors.values()) {
        return editor.isEmpty();
      }
    }
    return false;
  }
  delete() {
    this.commitOrRemove();
    if (!this.hasSelection) {
      return;
    }
    const editors = [...this.#selectedEditors];
    const cmd = () => {
      for (const editor of editors) {
        editor.remove();
      }
    };
    const undo = () => {
      for (const editor of editors) {
        this.#addEditorToLayer(editor);
      }
    };
    this.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }
  commitOrRemove() {
    this.#activeEditor?.commitOrRemove();
  }
  hasSomethingToControl() {
    return this.#activeEditor || this.hasSelection;
  }
  #selectEditors(editors) {
    this.#selectedEditors.clear();
    for (const editor of editors) {
      if (editor.isEmpty()) {
        continue;
      }
      this.#selectedEditors.add(editor);
      editor.select();
    }
    this.#dispatchUpdateStates({
      hasSelectedEditor: true
    });
  }
  selectAll() {
    for (const editor of this.#selectedEditors) {
      editor.commit();
    }
    this.#selectEditors(this.#allEditors.values());
  }
  unselectAll() {
    if (this.#activeEditor) {
      this.#activeEditor.commitOrRemove();
      return;
    }
    if (!this.hasSelection) {
      return;
    }
    for (const editor of this.#selectedEditors) {
      editor.unselect();
    }
    this.#selectedEditors.clear();
    this.#dispatchUpdateStates({
      hasSelectedEditor: false
    });
  }
  translateSelectedEditors(x, y, noCommit = false) {
    if (!noCommit) {
      this.commitOrRemove();
    }
    if (!this.hasSelection) {
      return;
    }
    this.#translation[0] += x;
    this.#translation[1] += y;
    const [totalX, totalY] = this.#translation;
    const editors = [...this.#selectedEditors];
    const TIME_TO_WAIT = 1000;
    if (this.#translationTimeoutId) {
      clearTimeout(this.#translationTimeoutId);
    }
    this.#translationTimeoutId = setTimeout(() => {
      this.#translationTimeoutId = null;
      this.#translation[0] = this.#translation[1] = 0;
      this.addCommands({
        cmd: () => {
          for (const editor of editors) {
            if (this.#allEditors.has(editor.id)) {
              editor.translateInPage(totalX, totalY);
            }
          }
        },
        undo: () => {
          for (const editor of editors) {
            if (this.#allEditors.has(editor.id)) {
              editor.translateInPage(-totalX, -totalY);
            }
          }
        },
        mustExec: false
      });
    }, TIME_TO_WAIT);
    for (const editor of editors) {
      editor.translateInPage(x, y);
    }
  }
  setUpDragSession() {
    if (!this.hasSelection) {
      return;
    }
    this.disableUserSelect(true);
    this.#draggingEditors = new Map();
    for (const editor of this.#selectedEditors) {
      this.#draggingEditors.set(editor, {
        savedX: editor.x,
        savedY: editor.y,
        savedPageIndex: editor.pageIndex,
        newX: 0,
        newY: 0,
        newPageIndex: -1
      });
    }
  }
  endDragSession() {
    if (!this.#draggingEditors) {
      return false;
    }
    this.disableUserSelect(false);
    const map = this.#draggingEditors;
    this.#draggingEditors = null;
    let mustBeAddedInUndoStack = false;
    for (const [{
      x,
      y,
      pageIndex
    }, value] of map) {
      value.newX = x;
      value.newY = y;
      value.newPageIndex = pageIndex;
      mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;
    }
    if (!mustBeAddedInUndoStack) {
      return false;
    }
    const move = (editor, x, y, pageIndex) => {
      if (this.#allEditors.has(editor.id)) {
        const parent = this.#allLayers.get(pageIndex);
        if (parent) {
          editor._setParentAndPosition(parent, x, y);
        } else {
          editor.pageIndex = pageIndex;
          editor.x = x;
          editor.y = y;
        }
      }
    };
    this.addCommands({
      cmd: () => {
        for (const [editor, {
          newX,
          newY,
          newPageIndex
        }] of map) {
          move(editor, newX, newY, newPageIndex);
        }
      },
      undo: () => {
        for (const [editor, {
          savedX,
          savedY,
          savedPageIndex
        }] of map) {
          move(editor, savedX, savedY, savedPageIndex);
        }
      },
      mustExec: true
    });
    return true;
  }
  dragSelectedEditors(tx, ty) {
    if (!this.#draggingEditors) {
      return;
    }
    for (const editor of this.#draggingEditors.keys()) {
      editor.drag(tx, ty);
    }
  }
  rebuild(editor) {
    if (editor.parent === null) {
      const parent = this.getLayer(editor.pageIndex);
      if (parent) {
        parent.changeParent(editor);
        parent.addOrRebuild(editor);
      } else {
        this.addEditor(editor);
        this.addToAnnotationStorage(editor);
        editor.rebuild();
      }
    } else {
      editor.parent.addOrRebuild(editor);
    }
  }
  isActive(editor) {
    return this.#activeEditor === editor;
  }
  getActive() {
    return this.#activeEditor;
  }
  getMode() {
    return this.#mode;
  }
  get imageManager() {
    return (0, _util.shadow)(this, "imageManager", new ImageManager());
  }
}
exports.AnnotationEditorUIManager = AnnotationEditorUIManager;

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMFilterFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = void 0;
exports.deprecated = deprecated;
exports.getColorValues = getColorValues;
exports.getCurrentTransform = getCurrentTransform;
exports.getCurrentTransformInverse = getCurrentTransformInverse;
exports.getFilenameFromUrl = getFilenameFromUrl;
exports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
exports.getRGB = getRGB;
exports.getXfaPageViewport = getXfaPageViewport;
exports.isDataScheme = isDataScheme;
exports.isPdfFile = isPdfFile;
exports.isValidFetchUrl = isValidFetchUrl;
exports.loadScript = loadScript;
exports.noContextMenu = noContextMenu;
exports.setLayerDimensions = setLayerDimensions;
var _base_factory = __w_pdfjs_require__(7);
var _util = __w_pdfjs_require__(1);
const SVG_NS = "http://www.w3.org/2000/svg";
class PixelsPerInch {
  static CSS = 96.0;
  static PDF = 72.0;
  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;
}
exports.PixelsPerInch = PixelsPerInch;
class DOMFilterFactory extends _base_factory.BaseFilterFactory {
  #_cache;
  #_defs;
  #docId;
  #document;
  #hcmFilter;
  #hcmKey;
  #hcmUrl;
  #hcmHighlightFilter;
  #hcmHighlightKey;
  #hcmHighlightUrl;
  #id = 0;
  constructor({
    docId,
    ownerDocument = globalThis.document
  } = {}) {
    super();
    this.#docId = docId;
    this.#document = ownerDocument;
  }
  get #cache() {
    return this.#_cache ||= new Map();
  }
  get #defs() {
    if (!this.#_defs) {
      const div = this.#document.createElement("div");
      const {
        style
      } = div;
      style.visibility = "hidden";
      style.contain = "strict";
      style.width = style.height = 0;
      style.position = "absolute";
      style.top = style.left = 0;
      style.zIndex = -1;
      const svg = this.#document.createElementNS(SVG_NS, "svg");
      svg.setAttribute("width", 0);
      svg.setAttribute("height", 0);
      this.#_defs = this.#document.createElementNS(SVG_NS, "defs");
      div.append(svg);
      svg.append(this.#_defs);
      this.#document.body.append(div);
    }
    return this.#_defs;
  }
  addFilter(maps) {
    if (!maps) {
      return "none";
    }
    let value = this.#cache.get(maps);
    if (value) {
      return value;
    }
    let tableR, tableG, tableB, key;
    if (maps.length === 1) {
      const mapR = maps[0];
      const buffer = new Array(256);
      for (let i = 0; i < 256; i++) {
        buffer[i] = mapR[i] / 255;
      }
      key = tableR = tableG = tableB = buffer.join(",");
    } else {
      const [mapR, mapG, mapB] = maps;
      const bufferR = new Array(256);
      const bufferG = new Array(256);
      const bufferB = new Array(256);
      for (let i = 0; i < 256; i++) {
        bufferR[i] = mapR[i] / 255;
        bufferG[i] = mapG[i] / 255;
        bufferB[i] = mapB[i] / 255;
      }
      tableR = bufferR.join(",");
      tableG = bufferG.join(",");
      tableB = bufferB.join(",");
      key = `${tableR}${tableG}${tableB}`;
    }
    value = this.#cache.get(key);
    if (value) {
      this.#cache.set(maps, value);
      return value;
    }
    const id = `g_${this.#docId}_transfer_map_${this.#id++}`;
    const url = `url(#${id})`;
    this.#cache.set(maps, url);
    this.#cache.set(key, url);
    const filter = this.#createFilter(id);
    this.#addTransferMapConversion(tableR, tableG, tableB, filter);
    return url;
  }
  addHCMFilter(fgColor, bgColor) {
    const key = `${fgColor}-${bgColor}`;
    if (this.#hcmKey === key) {
      return this.#hcmUrl;
    }
    this.#hcmKey = key;
    this.#hcmUrl = "none";
    this.#hcmFilter?.remove();
    if (!fgColor || !bgColor) {
      return this.#hcmUrl;
    }
    const fgRGB = this.#getRGB(fgColor);
    fgColor = _util.Util.makeHexColor(...fgRGB);
    const bgRGB = this.#getRGB(bgColor);
    bgColor = _util.Util.makeHexColor(...bgRGB);
    this.#defs.style.color = "";
    if (fgColor === "#000000" && bgColor === "#ffffff" || fgColor === bgColor) {
      return this.#hcmUrl;
    }
    const map = new Array(256);
    for (let i = 0; i <= 255; i++) {
      const x = i / 255;
      map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
    }
    const table = map.join(",");
    const id = `g_${this.#docId}_hcm_filter`;
    const filter = this.#hcmHighlightFilter = this.#createFilter(id);
    this.#addTransferMapConversion(table, table, table, filter);
    this.#addGrayConversion(filter);
    const getSteps = (c, n) => {
      const start = fgRGB[c] / 255;
      const end = bgRGB[c] / 255;
      const arr = new Array(n + 1);
      for (let i = 0; i <= n; i++) {
        arr[i] = start + i / n * (end - start);
      }
      return arr.join(",");
    };
    this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);
    this.#hcmUrl = `url(#${id})`;
    return this.#hcmUrl;
  }
  addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {
    const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;
    if (this.#hcmHighlightKey === key) {
      return this.#hcmHighlightUrl;
    }
    this.#hcmHighlightKey = key;
    this.#hcmHighlightUrl = "none";
    this.#hcmHighlightFilter?.remove();
    if (!fgColor || !bgColor) {
      return this.#hcmHighlightUrl;
    }
    const [fgRGB, bgRGB] = [fgColor, bgColor].map(this.#getRGB.bind(this));
    let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);
    let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);
    let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(this.#getRGB.bind(this));
    if (bgGray < fgGray) {
      [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];
    }
    this.#defs.style.color = "";
    const getSteps = (fg, bg, n) => {
      const arr = new Array(256);
      const step = (bgGray - fgGray) / n;
      const newStart = fg / 255;
      const newStep = (bg - fg) / (255 * n);
      let prev = 0;
      for (let i = 0; i <= n; i++) {
        const k = Math.round(fgGray + i * step);
        const value = newStart + i * newStep;
        for (let j = prev; j <= k; j++) {
          arr[j] = value;
        }
        prev = k + 1;
      }
      for (let i = prev; i < 256; i++) {
        arr[i] = arr[prev - 1];
      }
      return arr.join(",");
    };
    const id = `g_${this.#docId}_hcm_highlight_filter`;
    const filter = this.#hcmHighlightFilter = this.#createFilter(id);
    this.#addGrayConversion(filter);
    this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);
    this.#hcmHighlightUrl = `url(#${id})`;
    return this.#hcmHighlightUrl;
  }
  destroy(keepHCM = false) {
    if (keepHCM && (this.#hcmUrl || this.#hcmHighlightUrl)) {
      return;
    }
    if (this.#_defs) {
      this.#_defs.parentNode.parentNode.remove();
      this.#_defs = null;
    }
    if (this.#_cache) {
      this.#_cache.clear();
      this.#_cache = null;
    }
    this.#id = 0;
  }
  #addGrayConversion(filter) {
    const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
    feColorMatrix.setAttribute("type", "matrix");
    feColorMatrix.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
    filter.append(feColorMatrix);
  }
  #createFilter(id) {
    const filter = this.#document.createElementNS(SVG_NS, "filter");
    filter.setAttribute("color-interpolation-filters", "sRGB");
    filter.setAttribute("id", id);
    this.#defs.append(filter);
    return filter;
  }
  #appendFeFunc(feComponentTransfer, func, table) {
    const feFunc = this.#document.createElementNS(SVG_NS, func);
    feFunc.setAttribute("type", "discrete");
    feFunc.setAttribute("tableValues", table);
    feComponentTransfer.append(feFunc);
  }
  #addTransferMapConversion(rTable, gTable, bTable, filter) {
    const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
    filter.append(feComponentTransfer);
    this.#appendFeFunc(feComponentTransfer, "feFuncR", rTable);
    this.#appendFeFunc(feComponentTransfer, "feFuncG", gTable);
    this.#appendFeFunc(feComponentTransfer, "feFuncB", bTable);
  }
  #getRGB(color) {
    this.#defs.style.color = color;
    return getRGB(getComputedStyle(this.#defs).getPropertyValue("color"));
  }
}
exports.DOMFilterFactory = DOMFilterFactory;
class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {
  constructor({
    ownerDocument = globalThis.document
  } = {}) {
    super();
    this._document = ownerDocument;
  }
  _createCanvas(width, height) {
    const canvas = this._document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }
}
exports.DOMCanvasFactory = DOMCanvasFactory;
async function fetchData(url, asTypedArray = false) {
  if (isValidFetchUrl(url, document.baseURI)) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(response.statusText);
    }
    return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text());
  }
  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();
    request.open("GET", url, true);
    if (asTypedArray) {
      request.responseType = "arraybuffer";
    }
    request.onreadystatechange = () => {
      if (request.readyState !== XMLHttpRequest.DONE) {
        return;
      }
      if (request.status === 200 || request.status === 0) {
        let data;
        if (asTypedArray && request.response) {
          data = new Uint8Array(request.response);
        } else if (!asTypedArray && request.responseText) {
          data = (0, _util.stringToBytes)(request.responseText);
        }
        if (data) {
          resolve(data);
          return;
        }
      }
      reject(new Error(request.statusText));
    };
    request.send(null);
  });
}
class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
  _fetchData(url, compressionType) {
    return fetchData(url, this.isCompressed).then(data => {
      return {
        cMapData: data,
        compressionType
      };
    });
  }
}
exports.DOMCMapReaderFactory = DOMCMapReaderFactory;
class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
  _fetchData(url) {
    return fetchData(url, true);
  }
}
exports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;
class DOMSVGFactory extends _base_factory.BaseSVGFactory {
  _createSVG(type) {
    return document.createElementNS(SVG_NS, type);
  }
}
exports.DOMSVGFactory = DOMSVGFactory;
class PageViewport {
  constructor({
    viewBox,
    scale,
    rotation,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  }) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    const centerX = (viewBox[2] + viewBox[0]) / 2;
    const centerY = (viewBox[3] + viewBox[1]) / 2;
    let rotateA, rotateB, rotateC, rotateD;
    rotation %= 360;
    if (rotation < 0) {
      rotation += 360;
    }
    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;
      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;
      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;
      case 0:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }
    let offsetCanvasX, offsetCanvasY;
    let width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = (viewBox[3] - viewBox[1]) * scale;
      height = (viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = (viewBox[2] - viewBox[0]) * scale;
      height = (viewBox[3] - viewBox[1]) * scale;
    }
    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
  }
  get rawDims() {
    const {
      viewBox
    } = this;
    return (0, _util.shadow)(this, "rawDims", {
      pageWidth: viewBox[2] - viewBox[0],
      pageHeight: viewBox[3] - viewBox[1],
      pageX: viewBox[0],
      pageY: viewBox[1]
    });
  }
  clone({
    scale = this.scale,
    rotation = this.rotation,
    offsetX = this.offsetX,
    offsetY = this.offsetY,
    dontFlip = false
  } = {}) {
    return new PageViewport({
      viewBox: this.viewBox.slice(),
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }
  convertToViewportPoint(x, y) {
    return _util.Util.applyTransform([x, y], this.transform);
  }
  convertToViewportRectangle(rect) {
    const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);
    const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);
    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
  }
  convertToPdfPoint(x, y) {
    return _util.Util.applyInverseTransform([x, y], this.transform);
  }
}
exports.PageViewport = PageViewport;
class RenderingCancelledException extends _util.BaseException {
  constructor(msg, extraDelay = 0) {
    super(msg, "RenderingCancelledException");
    this.extraDelay = extraDelay;
  }
}
exports.RenderingCancelledException = RenderingCancelledException;
function isDataScheme(url) {
  const ii = url.length;
  let i = 0;
  while (i < ii && url[i].trim() === "") {
    i++;
  }
  return url.substring(i, i + 5).toLowerCase() === "data:";
}
function isPdfFile(filename) {
  return typeof filename === "string" && /\.pdf$/i.test(filename);
}
function getFilenameFromUrl(url, onlyStripPath = false) {
  if (!onlyStripPath) {
    [url] = url.split(/[#?]/, 1);
  }
  return url.substring(url.lastIndexOf("/") + 1);
}
function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
  if (typeof url !== "string") {
    return defaultFilename;
  }
  if (isDataScheme(url)) {
    (0, _util.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
    return defaultFilename;
  }
  const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
  const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
  const splitURI = reURI.exec(url);
  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
  if (suggestedFilename) {
    suggestedFilename = suggestedFilename[0];
    if (suggestedFilename.includes("%")) {
      try {
        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
      } catch {}
    }
  }
  return suggestedFilename || defaultFilename;
}
class StatTimer {
  started = Object.create(null);
  times = [];
  time(name) {
    if (name in this.started) {
      (0, _util.warn)(`Timer is already running for ${name}`);
    }
    this.started[name] = Date.now();
  }
  timeEnd(name) {
    if (!(name in this.started)) {
      (0, _util.warn)(`Timer has not been started for ${name}`);
    }
    this.times.push({
      name,
      start: this.started[name],
      end: Date.now()
    });
    delete this.started[name];
  }
  toString() {
    const outBuf = [];
    let longest = 0;
    for (const {
      name
    } of this.times) {
      longest = Math.max(name.length, longest);
    }
    for (const {
      name,
      start,
      end
    } of this.times) {
      outBuf.push(`${name.padEnd(longest)} ${end - start}ms\n`);
    }
    return outBuf.join("");
  }
}
exports.StatTimer = StatTimer;
function isValidFetchUrl(url, baseUrl) {
  try {
    const {
      protocol
    } = baseUrl ? new URL(url, baseUrl) : new URL(url);
    return protocol === "http:" || protocol === "https:";
  } catch {
    return false;
  }
}
function noContextMenu(e) {
  e.preventDefault();
}
function loadScript(src, removeScriptElement = false) {
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = src;
    script.onload = function (evt) {
      if (removeScriptElement) {
        script.remove();
      }
      resolve(evt);
    };
    script.onerror = function () {
      reject(new Error(`Cannot load script at: ${script.src}`));
    };
    (document.head || document.documentElement).append(script);
  });
}
function deprecated(details) {
  console.log("Deprecated API usage: " + details);
}
let pdfDateStringRegex;
class PDFDateString {
  static toDateObject(input) {
    if (!input || typeof input !== "string") {
      return null;
    }
    pdfDateStringRegex ||= new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?");
    const matches = pdfDateStringRegex.exec(input);
    if (!matches) {
      return null;
    }
    const year = parseInt(matches[1], 10);
    let month = parseInt(matches[2], 10);
    month = month >= 1 && month <= 12 ? month - 1 : 0;
    let day = parseInt(matches[3], 10);
    day = day >= 1 && day <= 31 ? day : 1;
    let hour = parseInt(matches[4], 10);
    hour = hour >= 0 && hour <= 23 ? hour : 0;
    let minute = parseInt(matches[5], 10);
    minute = minute >= 0 && minute <= 59 ? minute : 0;
    let second = parseInt(matches[6], 10);
    second = second >= 0 && second <= 59 ? second : 0;
    const universalTimeRelation = matches[7] || "Z";
    let offsetHour = parseInt(matches[8], 10);
    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
    let offsetMinute = parseInt(matches[9], 10) || 0;
    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
    if (universalTimeRelation === "-") {
      hour += offsetHour;
      minute += offsetMinute;
    } else if (universalTimeRelation === "+") {
      hour -= offsetHour;
      minute -= offsetMinute;
    }
    return new Date(Date.UTC(year, month, day, hour, minute, second));
  }
}
exports.PDFDateString = PDFDateString;
function getXfaPageViewport(xfaPage, {
  scale = 1,
  rotation = 0
}) {
  const {
    width,
    height
  } = xfaPage.attributes.style;
  const viewBox = [0, 0, parseInt(width), parseInt(height)];
  return new PageViewport({
    viewBox,
    scale,
    rotation
  });
}
function getRGB(color) {
  if (color.startsWith("#")) {
    const colorRGB = parseInt(color.slice(1), 16);
    return [(colorRGB & 0xff0000) >> 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff];
  }
  if (color.startsWith("rgb(")) {
    return color.slice(4, -1).split(",").map(x => parseInt(x));
  }
  if (color.startsWith("rgba(")) {
    return color.slice(5, -1).split(",").map(x => parseInt(x)).slice(0, 3);
  }
  (0, _util.warn)(`Not a valid color format: "${color}"`);
  return [0, 0, 0];
}
function getColorValues(colors) {
  const span = document.createElement("span");
  span.style.visibility = "hidden";
  document.body.append(span);
  for (const name of colors.keys()) {
    span.style.color = name;
    const computedColor = window.getComputedStyle(span).color;
    colors.set(name, getRGB(computedColor));
  }
  span.remove();
}
function getCurrentTransform(ctx) {
  const {
    a,
    b,
    c,
    d,
    e,
    f
  } = ctx.getTransform();
  return [a, b, c, d, e, f];
}
function getCurrentTransformInverse(ctx) {
  const {
    a,
    b,
    c,
    d,
    e,
    f
  } = ctx.getTransform().invertSelf();
  return [a, b, c, d, e, f];
}
function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {
  if (viewport instanceof PageViewport) {
    const {
      pageWidth,
      pageHeight
    } = viewport.rawDims;
    const {
      style
    } = div;
    const useRound = _util.FeatureTest.isCSSRoundSupported;
    const w = `var(--scale-factor) * ${pageWidth}px`,
      h = `var(--scale-factor) * ${pageHeight}px`;
    const widthStr = useRound ? `round(${w}, 1px)` : `calc(${w})`,
      heightStr = useRound ? `round(${h}, 1px)` : `calc(${h})`;
    if (!mustFlip || viewport.rotation % 180 === 0) {
      style.width = widthStr;
      style.height = heightStr;
    } else {
      style.width = heightStr;
      style.height = widthStr;
    }
  }
  if (mustRotate) {
    div.setAttribute("data-main-rotation", viewport.rotation);
  }
}

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseFilterFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;
var _util = __w_pdfjs_require__(1);
class BaseFilterFactory {
  constructor() {
    if (this.constructor === BaseFilterFactory) {
      (0, _util.unreachable)("Cannot initialize BaseFilterFactory.");
    }
  }
  addFilter(maps) {
    return "none";
  }
  addHCMFilter(fgColor, bgColor) {
    return "none";
  }
  addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {
    return "none";
  }
  destroy(keepHCM = false) {}
}
exports.BaseFilterFactory = BaseFilterFactory;
class BaseCanvasFactory {
  constructor() {
    if (this.constructor === BaseCanvasFactory) {
      (0, _util.unreachable)("Cannot initialize BaseCanvasFactory.");
    }
  }
  create(width, height) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }
    const canvas = this._createCanvas(width, height);
    return {
      canvas,
      context: canvas.getContext("2d")
    };
  }
  reset(canvasAndContext, width, height) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }
    canvasAndContext.canvas.width = width;
    canvasAndContext.canvas.height = height;
  }
  destroy(canvasAndContext) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }
    canvasAndContext.canvas.width = 0;
    canvasAndContext.canvas.height = 0;
    canvasAndContext.canvas = null;
    canvasAndContext.context = null;
  }
  _createCanvas(width, height) {
    (0, _util.unreachable)("Abstract method `_createCanvas` called.");
  }
}
exports.BaseCanvasFactory = BaseCanvasFactory;
class BaseCMapReaderFactory {
  constructor({
    baseUrl = null,
    isCompressed = true
  }) {
    if (this.constructor === BaseCMapReaderFactory) {
      (0, _util.unreachable)("Cannot initialize BaseCMapReaderFactory.");
    }
    this.baseUrl = baseUrl;
    this.isCompressed = isCompressed;
  }
  async fetch({
    name
  }) {
    if (!this.baseUrl) {
      throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.');
    }
    if (!name) {
      throw new Error("CMap name must be specified.");
    }
    const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
    const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;
    return this._fetchData(url, compressionType).catch(reason => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
    });
  }
  _fetchData(url, compressionType) {
    (0, _util.unreachable)("Abstract method `_fetchData` called.");
  }
}
exports.BaseCMapReaderFactory = BaseCMapReaderFactory;
class BaseStandardFontDataFactory {
  constructor({
    baseUrl = null
  }) {
    if (this.constructor === BaseStandardFontDataFactory) {
      (0, _util.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
    }
    this.baseUrl = baseUrl;
  }
  async fetch({
    filename
  }) {
    if (!this.baseUrl) {
      throw new Error('The standard font "baseUrl" parameter must be specified, ensure that ' + 'the "standardFontDataUrl" API parameter is provided.');
    }
    if (!filename) {
      throw new Error("Font filename must be specified.");
    }
    const url = `${this.baseUrl}${filename}`;
    return this._fetchData(url).catch(reason => {
      throw new Error(`Unable to load font data at: ${url}`);
    });
  }
  _fetchData(url) {
    (0, _util.unreachable)("Abstract method `_fetchData` called.");
  }
}
exports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;
class BaseSVGFactory {
  constructor() {
    if (this.constructor === BaseSVGFactory) {
      (0, _util.unreachable)("Cannot initialize BaseSVGFactory.");
    }
  }
  create(width, height, skipDimensions = false) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid SVG dimensions");
    }
    const svg = this._createSVG("svg:svg");
    svg.setAttribute("version", "1.1");
    if (!skipDimensions) {
      svg.setAttribute("width", `${width}px`);
      svg.setAttribute("height", `${height}px`);
    }
    svg.setAttribute("preserveAspectRatio", "none");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    return svg;
  }
  createElement(type) {
    if (typeof type !== "string") {
      throw new Error("Invalid SVG element type");
    }
    return this._createSVG(type);
  }
  _createSVG(type) {
    (0, _util.unreachable)("Abstract method `_createSVG` called.");
  }
}
exports.BaseSVGFactory = BaseSVGFactory;

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MurmurHash3_64 = void 0;
var _util = __w_pdfjs_require__(1);
const SEED = 0xc3d2e1f0;
const MASK_HIGH = 0xffff0000;
const MASK_LOW = 0xffff;
class MurmurHash3_64 {
  constructor(seed) {
    this.h1 = seed ? seed & 0xffffffff : SEED;
    this.h2 = seed ? seed & 0xffffffff : SEED;
  }
  update(input) {
    let data, length;
    if (typeof input === "string") {
      data = new Uint8Array(input.length * 2);
      length = 0;
      for (let i = 0, ii = input.length; i < ii; i++) {
        const code = input.charCodeAt(i);
        if (code <= 0xff) {
          data[length++] = code;
        } else {
          data[length++] = code >>> 8;
          data[length++] = code & 0xff;
        }
      }
    } else if ((0, _util.isArrayBuffer)(input)) {
      data = input.slice();
      length = data.byteLength;
    } else {
      throw new Error("Wrong data format in MurmurHash3_64_update. " + "Input must be a string or array.");
    }
    const blockCounts = length >> 2;
    const tailLength = length - blockCounts * 4;
    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
    let k1 = 0,
      k2 = 0;
    let h1 = this.h1,
      h2 = this.h2;
    const C1 = 0xcc9e2d51,
      C2 = 0x1b873593;
    const C1_LOW = C1 & MASK_LOW,
      C2_LOW = C2 & MASK_LOW;
    for (let i = 0; i < blockCounts; i++) {
      if (i & 1) {
        k1 = dataUint32[i];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = h1 * 5 + 0xe6546b64;
      } else {
        k2 = dataUint32[i];
        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
        k2 = k2 << 15 | k2 >>> 17;
        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
        h2 ^= k2;
        h2 = h2 << 13 | h2 >>> 19;
        h2 = h2 * 5 + 0xe6546b64;
      }
    }
    k1 = 0;
    switch (tailLength) {
      case 3:
        k1 ^= data[blockCounts * 4 + 2] << 16;
      case 2:
        k1 ^= data[blockCounts * 4 + 1] << 8;
      case 1:
        k1 ^= data[blockCounts * 4];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        if (blockCounts & 1) {
          h1 ^= k1;
        } else {
          h2 ^= k1;
        }
    }
    this.h1 = h1;
    this.h2 = h2;
  }
  hexdigest() {
    let h1 = this.h1,
      h2 = this.h2;
    h1 ^= h2 >>> 1;
    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;
    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;
    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
  }
}
exports.MurmurHash3_64 = MurmurHash3_64;

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FontLoader = exports.FontFaceObject = void 0;
var _util = __w_pdfjs_require__(1);
class FontLoader {
  #systemFonts = new Set();
  constructor({
    ownerDocument = globalThis.document,
    styleElement = null
  }) {
    this._document = ownerDocument;
    this.nativeFontFaces = new Set();
    this.styleElement = null;
    this.loadingRequests = [];
    this.loadTestFontId = 0;
  }
  addNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.add(nativeFontFace);
    this._document.fonts.add(nativeFontFace);
  }
  removeNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.delete(nativeFontFace);
    this._document.fonts.delete(nativeFontFace);
  }
  insertRule(rule) {
    if (!this.styleElement) {
      this.styleElement = this._document.createElement("style");
      this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
    }
    const styleSheet = this.styleElement.sheet;
    styleSheet.insertRule(rule, styleSheet.cssRules.length);
  }
  clear() {
    for (const nativeFontFace of this.nativeFontFaces) {
      this._document.fonts.delete(nativeFontFace);
    }
    this.nativeFontFaces.clear();
    this.#systemFonts.clear();
    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }
  async loadSystemFont(info) {
    if (!info || this.#systemFonts.has(info.loadedName)) {
      return;
    }
    (0, _util.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
    if (this.isFontLoadingAPISupported) {
      const {
        loadedName,
        src,
        style
      } = info;
      const fontFace = new FontFace(loadedName, src, style);
      this.addNativeFontFace(fontFace);
      try {
        await fontFace.load();
        this.#systemFonts.add(loadedName);
      } catch {
        (0, _util.warn)(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);
        this.removeNativeFontFace(fontFace);
      }
      return;
    }
    (0, _util.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
  }
  async bind(font) {
    if (font.attached || font.missingFile && !font.systemFontInfo) {
      return;
    }
    font.attached = true;
    if (font.systemFontInfo) {
      await this.loadSystemFont(font.systemFontInfo);
      return;
    }
    if (this.isFontLoadingAPISupported) {
      const nativeFontFace = font.createNativeFontFace();
      if (nativeFontFace) {
        this.addNativeFontFace(nativeFontFace);
        try {
          await nativeFontFace.loaded;
        } catch (ex) {
          (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
          font.disableFontFace = true;
          throw ex;
        }
      }
      return;
    }
    const rule = font.createFontFaceRule();
    if (rule) {
      this.insertRule(rule);
      if (this.isSyncFontLoadingSupported) {
        return;
      }
      await new Promise(resolve => {
        const request = this._queueLoadingCallback(resolve);
        this._prepareFontLoadEvent(font, request);
      });
    }
  }
  get isFontLoadingAPISupported() {
    const hasFonts = !!this._document?.fonts;
    return (0, _util.shadow)(this, "isFontLoadingAPISupported", hasFonts);
  }
  get isSyncFontLoadingSupported() {
    let supported = false;
    if (_util.isNodeJS) {
      supported = true;
    } else if (typeof navigator !== "undefined" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) {
      supported = true;
    }
    return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported);
  }
  _queueLoadingCallback(callback) {
    function completeRequest() {
      (0, _util.assert)(!request.done, "completeRequest() cannot be called twice.");
      request.done = true;
      while (loadingRequests.length > 0 && loadingRequests[0].done) {
        const otherRequest = loadingRequests.shift();
        setTimeout(otherRequest.callback, 0);
      }
    }
    const {
      loadingRequests
    } = this;
    const request = {
      done: false,
      complete: completeRequest,
      callback
    };
    loadingRequests.push(request);
    return request;
  }
  get _loadTestFont() {
    const testFont = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
    return (0, _util.shadow)(this, "_loadTestFont", testFont);
  }
  _prepareFontLoadEvent(font, request) {
    function int32(data, offset) {
      return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
    }
    function spliceString(s, offset, remove, insert) {
      const chunk1 = s.substring(0, offset);
      const chunk2 = s.substring(offset + remove);
      return chunk1 + insert + chunk2;
    }
    let i, ii;
    const canvas = this._document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext("2d");
    let called = 0;
    function isFontReady(name, callback) {
      if (++called > 30) {
        (0, _util.warn)("Load test font never loaded.");
        callback();
        return;
      }
      ctx.font = "30px " + name;
      ctx.fillText(".", 0, 20);
      const imageData = ctx.getImageData(0, 0, 1, 1);
      if (imageData.data[3] > 0) {
        callback();
        return;
      }
      setTimeout(isFontReady.bind(null, name, callback));
    }
    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
    let data = this._loadTestFont;
    const COMMENT_OFFSET = 976;
    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
    const CFF_CHECKSUM_OFFSET = 16;
    const XXXX_VALUE = 0x58585858;
    let checksum = int32(data, CFF_CHECKSUM_OFFSET);
    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
    }
    if (i < loadTestFontId.length) {
      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
    }
    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
    const url = `url(data:font/opentype;base64,${btoa(data)});`;
    const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
    this.insertRule(rule);
    const div = this._document.createElement("div");
    div.style.visibility = "hidden";
    div.style.width = div.style.height = "10px";
    div.style.position = "absolute";
    div.style.top = div.style.left = "0px";
    for (const name of [font.loadedName, loadTestFontId]) {
      const span = this._document.createElement("span");
      span.textContent = "Hi";
      span.style.fontFamily = name;
      div.append(span);
    }
    this._document.body.append(div);
    isFontReady(loadTestFontId, () => {
      div.remove();
      request.complete();
    });
  }
}
exports.FontLoader = FontLoader;
class FontFaceObject {
  constructor(translatedData, {
    isEvalSupported = true,
    disableFontFace = false,
    ignoreErrors = false,
    inspectFont = null
  }) {
    this.compiledGlyphs = Object.create(null);
    for (const i in translatedData) {
      this[i] = translatedData[i];
    }
    this.isEvalSupported = isEvalSupported !== false;
    this.disableFontFace = disableFontFace === true;
    this.ignoreErrors = ignoreErrors === true;
    this._inspectFont = inspectFont;
  }
  createNativeFontFace() {
    if (!this.data || this.disableFontFace) {
      return null;
    }
    let nativeFontFace;
    if (!this.cssFontInfo) {
      nativeFontFace = new FontFace(this.loadedName, this.data, {});
    } else {
      const css = {
        weight: this.cssFontInfo.fontWeight
      };
      if (this.cssFontInfo.italicAngle) {
        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
      }
      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
    }
    this._inspectFont?.(this);
    return nativeFontFace;
  }
  createFontFaceRule() {
    if (!this.data || this.disableFontFace) {
      return null;
    }
    const data = (0, _util.bytesToString)(this.data);
    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
    let rule;
    if (!this.cssFontInfo) {
      rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
    } else {
      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
      if (this.cssFontInfo.italicAngle) {
        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
      }
      rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
    }
    this._inspectFont?.(this, url);
    return rule;
  }
  getPathGenerator(objs, character) {
    if (this.compiledGlyphs[character] !== undefined) {
      return this.compiledGlyphs[character];
    }
    let cmds;
    try {
      cmds = objs.get(this.loadedName + "_path_" + character);
    } catch (ex) {
      if (!this.ignoreErrors) {
        throw ex;
      }
      (0, _util.warn)(`getPathGenerator - ignoring character: "${ex}".`);
      return this.compiledGlyphs[character] = function (c, size) {};
    }
    if (this.isEvalSupported && _util.FeatureTest.isEvalSupported) {
      const jsBuf = [];
      for (const current of cmds) {
        const args = current.args !== undefined ? current.args.join(",") : "";
        jsBuf.push("c.", current.cmd, "(", args, ");\n");
      }
      return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
    }
    return this.compiledGlyphs[character] = function (c, size) {
      for (const current of cmds) {
        if (current.cmd === "scale") {
          current.args = [size, -size];
        }
        c[current.cmd].apply(c, current.args);
      }
    };
  }
}
exports.FontFaceObject = FontFaceObject;

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NodeStandardFontDataFactory = exports.NodeFilterFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;
var _base_factory = __w_pdfjs_require__(7);
var _util = __w_pdfjs_require__(1);
;
;
const fetchData = function (url) {
  return new Promise((resolve, reject) => {
    const fs = __webpack_require__(/*! fs */ "?fe90");
    fs.readFile(url, (error, data) => {
      if (error || !data) {
        reject(new Error(error));
        return;
      }
      resolve(new Uint8Array(data));
    });
  });
};
class NodeFilterFactory extends _base_factory.BaseFilterFactory {}
exports.NodeFilterFactory = NodeFilterFactory;
class NodeCanvasFactory extends _base_factory.BaseCanvasFactory {
  _createCanvas(width, height) {
    const Canvas = __webpack_require__(/*! canvas */ "?4a14");
    return Canvas.createCanvas(width, height);
  }
}
exports.NodeCanvasFactory = NodeCanvasFactory;
class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
  _fetchData(url, compressionType) {
    return fetchData(url).then(data => {
      return {
        cMapData: data,
        compressionType
      };
    });
  }
}
exports.NodeCMapReaderFactory = NodeCMapReaderFactory;
class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
  _fetchData(url) {
    return fetchData(url);
  }
}
exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CanvasGraphics = void 0;
var _util = __w_pdfjs_require__(1);
var _display_utils = __w_pdfjs_require__(6);
var _pattern_helper = __w_pdfjs_require__(12);
var _image_utils = __w_pdfjs_require__(13);
const MIN_FONT_SIZE = 16;
const MAX_FONT_SIZE = 100;
const MAX_GROUP_SIZE = 4096;
const EXECUTION_TIME = 15;
const EXECUTION_STEPS = 10;
const MAX_SIZE_TO_COMPILE = 1000;
const FULL_CHUNK_HEIGHT = 16;
function mirrorContextOperations(ctx, destCtx) {
  if (ctx._removeMirroring) {
    throw new Error("Context is already forwarding operations.");
  }
  ctx.__originalSave = ctx.save;
  ctx.__originalRestore = ctx.restore;
  ctx.__originalRotate = ctx.rotate;
  ctx.__originalScale = ctx.scale;
  ctx.__originalTranslate = ctx.translate;
  ctx.__originalTransform = ctx.transform;
  ctx.__originalSetTransform = ctx.setTransform;
  ctx.__originalResetTransform = ctx.resetTransform;
  ctx.__originalClip = ctx.clip;
  ctx.__originalMoveTo = ctx.moveTo;
  ctx.__originalLineTo = ctx.lineTo;
  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
  ctx.__originalRect = ctx.rect;
  ctx.__originalClosePath = ctx.closePath;
  ctx.__originalBeginPath = ctx.beginPath;
  ctx._removeMirroring = () => {
    ctx.save = ctx.__originalSave;
    ctx.restore = ctx.__originalRestore;
    ctx.rotate = ctx.__originalRotate;
    ctx.scale = ctx.__originalScale;
    ctx.translate = ctx.__originalTranslate;
    ctx.transform = ctx.__originalTransform;
    ctx.setTransform = ctx.__originalSetTransform;
    ctx.resetTransform = ctx.__originalResetTransform;
    ctx.clip = ctx.__originalClip;
    ctx.moveTo = ctx.__originalMoveTo;
    ctx.lineTo = ctx.__originalLineTo;
    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
    ctx.rect = ctx.__originalRect;
    ctx.closePath = ctx.__originalClosePath;
    ctx.beginPath = ctx.__originalBeginPath;
    delete ctx._removeMirroring;
  };
  ctx.save = function ctxSave() {
    destCtx.save();
    this.__originalSave();
  };
  ctx.restore = function ctxRestore() {
    destCtx.restore();
    this.__originalRestore();
  };
  ctx.translate = function ctxTranslate(x, y) {
    destCtx.translate(x, y);
    this.__originalTranslate(x, y);
  };
  ctx.scale = function ctxScale(x, y) {
    destCtx.scale(x, y);
    this.__originalScale(x, y);
  };
  ctx.transform = function ctxTransform(a, b, c, d, e, f) {
    destCtx.transform(a, b, c, d, e, f);
    this.__originalTransform(a, b, c, d, e, f);
  };
  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
    destCtx.setTransform(a, b, c, d, e, f);
    this.__originalSetTransform(a, b, c, d, e, f);
  };
  ctx.resetTransform = function ctxResetTransform() {
    destCtx.resetTransform();
    this.__originalResetTransform();
  };
  ctx.rotate = function ctxRotate(angle) {
    destCtx.rotate(angle);
    this.__originalRotate(angle);
  };
  ctx.clip = function ctxRotate(rule) {
    destCtx.clip(rule);
    this.__originalClip(rule);
  };
  ctx.moveTo = function (x, y) {
    destCtx.moveTo(x, y);
    this.__originalMoveTo(x, y);
  };
  ctx.lineTo = function (x, y) {
    destCtx.lineTo(x, y);
    this.__originalLineTo(x, y);
  };
  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  };
  ctx.rect = function (x, y, width, height) {
    destCtx.rect(x, y, width, height);
    this.__originalRect(x, y, width, height);
  };
  ctx.closePath = function () {
    destCtx.closePath();
    this.__originalClosePath();
  };
  ctx.beginPath = function () {
    destCtx.beginPath();
    this.__originalBeginPath();
  };
}
class CachedCanvases {
  constructor(canvasFactory) {
    this.canvasFactory = canvasFactory;
    this.cache = Object.create(null);
  }
  getCanvas(id, width, height) {
    let canvasEntry;
    if (this.cache[id] !== undefined) {
      canvasEntry = this.cache[id];
      this.canvasFactory.reset(canvasEntry, width, height);
    } else {
      canvasEntry = this.canvasFactory.create(width, height);
      this.cache[id] = canvasEntry;
    }
    return canvasEntry;
  }
  delete(id) {
    delete this.cache[id];
  }
  clear() {
    for (const id in this.cache) {
      const canvasEntry = this.cache[id];
      this.canvasFactory.destroy(canvasEntry);
      delete this.cache[id];
    }
  }
}
function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
  const [a, b, c, d, tx, ty] = (0, _display_utils.getCurrentTransform)(ctx);
  if (b === 0 && c === 0) {
    const tlX = destX * a + tx;
    const rTlX = Math.round(tlX);
    const tlY = destY * d + ty;
    const rTlY = Math.round(tlY);
    const brX = (destX + destW) * a + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destY + destH) * d + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
    ctx.setTransform(a, b, c, d, tx, ty);
    return [rWidth, rHeight];
  }
  if (a === 0 && d === 0) {
    const tlX = destY * c + tx;
    const rTlX = Math.round(tlX);
    const tlY = destX * b + ty;
    const rTlY = Math.round(tlY);
    const brX = (destY + destH) * c + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destX + destW) * b + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
    ctx.setTransform(a, b, c, d, tx, ty);
    return [rHeight, rWidth];
  }
  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
  const scaleX = Math.hypot(a, b);
  const scaleY = Math.hypot(c, d);
  return [scaleX * destW, scaleY * destH];
}
function compileType3Glyph(imgData) {
  const {
    width,
    height
  } = imgData;
  if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
    return null;
  }
  const POINT_TO_PROCESS_LIMIT = 1000;
  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
  const width1 = width + 1;
  let points = new Uint8Array(width1 * (height + 1));
  let i, j, j0;
  const lineSize = width + 7 & ~7;
  let data = new Uint8Array(lineSize * height),
    pos = 0;
  for (const elem of imgData.data) {
    let mask = 128;
    while (mask > 0) {
      data[pos++] = elem & mask ? 0 : 255;
      mask >>= 1;
    }
  }
  let count = 0;
  pos = 0;
  if (data[pos] !== 0) {
    points[0] = 1;
    ++count;
  }
  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j] = data[pos] ? 2 : 1;
      ++count;
    }
    pos++;
  }
  if (data[pos] !== 0) {
    points[j] = 2;
    ++count;
  }
  for (i = 1; i < height; i++) {
    pos = i * lineSize;
    j0 = i * width1;
    if (data[pos - lineSize] !== data[pos]) {
      points[j0] = data[pos] ? 1 : 8;
      ++count;
    }
    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
    for (j = 1; j < width; j++) {
      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
      if (POINT_TYPES[sum]) {
        points[j0 + j] = POINT_TYPES[sum];
        ++count;
      }
      pos++;
    }
    if (data[pos - lineSize] !== data[pos]) {
      points[j0 + j] = data[pos] ? 2 : 4;
      ++count;
    }
    if (count > POINT_TO_PROCESS_LIMIT) {
      return null;
    }
  }
  pos = lineSize * (height - 1);
  j0 = i * width1;
  if (data[pos] !== 0) {
    points[j0] = 8;
    ++count;
  }
  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j0 + j] = data[pos] ? 4 : 8;
      ++count;
    }
    pos++;
  }
  if (data[pos] !== 0) {
    points[j0 + j] = 4;
    ++count;
  }
  if (count > POINT_TO_PROCESS_LIMIT) {
    return null;
  }
  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
  const path = new Path2D();
  for (i = 0; count && i <= height; i++) {
    let p = i * width1;
    const end = p + width;
    while (p < end && !points[p]) {
      p++;
    }
    if (p === end) {
      continue;
    }
    path.moveTo(p % width1, i);
    const p0 = p;
    let type = points[p];
    do {
      const step = steps[type];
      do {
        p += step;
      } while (!points[p]);
      const pp = points[p];
      if (pp !== 5 && pp !== 10) {
        type = pp;
        points[p] = 0;
      } else {
        type = pp & 0x33 * type >> 4;
        points[p] &= type >> 2 | type << 2;
      }
      path.lineTo(p % width1, p / width1 | 0);
      if (!points[p]) {
        --count;
      }
    } while (p0 !== p);
    --i;
  }
  data = null;
  points = null;
  const drawOutline = function (c) {
    c.save();
    c.scale(1 / width, -1 / height);
    c.translate(0, -height);
    c.fill(path);
    c.beginPath();
    c.restore();
  };
  return drawOutline;
}
class CanvasExtraState {
  constructor(width, height) {
    this.alphaIsShape = false;
    this.fontSize = 0;
    this.fontSizeScale = 1;
    this.textMatrix = _util.IDENTITY_MATRIX;
    this.textMatrixScale = 1;
    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
    this.leading = 0;
    this.x = 0;
    this.y = 0;
    this.lineX = 0;
    this.lineY = 0;
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.textHScale = 1;
    this.textRenderingMode = _util.TextRenderingMode.FILL;
    this.textRise = 0;
    this.fillColor = "#000000";
    this.strokeColor = "#000000";
    this.patternFill = false;
    this.fillAlpha = 1;
    this.strokeAlpha = 1;
    this.lineWidth = 1;
    this.activeSMask = null;
    this.transferMaps = "none";
    this.startNewPathAndClipBox([0, 0, width, height]);
  }
  clone() {
    const clone = Object.create(this);
    clone.clipBox = this.clipBox.slice();
    return clone;
  }
  setCurrentPoint(x, y) {
    this.x = x;
    this.y = y;
  }
  updatePathMinMax(transform, x, y) {
    [x, y] = _util.Util.applyTransform([x, y], transform);
    this.minX = Math.min(this.minX, x);
    this.minY = Math.min(this.minY, y);
    this.maxX = Math.max(this.maxX, x);
    this.maxY = Math.max(this.maxY, y);
  }
  updateRectMinMax(transform, rect) {
    const p1 = _util.Util.applyTransform(rect, transform);
    const p2 = _util.Util.applyTransform(rect.slice(2), transform);
    this.minX = Math.min(this.minX, p1[0], p2[0]);
    this.minY = Math.min(this.minY, p1[1], p2[1]);
    this.maxX = Math.max(this.maxX, p1[0], p2[0]);
    this.maxY = Math.max(this.maxY, p1[1], p2[1]);
  }
  updateScalingPathMinMax(transform, minMax) {
    _util.Util.scaleMinMax(transform, minMax);
    this.minX = Math.min(this.minX, minMax[0]);
    this.maxX = Math.max(this.maxX, minMax[1]);
    this.minY = Math.min(this.minY, minMax[2]);
    this.maxY = Math.max(this.maxY, minMax[3]);
  }
  updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
    const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);
    if (minMax) {
      minMax[0] = Math.min(minMax[0], box[0], box[2]);
      minMax[1] = Math.max(minMax[1], box[0], box[2]);
      minMax[2] = Math.min(minMax[2], box[1], box[3]);
      minMax[3] = Math.max(minMax[3], box[1], box[3]);
      return;
    }
    this.updateRectMinMax(transform, box);
  }
  getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
    const box = [this.minX, this.minY, this.maxX, this.maxY];
    if (pathType === _pattern_helper.PathType.STROKE) {
      if (!transform) {
        (0, _util.unreachable)("Stroke bounding box must include transform.");
      }
      const scale = _util.Util.singularValueDecompose2dScale(transform);
      const xStrokePad = scale[0] * this.lineWidth / 2;
      const yStrokePad = scale[1] * this.lineWidth / 2;
      box[0] -= xStrokePad;
      box[1] -= yStrokePad;
      box[2] += xStrokePad;
      box[3] += yStrokePad;
    }
    return box;
  }
  updateClipFromPath() {
    const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minX === Infinity;
  }
  startNewPathAndClipBox(box) {
    this.clipBox = box;
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = 0;
    this.maxY = 0;
  }
  getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
    return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
  }
}
function putBinaryImageData(ctx, imgData) {
  if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
    ctx.putImageData(imgData, 0, 0);
    return;
  }
  const height = imgData.height,
    width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0,
    destPos;
  const src = imgData.data;
  const dest = chunkImgData.data;
  let i, j, thisChunkHeight, elemsInThisChunk;
  if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
    const srcLength = src.byteLength;
    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
    const dest32DataLength = dest32.length;
    const fullSrcDiff = width + 7 >> 3;
    const white = 0xffffffff;
    const black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
    for (i = 0; i < totalChunks; i++) {
      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
      destPos = 0;
      for (j = 0; j < thisChunkHeight; j++) {
        const srcDiff = srcLength - srcPos;
        let k = 0;
        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
        const kEndUnrolled = kEnd & ~7;
        let mask = 0;
        let srcByte = 0;
        for (; k < kEndUnrolled; k += 8) {
          srcByte = src[srcPos++];
          dest32[destPos++] = srcByte & 128 ? white : black;
          dest32[destPos++] = srcByte & 64 ? white : black;
          dest32[destPos++] = srcByte & 32 ? white : black;
          dest32[destPos++] = srcByte & 16 ? white : black;
          dest32[destPos++] = srcByte & 8 ? white : black;
          dest32[destPos++] = srcByte & 4 ? white : black;
          dest32[destPos++] = srcByte & 2 ? white : black;
          dest32[destPos++] = srcByte & 1 ? white : black;
        }
        for (; k < kEnd; k++) {
          if (mask === 0) {
            srcByte = src[srcPos++];
            mask = 128;
          }
          dest32[destPos++] = srcByte & mask ? white : black;
          mask >>= 1;
        }
      }
      while (destPos < dest32DataLength) {
        dest32[destPos++] = 0;
      }
      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
    j = 0;
    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
    for (i = 0; i < fullChunks; i++) {
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      srcPos += elemsInThisChunk;
      ctx.putImageData(chunkImgData, 0, j);
      j += FULL_CHUNK_HEIGHT;
    }
    if (i < totalChunks) {
      elemsInThisChunk = width * partialChunkHeight * 4;
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      ctx.putImageData(chunkImgData, 0, j);
    }
  } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
    thisChunkHeight = FULL_CHUNK_HEIGHT;
    elemsInThisChunk = width * thisChunkHeight;
    for (i = 0; i < totalChunks; i++) {
      if (i >= fullChunks) {
        thisChunkHeight = partialChunkHeight;
        elemsInThisChunk = width * thisChunkHeight;
      }
      destPos = 0;
      for (j = elemsInThisChunk; j--;) {
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = 255;
      }
      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else {
    throw new Error(`bad image kind: ${imgData.kind}`);
  }
}
function putBinaryImageMask(ctx, imgData) {
  if (imgData.bitmap) {
    ctx.drawImage(imgData.bitmap, 0, 0);
    return;
  }
  const height = imgData.height,
    width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0;
  const src = imgData.data;
  const dest = chunkImgData.data;
  for (let i = 0; i < totalChunks; i++) {
    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
    ({
      srcPos
    } = (0, _image_utils.convertBlackAndWhiteToRGBA)({
      src,
      srcPos,
      dest,
      width,
      height: thisChunkHeight,
      nonBlackColor: 0
    }));
    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
  }
}
function copyCtxState(sourceCtx, destCtx) {
  const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const property of properties) {
    if (sourceCtx[property] !== undefined) {
      destCtx[property] = sourceCtx[property];
    }
  }
  if (sourceCtx.setLineDash !== undefined) {
    destCtx.setLineDash(sourceCtx.getLineDash());
    destCtx.lineDashOffset = sourceCtx.lineDashOffset;
  }
}
function resetCtxToDefault(ctx) {
  ctx.strokeStyle = ctx.fillStyle = "#000000";
  ctx.fillRule = "nonzero";
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
  ctx.lineCap = "butt";
  ctx.lineJoin = "miter";
  ctx.miterLimit = 10;
  ctx.globalCompositeOperation = "source-over";
  ctx.font = "10px sans-serif";
  if (ctx.setLineDash !== undefined) {
    ctx.setLineDash([]);
    ctx.lineDashOffset = 0;
  }
  if (!_util.isNodeJS) {
    const {
      filter
    } = ctx;
    if (filter !== "none" && filter !== "") {
      ctx.filter = "none";
    }
  }
}
function composeSMaskBackdrop(bytes, r0, g0, b0) {
  const length = bytes.length;
  for (let i = 3; i < length; i += 4) {
    const alpha = bytes[i];
    if (alpha === 0) {
      bytes[i - 3] = r0;
      bytes[i - 2] = g0;
      bytes[i - 1] = b0;
    } else if (alpha < 255) {
      const alpha_ = 255 - alpha;
      bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
      bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
      bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
    }
  }
}
function composeSMaskAlpha(maskData, layerData, transferMap) {
  const length = maskData.length;
  const scale = 1 / 255;
  for (let i = 3; i < length; i += 4) {
    const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
    layerData[i] = layerData[i] * alpha * scale | 0;
  }
}
function composeSMaskLuminosity(maskData, layerData, transferMap) {
  const length = maskData.length;
  for (let i = 3; i < length; i += 4) {
    const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
    layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
  }
}
function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
  const hasBackdrop = !!backdrop;
  const r0 = hasBackdrop ? backdrop[0] : 0;
  const g0 = hasBackdrop ? backdrop[1] : 0;
  const b0 = hasBackdrop ? backdrop[2] : 0;
  const composeFn = subtype === "Luminosity" ? composeSMaskLuminosity : composeSMaskAlpha;
  const PIXELS_TO_PROCESS = 1048576;
  const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
  for (let row = 0; row < height; row += chunkSize) {
    const chunkHeight = Math.min(chunkSize, height - row);
    const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
    const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);
    if (hasBackdrop) {
      composeSMaskBackdrop(maskData.data, r0, g0, b0);
    }
    composeFn(maskData.data, layerData.data, transferMap);
    layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
  }
}
function composeSMask(ctx, smask, layerCtx, layerBox) {
  const layerOffsetX = layerBox[0];
  const layerOffsetY = layerBox[1];
  const layerWidth = layerBox[2] - layerOffsetX;
  const layerHeight = layerBox[3] - layerOffsetY;
  if (layerWidth === 0 || layerHeight === 0) {
    return;
  }
  genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.drawImage(layerCtx.canvas, 0, 0);
  ctx.restore();
}
function getImageSmoothingEnabled(transform, interpolate) {
  const scale = _util.Util.singularValueDecompose2dScale(transform);
  scale[0] = Math.fround(scale[0]);
  scale[1] = Math.fround(scale[1]);
  const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);
  if (interpolate !== undefined) {
    return interpolate;
  } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
    return true;
  }
  return false;
}
const LINE_CAP_STYLES = ["butt", "round", "square"];
const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
const NORMAL_CLIP = {};
const EO_CLIP = {};
class CanvasGraphics {
  constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {
    optionalContentConfig,
    markedContentStack = null
  }, annotationCanvasMap, pageColors) {
    this.ctx = canvasCtx;
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.stateStack = [];
    this.pendingClip = null;
    this.pendingEOFill = false;
    this.res = null;
    this.xobjs = null;
    this.commonObjs = commonObjs;
    this.objs = objs;
    this.canvasFactory = canvasFactory;
    this.filterFactory = filterFactory;
    this.groupStack = [];
    this.processingType3 = null;
    this.baseTransform = null;
    this.baseTransformStack = [];
    this.groupLevel = 0;
    this.smaskStack = [];
    this.smaskCounter = 0;
    this.tempSMask = null;
    this.suspendedCtx = null;
    this.contentVisible = true;
    this.markedContentStack = markedContentStack || [];
    this.optionalContentConfig = optionalContentConfig;
    this.cachedCanvases = new CachedCanvases(this.canvasFactory);
    this.cachedPatterns = new Map();
    this.annotationCanvasMap = annotationCanvasMap;
    this.viewportScale = 1;
    this.outputScaleX = 1;
    this.outputScaleY = 1;
    this.pageColors = pageColors;
    this._cachedScaleForStroking = [-1, 0];
    this._cachedGetSinglePixelWidth = null;
    this._cachedBitmapsMap = new Map();
  }
  getObject(data, fallback = null) {
    if (typeof data === "string") {
      return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
    }
    return fallback;
  }
  beginDrawing({
    transform,
    viewport,
    transparency = false,
    background = null
  }) {
    const width = this.ctx.canvas.width;
    const height = this.ctx.canvas.height;
    const savedFillStyle = this.ctx.fillStyle;
    this.ctx.fillStyle = background || "#ffffff";
    this.ctx.fillRect(0, 0, width, height);
    this.ctx.fillStyle = savedFillStyle;
    if (transparency) {
      const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
      this.compositeCtx = this.ctx;
      this.transparentCanvas = transparentCanvas.canvas;
      this.ctx = transparentCanvas.context;
      this.ctx.save();
      this.ctx.transform(...(0, _display_utils.getCurrentTransform)(this.compositeCtx));
    }
    this.ctx.save();
    resetCtxToDefault(this.ctx);
    if (transform) {
      this.ctx.transform(...transform);
      this.outputScaleX = transform[0];
      this.outputScaleY = transform[0];
    }
    this.ctx.transform(...viewport.transform);
    this.viewportScale = viewport.scale;
    this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);
  }
  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
    const argsArray = operatorList.argsArray;
    const fnArray = operatorList.fnArray;
    let i = executionStartIdx || 0;
    const argsArrayLen = argsArray.length;
    if (argsArrayLen === i) {
      return i;
    }
    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
    let steps = 0;
    const commonObjs = this.commonObjs;
    const objs = this.objs;
    let fnId;
    while (true) {
      if (stepper !== undefined && i === stepper.nextBreakPoint) {
        stepper.breakIt(i, continueCallback);
        return i;
      }
      fnId = fnArray[i];
      if (fnId !== _util.OPS.dependency) {
        this[fnId].apply(this, argsArray[i]);
      } else {
        for (const depObjId of argsArray[i]) {
          const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
          if (!objsPool.has(depObjId)) {
            objsPool.get(depObjId, continueCallback);
            return i;
          }
        }
      }
      i++;
      if (i === argsArrayLen) {
        return i;
      }
      if (chunkOperations && ++steps > EXECUTION_STEPS) {
        if (Date.now() > endTime) {
          continueCallback();
          return i;
        }
        steps = 0;
      }
    }
  }
  #restoreInitialState() {
    while (this.stateStack.length || this.inSMaskMode) {
      this.restore();
    }
    this.ctx.restore();
    if (this.transparentCanvas) {
      this.ctx = this.compositeCtx;
      this.ctx.save();
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.drawImage(this.transparentCanvas, 0, 0);
      this.ctx.restore();
      this.transparentCanvas = null;
    }
  }
  endDrawing() {
    this.#restoreInitialState();
    this.cachedCanvases.clear();
    this.cachedPatterns.clear();
    for (const cache of this._cachedBitmapsMap.values()) {
      for (const canvas of cache.values()) {
        if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
          canvas.width = canvas.height = 0;
        }
      }
      cache.clear();
    }
    this._cachedBitmapsMap.clear();
    this.#drawFilter();
  }
  #drawFilter() {
    if (this.pageColors) {
      const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
      if (hcmFilterId !== "none") {
        const savedFilter = this.ctx.filter;
        this.ctx.filter = hcmFilterId;
        this.ctx.drawImage(this.ctx.canvas, 0, 0);
        this.ctx.filter = savedFilter;
      }
    }
  }
  _scaleImage(img, inverseTransform) {
    const width = img.width;
    const height = img.height;
    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
    let paintWidth = width,
      paintHeight = height;
    let tmpCanvasId = "prescale1";
    let tmpCanvas, tmpCtx;
    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
      let newWidth = paintWidth,
        newHeight = paintHeight;
      if (widthScale > 2 && paintWidth > 1) {
        newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);
        widthScale /= paintWidth / newWidth;
      }
      if (heightScale > 2 && paintHeight > 1) {
        newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;
        heightScale /= paintHeight / newHeight;
      }
      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
      tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, newWidth, newHeight);
      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
      img = tmpCanvas.canvas;
      paintWidth = newWidth;
      paintHeight = newHeight;
      tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
    }
    return {
      img,
      paintWidth,
      paintHeight
    };
  }
  _createMaskCanvas(img) {
    const ctx = this.ctx;
    const {
      width,
      height
    } = img;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);
    let cache, cacheKey, scaled, maskCanvas;
    if ((img.bitmap || img.data) && img.count > 1) {
      const mainKey = img.bitmap || img.data.buffer;
      cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);
      cache = this._cachedBitmapsMap.get(mainKey);
      if (!cache) {
        cache = new Map();
        this._cachedBitmapsMap.set(mainKey, cache);
      }
      const cachedImage = cache.get(cacheKey);
      if (cachedImage && !isPatternFill) {
        const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
        const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
        return {
          canvas: cachedImage,
          offsetX,
          offsetY
        };
      }
      scaled = cachedImage;
    }
    if (!scaled) {
      maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      putBinaryImageMask(maskCanvas.context, img);
    }
    let maskToCanvas = _util.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
    maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
    const cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);
    const cord2 = _util.Util.applyTransform([width, height], maskToCanvas);
    const rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);
    const drawnWidth = Math.round(rect[2] - rect[0]) || 1;
    const drawnHeight = Math.round(rect[3] - rect[1]) || 1;
    const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
    const fillCtx = fillCanvas.context;
    const offsetX = Math.min(cord1[0], cord2[0]);
    const offsetY = Math.min(cord1[1], cord2[1]);
    fillCtx.translate(-offsetX, -offsetY);
    fillCtx.transform(...maskToCanvas);
    if (!scaled) {
      scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils.getCurrentTransformInverse)(fillCtx));
      scaled = scaled.img;
      if (cache && isPatternFill) {
        cache.set(cacheKey, scaled);
      }
    }
    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(fillCtx), img.interpolate);
    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
    fillCtx.globalCompositeOperation = "source-in";
    const inverse = _util.Util.transform((0, _display_utils.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;
    fillCtx.fillRect(0, 0, width, height);
    if (cache && !isPatternFill) {
      this.cachedCanvases.delete("fillCanvas");
      cache.set(cacheKey, fillCanvas.canvas);
    }
    return {
      canvas: fillCanvas.canvas,
      offsetX: Math.round(offsetX),
      offsetY: Math.round(offsetY)
    };
  }
  setLineWidth(width) {
    if (width !== this.current.lineWidth) {
      this._cachedScaleForStroking[0] = -1;
    }
    this.current.lineWidth = width;
    this.ctx.lineWidth = width;
  }
  setLineCap(style) {
    this.ctx.lineCap = LINE_CAP_STYLES[style];
  }
  setLineJoin(style) {
    this.ctx.lineJoin = LINE_JOIN_STYLES[style];
  }
  setMiterLimit(limit) {
    this.ctx.miterLimit = limit;
  }
  setDash(dashArray, dashPhase) {
    const ctx = this.ctx;
    if (ctx.setLineDash !== undefined) {
      ctx.setLineDash(dashArray);
      ctx.lineDashOffset = dashPhase;
    }
  }
  setRenderingIntent(intent) {}
  setFlatness(flatness) {}
  setGState(states) {
    for (const [key, value] of states) {
      switch (key) {
        case "LW":
          this.setLineWidth(value);
          break;
        case "LC":
          this.setLineCap(value);
          break;
        case "LJ":
          this.setLineJoin(value);
          break;
        case "ML":
          this.setMiterLimit(value);
          break;
        case "D":
          this.setDash(value[0], value[1]);
          break;
        case "RI":
          this.setRenderingIntent(value);
          break;
        case "FL":
          this.setFlatness(value);
          break;
        case "Font":
          this.setFont(value[0], value[1]);
          break;
        case "CA":
          this.current.strokeAlpha = value;
          break;
        case "ca":
          this.current.fillAlpha = value;
          this.ctx.globalAlpha = value;
          break;
        case "BM":
          this.ctx.globalCompositeOperation = value;
          break;
        case "SMask":
          this.current.activeSMask = value ? this.tempSMask : null;
          this.tempSMask = null;
          this.checkSMaskState();
          break;
        case "TR":
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);
          break;
      }
    }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const inSMaskMode = this.inSMaskMode;
    if (this.current.activeSMask && !inSMaskMode) {
      this.beginSMaskMode();
    } else if (!this.current.activeSMask && inSMaskMode) {
      this.endSMaskMode();
    }
  }
  beginSMaskMode() {
    if (this.inSMaskMode) {
      throw new Error("beginSMaskMode called while already in smask mode");
    }
    const drawnWidth = this.ctx.canvas.width;
    const drawnHeight = this.ctx.canvas.height;
    const cacheId = "smaskGroupAt" + this.groupLevel;
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    this.suspendedCtx = this.ctx;
    this.ctx = scratchCanvas.context;
    const ctx = this.ctx;
    ctx.setTransform(...(0, _display_utils.getCurrentTransform)(this.suspendedCtx));
    copyCtxState(this.suspendedCtx, ctx);
    mirrorContextOperations(ctx, this.suspendedCtx);
    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode) {
      throw new Error("endSMaskMode called while not in smask mode");
    }
    this.ctx._removeMirroring();
    copyCtxState(this.ctx, this.suspendedCtx);
    this.ctx = this.suspendedCtx;
    this.suspendedCtx = null;
  }
  compose(dirtyBox) {
    if (!this.current.activeSMask) {
      return;
    }
    if (!dirtyBox) {
      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    } else {
      dirtyBox[0] = Math.floor(dirtyBox[0]);
      dirtyBox[1] = Math.floor(dirtyBox[1]);
      dirtyBox[2] = Math.ceil(dirtyBox[2]);
      dirtyBox[3] = Math.ceil(dirtyBox[3]);
    }
    const smask = this.current.activeSMask;
    const suspendedCtx = this.suspendedCtx;
    composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.ctx.restore();
  }
  save() {
    if (this.inSMaskMode) {
      copyCtxState(this.ctx, this.suspendedCtx);
      this.suspendedCtx.save();
    } else {
      this.ctx.save();
    }
    const old = this.current;
    this.stateStack.push(old);
    this.current = old.clone();
  }
  restore() {
    if (this.stateStack.length === 0 && this.inSMaskMode) {
      this.endSMaskMode();
    }
    if (this.stateStack.length !== 0) {
      this.current = this.stateStack.pop();
      if (this.inSMaskMode) {
        this.suspendedCtx.restore();
        copyCtxState(this.suspendedCtx, this.ctx);
      } else {
        this.ctx.restore();
      }
      this.checkSMaskState();
      this.pendingClip = null;
      this._cachedScaleForStroking[0] = -1;
      this._cachedGetSinglePixelWidth = null;
    }
  }
  transform(a, b, c, d, e, f) {
    this.ctx.transform(a, b, c, d, e, f);
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
  }
  constructPath(ops, args, minMax) {
    const ctx = this.ctx;
    const current = this.current;
    let x = current.x,
      y = current.y;
    let startX, startY;
    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);
    const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
    const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
    for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
      switch (ops[i] | 0) {
        case _util.OPS.rectangle:
          x = args[j++];
          y = args[j++];
          const width = args[j++];
          const height = args[j++];
          const xw = x + width;
          const yh = y + height;
          ctx.moveTo(x, y);
          if (width === 0 || height === 0) {
            ctx.lineTo(xw, yh);
          } else {
            ctx.lineTo(xw, y);
            ctx.lineTo(xw, yh);
            ctx.lineTo(x, yh);
          }
          if (!isScalingMatrix) {
            current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
          }
          ctx.closePath();
          break;
        case _util.OPS.moveTo:
          x = args[j++];
          y = args[j++];
          ctx.moveTo(x, y);
          if (!isScalingMatrix) {
            current.updatePathMinMax(currentTransform, x, y);
          }
          break;
        case _util.OPS.lineTo:
          x = args[j++];
          y = args[j++];
          ctx.lineTo(x, y);
          if (!isScalingMatrix) {
            current.updatePathMinMax(currentTransform, x, y);
          }
          break;
        case _util.OPS.curveTo:
          startX = x;
          startY = y;
          x = args[j + 4];
          y = args[j + 5];
          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
          j += 6;
          break;
        case _util.OPS.curveTo2:
          startX = x;
          startY = y;
          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
          current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
          x = args[j + 2];
          y = args[j + 3];
          j += 4;
          break;
        case _util.OPS.curveTo3:
          startX = x;
          startY = y;
          x = args[j + 2];
          y = args[j + 3];
          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
          j += 4;
          break;
        case _util.OPS.closePath:
          ctx.closePath();
          break;
      }
    }
    if (isScalingMatrix) {
      current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
    }
    current.setCurrentPoint(x, y);
  }
  closePath() {
    this.ctx.closePath();
  }
  stroke(consumePath = true) {
    const ctx = this.ctx;
    const strokeColor = this.current.strokeColor;
    ctx.globalAlpha = this.current.strokeAlpha;
    if (this.contentVisible) {
      if (typeof strokeColor === "object" && strokeColor?.getPattern) {
        ctx.save();
        ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);
        this.rescaleAndStroke(false);
        ctx.restore();
      } else {
        this.rescaleAndStroke(true);
      }
    }
    if (consumePath) {
      this.consumePath(this.current.getClippedPathBoundingBox());
    }
    ctx.globalAlpha = this.current.fillAlpha;
  }
  closeStroke() {
    this.closePath();
    this.stroke();
  }
  fill(consumePath = true) {
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    let needRestore = false;
    if (isPatternFill) {
      ctx.save();
      ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
      needRestore = true;
    }
    const intersect = this.current.getClippedPathBoundingBox();
    if (this.contentVisible && intersect !== null) {
      if (this.pendingEOFill) {
        ctx.fill("evenodd");
        this.pendingEOFill = false;
      } else {
        ctx.fill();
      }
    }
    if (needRestore) {
      ctx.restore();
    }
    if (consumePath) {
      this.consumePath(intersect);
    }
  }
  eoFill() {
    this.pendingEOFill = true;
    this.fill();
  }
  fillStroke() {
    this.fill(false);
    this.stroke(false);
    this.consumePath();
  }
  eoFillStroke() {
    this.pendingEOFill = true;
    this.fillStroke();
  }
  closeFillStroke() {
    this.closePath();
    this.fillStroke();
  }
  closeEOFillStroke() {
    this.pendingEOFill = true;
    this.closePath();
    this.fillStroke();
  }
  endPath() {
    this.consumePath();
  }
  clip() {
    this.pendingClip = NORMAL_CLIP;
  }
  eoClip() {
    this.pendingClip = EO_CLIP;
  }
  beginText() {
    this.current.textMatrix = _util.IDENTITY_MATRIX;
    this.current.textMatrixScale = 1;
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
  }
  endText() {
    const paths = this.pendingTextPaths;
    const ctx = this.ctx;
    if (paths === undefined) {
      ctx.beginPath();
      return;
    }
    ctx.save();
    ctx.beginPath();
    for (const path of paths) {
      ctx.setTransform(...path.transform);
      ctx.translate(path.x, path.y);
      path.addToPath(ctx, path.fontSize);
    }
    ctx.restore();
    ctx.clip();
    ctx.beginPath();
    delete this.pendingTextPaths;
  }
  setCharSpacing(spacing) {
    this.current.charSpacing = spacing;
  }
  setWordSpacing(spacing) {
    this.current.wordSpacing = spacing;
  }
  setHScale(scale) {
    this.current.textHScale = scale / 100;
  }
  setLeading(leading) {
    this.current.leading = -leading;
  }
  setFont(fontRefName, size) {
    const fontObj = this.commonObjs.get(fontRefName);
    const current = this.current;
    if (!fontObj) {
      throw new Error(`Can't find font for ${fontRefName}`);
    }
    current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
      (0, _util.warn)("Invalid font matrix for font " + fontRefName);
    }
    if (size < 0) {
      size = -size;
      current.fontDirection = -1;
    } else {
      current.fontDirection = 1;
    }
    this.current.font = fontObj;
    this.current.fontSize = size;
    if (fontObj.isType3Font) {
      return;
    }
    const name = fontObj.loadedName || "sans-serif";
    const typeface = fontObj.systemFontInfo?.css || `"${name}", ${fontObj.fallbackName}`;
    let bold = "normal";
    if (fontObj.black) {
      bold = "900";
    } else if (fontObj.bold) {
      bold = "bold";
    }
    const italic = fontObj.italic ? "italic" : "normal";
    let browserFontSize = size;
    if (size < MIN_FONT_SIZE) {
      browserFontSize = MIN_FONT_SIZE;
    } else if (size > MAX_FONT_SIZE) {
      browserFontSize = MAX_FONT_SIZE;
    }
    this.current.fontSizeScale = size / browserFontSize;
    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
  }
  setTextRenderingMode(mode) {
    this.current.textRenderingMode = mode;
  }
  setTextRise(rise) {
    this.current.textRise = rise;
  }
  moveText(x, y) {
    this.current.x = this.current.lineX += x;
    this.current.y = this.current.lineY += y;
  }
  setLeadingMoveText(x, y) {
    this.setLeading(-y);
    this.moveText(x, y);
  }
  setTextMatrix(a, b, c, d, e, f) {
    this.current.textMatrix = [a, b, c, d, e, f];
    this.current.textMatrixScale = Math.hypot(a, b);
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
  }
  nextLine() {
    this.moveText(0, this.current.leading);
  }
  paintChar(character, x, y, patternTransform) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const textRenderingMode = current.textRenderingMode;
    const fontSize = current.fontSize / current.fontSizeScale;
    const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
    const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
    const patternFill = current.patternFill && !font.missingFile;
    let addToPath;
    if (font.disableFontFace || isAddToPathSet || patternFill) {
      addToPath = font.getPathGenerator(this.commonObjs, character);
    }
    if (font.disableFontFace || patternFill) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      addToPath(ctx, fontSize);
      if (patternTransform) {
        ctx.setTransform(...patternTransform);
      }
      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        ctx.fill();
      }
      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        ctx.stroke();
      }
      ctx.restore();
    } else {
      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        ctx.fillText(character, x, y);
      }
      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        ctx.strokeText(character, x, y);
      }
    }
    if (isAddToPathSet) {
      const paths = this.pendingTextPaths ||= [];
      paths.push({
        transform: (0, _display_utils.getCurrentTransform)(ctx),
        x,
        y,
        fontSize,
        addToPath
      });
    }
  }
  get isFontSubpixelAAEnabled() {
    const {
      context: ctx
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    ctx.scale(1.5, 1);
    ctx.fillText("I", 0, 10);
    const data = ctx.getImageData(0, 0, 10, 10).data;
    let enabled = false;
    for (let i = 3; i < data.length; i += 4) {
      if (data[i] > 0 && data[i] < 255) {
        enabled = true;
        break;
      }
    }
    return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);
  }
  showText(glyphs) {
    const current = this.current;
    const font = current.font;
    if (font.isType3Font) {
      return this.showType3Text(glyphs);
    }
    const fontSize = current.fontSize;
    if (fontSize === 0) {
      return undefined;
    }
    const ctx = this.ctx;
    const fontSizeScale = current.fontSizeScale;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const fontDirection = current.fontDirection;
    const textHScale = current.textHScale * fontDirection;
    const glyphsLength = glyphs.length;
    const vertical = font.vertical;
    const spacingDir = vertical ? 1 : -1;
    const defaultVMetrics = font.defaultVMetrics;
    const widthAdvanceScale = fontSize * current.fontMatrix[0];
    const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
    ctx.save();
    ctx.transform(...current.textMatrix);
    ctx.translate(current.x, current.y + current.textRise);
    if (fontDirection > 0) {
      ctx.scale(textHScale, -1);
    } else {
      ctx.scale(textHScale, 1);
    }
    let patternTransform;
    if (current.patternFill) {
      ctx.save();
      const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
      patternTransform = (0, _display_utils.getCurrentTransform)(ctx);
      ctx.restore();
      ctx.fillStyle = pattern;
    }
    let lineWidth = current.lineWidth;
    const scale = current.textMatrixScale;
    if (scale === 0 || lineWidth === 0) {
      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        lineWidth = this.getSinglePixelWidth();
      }
    } else {
      lineWidth /= scale;
    }
    if (fontSizeScale !== 1.0) {
      ctx.scale(fontSizeScale, fontSizeScale);
      lineWidth /= fontSizeScale;
    }
    ctx.lineWidth = lineWidth;
    if (font.isInvalidPDFjsFont) {
      const chars = [];
      let width = 0;
      for (const glyph of glyphs) {
        chars.push(glyph.unicode);
        width += glyph.width;
      }
      ctx.fillText(chars.join(""), 0, 0);
      current.x += width * widthAdvanceScale * textHScale;
      ctx.restore();
      this.compose();
      return undefined;
    }
    let x = 0,
      i;
    for (i = 0; i < glyphsLength; ++i) {
      const glyph = glyphs[i];
      if (typeof glyph === "number") {
        x += spacingDir * glyph * fontSize / 1000;
        continue;
      }
      let restoreNeeded = false;
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const character = glyph.fontChar;
      const accent = glyph.accent;
      let scaledX, scaledY;
      let width = glyph.width;
      if (vertical) {
        const vmetric = glyph.vmetric || defaultVMetrics;
        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
        const vy = vmetric[2] * widthAdvanceScale;
        width = vmetric ? -vmetric[0] : width;
        scaledX = vx / fontSizeScale;
        scaledY = (x + vy) / fontSizeScale;
      } else {
        scaledX = x / fontSizeScale;
        scaledY = 0;
      }
      if (font.remeasure && width > 0) {
        const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;
        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
          const characterScaleX = width / measuredWidth;
          restoreNeeded = true;
          ctx.save();
          ctx.scale(characterScaleX, 1);
          scaledX /= characterScaleX;
        } else if (width !== measuredWidth) {
          scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
        }
      }
      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
        if (simpleFillText && !accent) {
          ctx.fillText(character, scaledX, scaledY);
        } else {
          this.paintChar(character, scaledX, scaledY, patternTransform);
          if (accent) {
            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
          }
        }
      }
      const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
      x += charWidth;
      if (restoreNeeded) {
        ctx.restore();
      }
    }
    if (vertical) {
      current.y -= x;
    } else {
      current.x += x * textHScale;
    }
    ctx.restore();
    this.compose();
    return undefined;
  }
  showType3Text(glyphs) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const fontSize = current.fontSize;
    const fontDirection = current.fontDirection;
    const spacingDir = font.vertical ? 1 : -1;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const textHScale = current.textHScale * fontDirection;
    const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
    const glyphsLength = glyphs.length;
    const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
    let i, glyph, width, spacingLength;
    if (isTextInvisible || fontSize === 0) {
      return;
    }
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
    ctx.save();
    ctx.transform(...current.textMatrix);
    ctx.translate(current.x, current.y);
    ctx.scale(textHScale, fontDirection);
    for (i = 0; i < glyphsLength; ++i) {
      glyph = glyphs[i];
      if (typeof glyph === "number") {
        spacingLength = spacingDir * glyph * fontSize / 1000;
        this.ctx.translate(spacingLength, 0);
        current.x += spacingLength * textHScale;
        continue;
      }
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const operatorList = font.charProcOperatorList[glyph.operatorListId];
      if (!operatorList) {
        (0, _util.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
        continue;
      }
      if (this.contentVisible) {
        this.processingType3 = glyph;
        this.save();
        ctx.scale(fontSize, fontSize);
        ctx.transform(...fontMatrix);
        this.executeOperatorList(operatorList);
        this.restore();
      }
      const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);
      width = transformed[0] * fontSize + spacing;
      ctx.translate(width, 0);
      current.x += width * textHScale;
    }
    ctx.restore();
    this.processingType3 = null;
  }
  setCharWidth(xWidth, yWidth) {}
  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
    this.ctx.rect(llx, lly, urx - llx, ury - lly);
    this.ctx.clip();
    this.endPath();
  }
  getColorN_Pattern(IR) {
    let pattern;
    if (IR[0] === "TilingPattern") {
      const color = IR[1];
      const baseTransform = this.baseTransform || (0, _display_utils.getCurrentTransform)(this.ctx);
      const canvasGraphicsFactory = {
        createCanvasGraphics: ctx => {
          return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
            optionalContentConfig: this.optionalContentConfig,
            markedContentStack: this.markedContentStack
          });
        }
      };
      pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
    } else {
      pattern = this._getPattern(IR[1], IR[2]);
    }
    return pattern;
  }
  setStrokeColorN() {
    this.current.strokeColor = this.getColorN_Pattern(arguments);
  }
  setFillColorN() {
    this.current.fillColor = this.getColorN_Pattern(arguments);
    this.current.patternFill = true;
  }
  setStrokeRGBColor(r, g, b) {
    const color = _util.Util.makeHexColor(r, g, b);
    this.ctx.strokeStyle = color;
    this.current.strokeColor = color;
  }
  setFillRGBColor(r, g, b) {
    const color = _util.Util.makeHexColor(r, g, b);
    this.ctx.fillStyle = color;
    this.current.fillColor = color;
    this.current.patternFill = false;
  }
  _getPattern(objId, matrix = null) {
    let pattern;
    if (this.cachedPatterns.has(objId)) {
      pattern = this.cachedPatterns.get(objId);
    } else {
      pattern = (0, _pattern_helper.getShadingPattern)(this.getObject(objId));
      this.cachedPatterns.set(objId, pattern);
    }
    if (matrix) {
      pattern.matrix = matrix;
    }
    return pattern;
  }
  shadingFill(objId) {
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    this.save();
    const pattern = this._getPattern(objId);
    ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);
    const inv = (0, _display_utils.getCurrentTransformInverse)(ctx);
    if (inv) {
      const {
        width,
        height
      } = ctx.canvas;
      const [x0, y0, x1, y1] = _util.Util.getAxialAlignedBoundingBox([0, 0, width, height], inv);
      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
    } else {
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    }
    this.compose(this.current.getClippedPathBoundingBox());
    this.restore();
  }
  beginInlineImage() {
    (0, _util.unreachable)("Should not call beginInlineImage");
  }
  beginImageData() {
    (0, _util.unreachable)("Should not call beginImageData");
  }
  paintFormXObjectBegin(matrix, bbox) {
    if (!this.contentVisible) {
      return;
    }
    this.save();
    this.baseTransformStack.push(this.baseTransform);
    if (Array.isArray(matrix) && matrix.length === 6) {
      this.transform(...matrix);
    }
    this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);
    if (bbox) {
      const width = bbox[2] - bbox[0];
      const height = bbox[3] - bbox[1];
      this.ctx.rect(bbox[0], bbox[1], width, height);
      this.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(this.ctx), bbox);
      this.clip();
      this.endPath();
    }
  }
  paintFormXObjectEnd() {
    if (!this.contentVisible) {
      return;
    }
    this.restore();
    this.baseTransform = this.baseTransformStack.pop();
  }
  beginGroup(group) {
    if (!this.contentVisible) {
      return;
    }
    this.save();
    if (this.inSMaskMode) {
      this.endSMaskMode();
      this.current.activeSMask = null;
    }
    const currentCtx = this.ctx;
    if (!group.isolated) {
      (0, _util.info)("TODO: Support non-isolated groups.");
    }
    if (group.knockout) {
      (0, _util.warn)("Knockout groups not supported.");
    }
    const currentTransform = (0, _display_utils.getCurrentTransform)(currentCtx);
    if (group.matrix) {
      currentCtx.transform(...group.matrix);
    }
    if (!group.bbox) {
      throw new Error("Bounding box is required.");
    }
    let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils.getCurrentTransform)(currentCtx));
    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
    bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
    const offsetX = Math.floor(bounds[0]);
    const offsetY = Math.floor(bounds[1]);
    let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
    let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
    let scaleX = 1,
      scaleY = 1;
    if (drawnWidth > MAX_GROUP_SIZE) {
      scaleX = drawnWidth / MAX_GROUP_SIZE;
      drawnWidth = MAX_GROUP_SIZE;
    }
    if (drawnHeight > MAX_GROUP_SIZE) {
      scaleY = drawnHeight / MAX_GROUP_SIZE;
      drawnHeight = MAX_GROUP_SIZE;
    }
    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
    let cacheId = "groupAt" + this.groupLevel;
    if (group.smask) {
      cacheId += "_smask_" + this.smaskCounter++ % 2;
    }
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    const groupCtx = scratchCanvas.context;
    groupCtx.scale(1 / scaleX, 1 / scaleY);
    groupCtx.translate(-offsetX, -offsetY);
    groupCtx.transform(...currentTransform);
    if (group.smask) {
      this.smaskStack.push({
        canvas: scratchCanvas.canvas,
        context: groupCtx,
        offsetX,
        offsetY,
        scaleX,
        scaleY,
        subtype: group.smask.subtype,
        backdrop: group.smask.backdrop,
        transferMap: group.smask.transferMap || null,
        startTransformInverse: null
      });
    } else {
      currentCtx.setTransform(1, 0, 0, 1, 0, 0);
      currentCtx.translate(offsetX, offsetY);
      currentCtx.scale(scaleX, scaleY);
      currentCtx.save();
    }
    copyCtxState(currentCtx, groupCtx);
    this.ctx = groupCtx;
    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
    this.groupStack.push(currentCtx);
    this.groupLevel++;
  }
  endGroup(group) {
    if (!this.contentVisible) {
      return;
    }
    this.groupLevel--;
    const groupCtx = this.ctx;
    const ctx = this.groupStack.pop();
    this.ctx = ctx;
    this.ctx.imageSmoothingEnabled = false;
    if (group.smask) {
      this.tempSMask = this.smaskStack.pop();
      this.restore();
    } else {
      this.ctx.restore();
      const currentMtx = (0, _display_utils.getCurrentTransform)(this.ctx);
      this.restore();
      this.ctx.save();
      this.ctx.setTransform(...currentMtx);
      const dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);
      this.ctx.drawImage(groupCtx.canvas, 0, 0);
      this.ctx.restore();
      this.compose(dirtyBox);
    }
  }
  beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
    this.#restoreInitialState();
    resetCtxToDefault(this.ctx);
    this.ctx.save();
    this.save();
    if (this.baseTransform) {
      this.ctx.setTransform(...this.baseTransform);
    }
    if (Array.isArray(rect) && rect.length === 4) {
      const width = rect[2] - rect[0];
      const height = rect[3] - rect[1];
      if (hasOwnCanvas && this.annotationCanvasMap) {
        transform = transform.slice();
        transform[4] -= rect[0];
        transform[5] -= rect[1];
        rect = rect.slice();
        rect[0] = rect[1] = 0;
        rect[2] = width;
        rect[3] = height;
        const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(this.ctx));
        const {
          viewportScale
        } = this;
        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
        const {
          canvas,
          context
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(id, canvas);
        this.annotationCanvas.savedCtx = this.ctx;
        this.ctx = context;
        this.ctx.save();
        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
        resetCtxToDefault(this.ctx);
      } else {
        resetCtxToDefault(this.ctx);
        this.ctx.rect(rect[0], rect[1], width, height);
        this.ctx.clip();
        this.endPath();
      }
    }
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.transform(...transform);
    this.transform(...matrix);
  }
  endAnnotation() {
    if (this.annotationCanvas) {
      this.ctx.restore();
      this.#drawFilter();
      this.ctx = this.annotationCanvas.savedCtx;
      delete this.annotationCanvas.savedCtx;
      delete this.annotationCanvas;
    }
  }
  paintImageMaskXObject(img) {
    if (!this.contentVisible) {
      return;
    }
    const count = img.count;
    img = this.getObject(img.data, img);
    img.count = count;
    const ctx = this.ctx;
    const glyph = this.processingType3;
    if (glyph) {
      if (glyph.compiled === undefined) {
        glyph.compiled = compileType3Glyph(img);
      }
      if (glyph.compiled) {
        glyph.compiled(ctx);
        return;
      }
    }
    const mask = this._createMaskCanvas(img);
    const maskCanvas = mask.canvas;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
    ctx.restore();
    this.compose();
  }
  paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }
    img = this.getObject(img.data, img);
    const ctx = this.ctx;
    ctx.save();
    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);
    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
    const mask = this._createMaskCanvas(img);
    ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);
    for (let i = 0, ii = positions.length; i < ii; i += 2) {
      const trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
      const [x, y] = _util.Util.applyTransform([0, 0], trans);
      ctx.drawImage(mask.canvas, x, y);
    }
    ctx.restore();
    this.compose();
  }
  paintImageMaskXObjectGroup(images) {
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    for (const image of images) {
      const {
        data,
        width,
        height,
        transform
      } = image;
      const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      const maskCtx = maskCanvas.context;
      maskCtx.save();
      const img = this.getObject(data, image);
      putBinaryImageMask(maskCtx, img);
      maskCtx.globalCompositeOperation = "source-in";
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      ctx.save();
      ctx.transform(...transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
      ctx.restore();
    }
    this.compose();
  }
  paintImageXObject(objId) {
    if (!this.contentVisible) {
      return;
    }
    const imgData = this.getObject(objId);
    if (!imgData) {
      (0, _util.warn)("Dependent image isn't ready yet");
      return;
    }
    this.paintInlineImageXObject(imgData);
  }
  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }
    const imgData = this.getObject(objId);
    if (!imgData) {
      (0, _util.warn)("Dependent image isn't ready yet");
      return;
    }
    const width = imgData.width;
    const height = imgData.height;
    const map = [];
    for (let i = 0, ii = positions.length; i < ii; i += 2) {
      map.push({
        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
        x: 0,
        y: 0,
        w: width,
        h: height
      });
    }
    this.paintInlineImageXObjectGroup(imgData, map);
  }
  applyTransferMapsToCanvas(ctx) {
    if (this.current.transferMaps !== "none") {
      ctx.filter = this.current.transferMaps;
      ctx.drawImage(ctx.canvas, 0, 0);
      ctx.filter = "none";
    }
    return ctx.canvas;
  }
  applyTransferMapsToBitmap(imgData) {
    if (this.current.transferMaps === "none") {
      return imgData.bitmap;
    }
    const {
      bitmap,
      width,
      height
    } = imgData;
    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
    const tmpCtx = tmpCanvas.context;
    tmpCtx.filter = this.current.transferMaps;
    tmpCtx.drawImage(bitmap, 0, 0);
    tmpCtx.filter = "none";
    return tmpCanvas.canvas;
  }
  paintInlineImageXObject(imgData) {
    if (!this.contentVisible) {
      return;
    }
    const width = imgData.width;
    const height = imgData.height;
    const ctx = this.ctx;
    this.save();
    if (!_util.isNodeJS) {
      const {
        filter
      } = ctx;
      if (filter !== "none" && filter !== "") {
        ctx.filter = "none";
      }
    }
    ctx.scale(1 / width, -1 / height);
    let imgToPaint;
    if (imgData.bitmap) {
      imgToPaint = this.applyTransferMapsToBitmap(imgData);
    } else if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
      imgToPaint = imgData;
    } else {
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData);
      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
    }
    const scaled = this._scaleImage(imgToPaint, (0, _display_utils.getCurrentTransformInverse)(ctx));
    ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(ctx), imgData.interpolate);
    drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
    this.compose();
    this.restore();
  }
  paintInlineImageXObjectGroup(imgData, map) {
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    let imgToPaint;
    if (imgData.bitmap) {
      imgToPaint = imgData.bitmap;
    } else {
      const w = imgData.width;
      const h = imgData.height;
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData);
      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
    }
    for (const entry of map) {
      ctx.save();
      ctx.transform(...entry.transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
      ctx.restore();
    }
    this.compose();
  }
  paintSolidColorImageMask() {
    if (!this.contentVisible) {
      return;
    }
    this.ctx.fillRect(0, 0, 1, 1);
    this.compose();
  }
  markPoint(tag) {}
  markPointProps(tag, properties) {}
  beginMarkedContent(tag) {
    this.markedContentStack.push({
      visible: true
    });
  }
  beginMarkedContentProps(tag, properties) {
    if (tag === "OC") {
      this.markedContentStack.push({
        visible: this.optionalContentConfig.isVisible(properties)
      });
    } else {
      this.markedContentStack.push({
        visible: true
      });
    }
    this.contentVisible = this.isContentVisible();
  }
  endMarkedContent() {
    this.markedContentStack.pop();
    this.contentVisible = this.isContentVisible();
  }
  beginCompat() {}
  endCompat() {}
  consumePath(clipBox) {
    const isEmpty = this.current.isEmptyClip();
    if (this.pendingClip) {
      this.current.updateClipFromPath();
    }
    if (!this.pendingClip) {
      this.compose(clipBox);
    }
    const ctx = this.ctx;
    if (this.pendingClip) {
      if (!isEmpty) {
        if (this.pendingClip === EO_CLIP) {
          ctx.clip("evenodd");
        } else {
          ctx.clip();
        }
      }
      this.pendingClip = null;
    }
    this.current.startNewPathAndClipBox(this.current.clipBox);
    ctx.beginPath();
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const m = (0, _display_utils.getCurrentTransform)(this.ctx);
      if (m[1] === 0 && m[2] === 0) {
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
      } else {
        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
        const normX = Math.hypot(m[0], m[2]);
        const normY = Math.hypot(m[1], m[3]);
        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (this._cachedScaleForStroking[0] === -1) {
      const {
        lineWidth
      } = this.current;
      const {
        a,
        b,
        c,
        d
      } = this.ctx.getTransform();
      let scaleX, scaleY;
      if (b === 0 && c === 0) {
        const normX = Math.abs(a);
        const normY = Math.abs(d);
        if (normX === normY) {
          if (lineWidth === 0) {
            scaleX = scaleY = 1 / normX;
          } else {
            const scaledLineWidth = normX * lineWidth;
            scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
          }
        } else if (lineWidth === 0) {
          scaleX = 1 / normX;
          scaleY = 1 / normY;
        } else {
          const scaledXLineWidth = normX * lineWidth;
          const scaledYLineWidth = normY * lineWidth;
          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
        }
      } else {
        const absDet = Math.abs(a * d - b * c);
        const normX = Math.hypot(a, b);
        const normY = Math.hypot(c, d);
        if (lineWidth === 0) {
          scaleX = normY / absDet;
          scaleY = normX / absDet;
        } else {
          const baseArea = lineWidth * absDet;
          scaleX = normY > baseArea ? normY / baseArea : 1;
          scaleY = normX > baseArea ? normX / baseArea : 1;
        }
      }
      this._cachedScaleForStroking[0] = scaleX;
      this._cachedScaleForStroking[1] = scaleY;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(saveRestore) {
    const {
      ctx
    } = this;
    const {
      lineWidth
    } = this.current;
    const [scaleX, scaleY] = this.getScaleForStroking();
    ctx.lineWidth = lineWidth || 1;
    if (scaleX === 1 && scaleY === 1) {
      ctx.stroke();
      return;
    }
    const dashes = ctx.getLineDash();
    if (saveRestore) {
      ctx.save();
    }
    ctx.scale(scaleX, scaleY);
    if (dashes.length > 0) {
      const scale = Math.max(scaleX, scaleY);
      ctx.setLineDash(dashes.map(x => x / scale));
      ctx.lineDashOffset /= scale;
    }
    ctx.stroke();
    if (saveRestore) {
      ctx.restore();
    }
  }
  isContentVisible() {
    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
      if (!this.markedContentStack[i].visible) {
        return false;
      }
    }
    return true;
  }
}
exports.CanvasGraphics = CanvasGraphics;
for (const op in _util.OPS) {
  if (CanvasGraphics.prototype[op] !== undefined) {
    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
  }
}

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TilingPattern = exports.PathType = void 0;
exports.getShadingPattern = getShadingPattern;
var _util = __w_pdfjs_require__(1);
var _display_utils = __w_pdfjs_require__(6);
const PathType = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
exports.PathType = PathType;
function applyBoundingBox(ctx, bbox) {
  if (!bbox) {
    return;
  }
  const width = bbox[2] - bbox[0];
  const height = bbox[3] - bbox[1];
  const region = new Path2D();
  region.rect(bbox[0], bbox[1], width, height);
  ctx.clip(region);
}
class BaseShadingPattern {
  constructor() {
    if (this.constructor === BaseShadingPattern) {
      (0, _util.unreachable)("Cannot initialize BaseShadingPattern.");
    }
  }
  getPattern() {
    (0, _util.unreachable)("Abstract method `getPattern` called.");
  }
}
class RadialAxialShadingPattern extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._type = IR[1];
    this._bbox = IR[2];
    this._colorStops = IR[3];
    this._p0 = IR[4];
    this._p1 = IR[5];
    this._r0 = IR[6];
    this._r1 = IR[7];
    this.matrix = null;
  }
  _createGradient(ctx) {
    let grad;
    if (this._type === "axial") {
      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
    } else if (this._type === "radial") {
      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
    }
    for (const colorStop of this._colorStops) {
      grad.addColorStop(colorStop[0], colorStop[1]);
    }
    return grad;
  }
  getPattern(ctx, owner, inverse, pathType) {
    let pattern;
    if (pathType === PathType.STROKE || pathType === PathType.FILL) {
      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils.getCurrentTransform)(ctx)) || [0, 0, 0, 0];
      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
      const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
      const tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.beginPath();
      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
      inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
      tmpCtx.transform(...owner.baseTransform);
      if (this.matrix) {
        tmpCtx.transform(...this.matrix);
      }
      applyBoundingBox(tmpCtx, this._bbox);
      tmpCtx.fillStyle = this._createGradient(tmpCtx);
      tmpCtx.fill();
      pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
      const domMatrix = new DOMMatrix(inverse);
      pattern.setTransform(domMatrix);
    } else {
      applyBoundingBox(ctx, this._bbox);
      pattern = this._createGradient(ctx);
    }
    return pattern;
  }
}
function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
  const coords = context.coords,
    colors = context.colors;
  const bytes = data.data,
    rowSize = data.width * 4;
  let tmp;
  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }
  if (coords[p2 + 1] > coords[p3 + 1]) {
    tmp = p2;
    p2 = p3;
    p3 = tmp;
    tmp = c2;
    c2 = c3;
    c3 = tmp;
  }
  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }
  const x1 = (coords[p1] + context.offsetX) * context.scaleX;
  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
  const x2 = (coords[p2] + context.offsetX) * context.scaleX;
  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
  const x3 = (coords[p3] + context.offsetX) * context.scaleX;
  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
  if (y1 >= y3) {
    return;
  }
  const c1r = colors[c1],
    c1g = colors[c1 + 1],
    c1b = colors[c1 + 2];
  const c2r = colors[c2],
    c2g = colors[c2 + 1],
    c2b = colors[c2 + 2];
  const c3r = colors[c3],
    c3g = colors[c3 + 1],
    c3b = colors[c3 + 2];
  const minY = Math.round(y1),
    maxY = Math.round(y3);
  let xa, car, cag, cab;
  let xb, cbr, cbg, cbb;
  for (let y = minY; y <= maxY; y++) {
    if (y < y2) {
      const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);
      xa = x1 - (x1 - x2) * k;
      car = c1r - (c1r - c2r) * k;
      cag = c1g - (c1g - c2g) * k;
      cab = c1b - (c1b - c2b) * k;
    } else {
      let k;
      if (y > y3) {
        k = 1;
      } else if (y2 === y3) {
        k = 0;
      } else {
        k = (y2 - y) / (y2 - y3);
      }
      xa = x2 - (x2 - x3) * k;
      car = c2r - (c2r - c3r) * k;
      cag = c2g - (c2g - c3g) * k;
      cab = c2b - (c2b - c3b) * k;
    }
    let k;
    if (y < y1) {
      k = 0;
    } else if (y > y3) {
      k = 1;
    } else {
      k = (y1 - y) / (y1 - y3);
    }
    xb = x1 - (x1 - x3) * k;
    cbr = c1r - (c1r - c3r) * k;
    cbg = c1g - (c1g - c3g) * k;
    cbb = c1b - (c1b - c3b) * k;
    const x1_ = Math.round(Math.min(xa, xb));
    const x2_ = Math.round(Math.max(xa, xb));
    let j = rowSize * y + x1_ * 4;
    for (let x = x1_; x <= x2_; x++) {
      k = (xa - x) / (xa - xb);
      if (k < 0) {
        k = 0;
      } else if (k > 1) {
        k = 1;
      }
      bytes[j++] = car - (car - cbr) * k | 0;
      bytes[j++] = cag - (cag - cbg) * k | 0;
      bytes[j++] = cab - (cab - cbb) * k | 0;
      bytes[j++] = 255;
    }
  }
}
function drawFigure(data, figure, context) {
  const ps = figure.coords;
  const cs = figure.colors;
  let i, ii;
  switch (figure.type) {
    case "lattice":
      const verticesPerRow = figure.verticesPerRow;
      const rows = Math.floor(ps.length / verticesPerRow) - 1;
      const cols = verticesPerRow - 1;
      for (i = 0; i < rows; i++) {
        let q = i * verticesPerRow;
        for (let j = 0; j < cols; j++, q++) {
          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
        }
      }
      break;
    case "triangles":
      for (i = 0, ii = ps.length; i < ii; i += 3) {
        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
      }
      break;
    default:
      throw new Error("illegal figure");
  }
}
class MeshShadingPattern extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._coords = IR[2];
    this._colors = IR[3];
    this._figures = IR[4];
    this._bounds = IR[5];
    this._bbox = IR[7];
    this._background = IR[8];
    this.matrix = null;
  }
  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
    const EXPECTED_SCALE = 1.1;
    const MAX_PATTERN_SIZE = 3000;
    const BORDER_SIZE = 2;
    const offsetX = Math.floor(this._bounds[0]);
    const offsetY = Math.floor(this._bounds[1]);
    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const scaleX = boundsWidth / width;
    const scaleY = boundsHeight / height;
    const context = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -offsetX,
      offsetY: -offsetY,
      scaleX: 1 / scaleX,
      scaleY: 1 / scaleY
    };
    const paddedWidth = width + BORDER_SIZE * 2;
    const paddedHeight = height + BORDER_SIZE * 2;
    const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
    const tmpCtx = tmpCanvas.context;
    const data = tmpCtx.createImageData(width, height);
    if (backgroundColor) {
      const bytes = data.data;
      for (let i = 0, ii = bytes.length; i < ii; i += 4) {
        bytes[i] = backgroundColor[0];
        bytes[i + 1] = backgroundColor[1];
        bytes[i + 2] = backgroundColor[2];
        bytes[i + 3] = 255;
      }
    }
    for (const figure of this._figures) {
      drawFigure(data, figure, context);
    }
    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
    const canvas = tmpCanvas.canvas;
    return {
      canvas,
      offsetX: offsetX - BORDER_SIZE * scaleX,
      offsetY: offsetY - BORDER_SIZE * scaleY,
      scaleX,
      scaleY
    };
  }
  getPattern(ctx, owner, inverse, pathType) {
    applyBoundingBox(ctx, this._bbox);
    let scale;
    if (pathType === PathType.SHADING) {
      scale = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(ctx));
    } else {
      scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);
      if (this.matrix) {
        const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);
        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
      }
    }
    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
    if (pathType !== PathType.SHADING) {
      ctx.setTransform(...owner.baseTransform);
      if (this.matrix) {
        ctx.transform(...this.matrix);
      }
    }
    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
  }
}
class DummyShadingPattern extends BaseShadingPattern {
  getPattern() {
    return "hotpink";
  }
}
function getShadingPattern(IR) {
  switch (IR[0]) {
    case "RadialAxial":
      return new RadialAxialShadingPattern(IR);
    case "Mesh":
      return new MeshShadingPattern(IR);
    case "Dummy":
      return new DummyShadingPattern();
  }
  throw new Error(`Unknown IR type: ${IR[0]}`);
}
const PaintType = {
  COLORED: 1,
  UNCOLORED: 2
};
class TilingPattern {
  static MAX_PATTERN_SIZE = 3000;
  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
    this.operatorList = IR[2];
    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
    this.bbox = IR[4];
    this.xstep = IR[5];
    this.ystep = IR[6];
    this.paintType = IR[7];
    this.tilingType = IR[8];
    this.color = color;
    this.ctx = ctx;
    this.canvasGraphicsFactory = canvasGraphicsFactory;
    this.baseTransform = baseTransform;
  }
  createPatternCanvas(owner) {
    const operatorList = this.operatorList;
    const bbox = this.bbox;
    const xstep = this.xstep;
    const ystep = this.ystep;
    const paintType = this.paintType;
    const tilingType = this.tilingType;
    const color = this.color;
    const canvasGraphicsFactory = this.canvasGraphicsFactory;
    (0, _util.info)("TilingType: " + tilingType);
    const x0 = bbox[0],
      y0 = bbox[1],
      x1 = bbox[2],
      y1 = bbox[3];
    const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);
    const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);
    const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
    const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
    const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
    const tmpCtx = tmpCanvas.context;
    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
    graphics.groupLevel = owner.groupLevel;
    this.setFillAndStrokeStyleToContext(graphics, paintType, color);
    let adjustedX0 = x0;
    let adjustedY0 = y0;
    let adjustedX1 = x1;
    let adjustedY1 = y1;
    if (x0 < 0) {
      adjustedX0 = 0;
      adjustedX1 += Math.abs(x0);
    }
    if (y0 < 0) {
      adjustedY0 = 0;
      adjustedY1 += Math.abs(y0);
    }
    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
    tmpCtx.save();
    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
    graphics.baseTransform = (0, _display_utils.getCurrentTransform)(graphics.ctx);
    graphics.executeOperatorList(operatorList);
    graphics.endDrawing();
    return {
      canvas: tmpCanvas.canvas,
      scaleX: dimx.scale,
      scaleY: dimy.scale,
      offsetX: adjustedX0,
      offsetY: adjustedY0
    };
  }
  getSizeAndScale(step, realOutputSize, scale) {
    step = Math.abs(step);
    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
    let size = Math.ceil(step * scale);
    if (size >= maxSize) {
      size = maxSize;
    } else {
      scale = size / step;
    }
    return {
      scale,
      size
    };
  }
  clipBbox(graphics, x0, y0, x1, y1) {
    const bboxWidth = x1 - x0;
    const bboxHeight = y1 - y0;
    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
    graphics.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);
    graphics.clip();
    graphics.endPath();
  }
  setFillAndStrokeStyleToContext(graphics, paintType, color) {
    const context = graphics.ctx,
      current = graphics.current;
    switch (paintType) {
      case PaintType.COLORED:
        const ctx = this.ctx;
        context.fillStyle = ctx.fillStyle;
        context.strokeStyle = ctx.strokeStyle;
        current.fillColor = ctx.fillStyle;
        current.strokeColor = ctx.strokeStyle;
        break;
      case PaintType.UNCOLORED:
        const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);
        context.fillStyle = cssColor;
        context.strokeStyle = cssColor;
        current.fillColor = cssColor;
        current.strokeColor = cssColor;
        break;
      default:
        throw new _util.FormatError(`Unsupported paint type: ${paintType}`);
    }
  }
  getPattern(ctx, owner, inverse, pathType) {
    let matrix = inverse;
    if (pathType !== PathType.SHADING) {
      matrix = _util.Util.transform(matrix, owner.baseTransform);
      if (this.matrix) {
        matrix = _util.Util.transform(matrix, this.matrix);
      }
    }
    const temporaryPatternCanvas = this.createPatternCanvas(owner);
    let domMatrix = new DOMMatrix(matrix);
    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
    pattern.setTransform(domMatrix);
    return pattern;
  }
}
exports.TilingPattern = TilingPattern;

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA;
exports.convertToRGBA = convertToRGBA;
exports.grayToRGBA = grayToRGBA;
var _util = __w_pdfjs_require__(1);
function convertToRGBA(params) {
  switch (params.kind) {
    case _util.ImageKind.GRAYSCALE_1BPP:
      return convertBlackAndWhiteToRGBA(params);
    case _util.ImageKind.RGB_24BPP:
      return convertRGBToRGBA(params);
  }
  return null;
}
function convertBlackAndWhiteToRGBA({
  src,
  srcPos = 0,
  dest,
  width,
  height,
  nonBlackColor = 0xffffffff,
  inverseDecode = false
}) {
  const black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];
  const widthInSource = width >> 3;
  const widthRemainder = width & 7;
  const srcLength = src.length;
  dest = new Uint32Array(dest.buffer);
  let destPos = 0;
  for (let i = 0; i < height; i++) {
    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
      const elem = srcPos < srcLength ? src[srcPos] : 255;
      dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;
    }
    if (widthRemainder === 0) {
      continue;
    }
    const elem = srcPos < srcLength ? src[srcPos++] : 255;
    for (let j = 0; j < widthRemainder; j++) {
      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
    }
  }
  return {
    srcPos,
    destPos
  };
}
function convertRGBToRGBA({
  src,
  srcPos = 0,
  dest,
  destPos = 0,
  width,
  height
}) {
  let i = 0;
  const len32 = src.length >> 2;
  const src32 = new Uint32Array(src.buffer, srcPos, len32);
  if (_util.FeatureTest.isLittleEndian) {
    for (; i < len32 - 2; i += 3, destPos += 4) {
      const s1 = src32[i];
      const s2 = src32[i + 1];
      const s3 = src32[i + 2];
      dest[destPos] = s1 | 0xff000000;
      dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;
      dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;
      dest[destPos + 3] = s3 >>> 8 | 0xff000000;
    }
    for (let j = i * 4, jj = src.length; j < jj; j += 3) {
      dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;
    }
  } else {
    for (; i < len32 - 2; i += 3, destPos += 4) {
      const s1 = src32[i];
      const s2 = src32[i + 1];
      const s3 = src32[i + 2];
      dest[destPos] = s1 | 0xff;
      dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;
      dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;
      dest[destPos + 3] = s3 << 8 | 0xff;
    }
    for (let j = i * 4, jj = src.length; j < jj; j += 3) {
      dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;
    }
  }
  return {
    srcPos,
    destPos
  };
}
function grayToRGBA(src, dest) {
  if (_util.FeatureTest.isLittleEndian) {
    for (let i = 0, ii = src.length; i < ii; i++) {
      dest[i] = src[i] * 0x10101 | 0xff000000;
    }
  } else {
    for (let i = 0, ii = src.length; i < ii; i++) {
      dest[i] = src[i] * 0x1010100 | 0x000000ff;
    }
  }
}

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GlobalWorkerOptions = void 0;
const GlobalWorkerOptions = Object.create(null);
exports.GlobalWorkerOptions = GlobalWorkerOptions;
GlobalWorkerOptions.workerPort = null;
GlobalWorkerOptions.workerSrc = "";

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MessageHandler = void 0;
var _util = __w_pdfjs_require__(1);
const CallbackKind = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
};
const StreamKind = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function wrapReason(reason) {
  if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
    (0, _util.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  }
  switch (reason.name) {
    case "AbortException":
      return new _util.AbortException(reason.message);
    case "MissingPDFException":
      return new _util.MissingPDFException(reason.message);
    case "PasswordException":
      return new _util.PasswordException(reason.message, reason.code);
    case "UnexpectedResponseException":
      return new _util.UnexpectedResponseException(reason.message, reason.status);
    case "UnknownErrorException":
      return new _util.UnknownErrorException(reason.message, reason.details);
    default:
      return new _util.UnknownErrorException(reason.message, reason.toString());
  }
}
class MessageHandler {
  constructor(sourceName, targetName, comObj) {
    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.streamSinks = Object.create(null);
    this.streamControllers = Object.create(null);
    this.callbackCapabilities = Object.create(null);
    this.actionHandler = Object.create(null);
    this._onComObjOnMessage = event => {
      const data = event.data;
      if (data.targetName !== this.sourceName) {
        return;
      }
      if (data.stream) {
        this.#processStreamMessage(data);
        return;
      }
      if (data.callback) {
        const callbackId = data.callbackId;
        const capability = this.callbackCapabilities[callbackId];
        if (!capability) {
          throw new Error(`Cannot resolve callback ${callbackId}`);
        }
        delete this.callbackCapabilities[callbackId];
        if (data.callback === CallbackKind.DATA) {
          capability.resolve(data.data);
        } else if (data.callback === CallbackKind.ERROR) {
          capability.reject(wrapReason(data.reason));
        } else {
          throw new Error("Unexpected callback case");
        }
        return;
      }
      const action = this.actionHandler[data.action];
      if (!action) {
        throw new Error(`Unknown action from worker: ${data.action}`);
      }
      if (data.callbackId) {
        const cbSourceName = this.sourceName;
        const cbTargetName = data.sourceName;
        new Promise(function (resolve) {
          resolve(action(data.data));
        }).then(function (result) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.DATA,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.ERROR,
            callbackId: data.callbackId,
            reason: wrapReason(reason)
          });
        });
        return;
      }
      if (data.streamId) {
        this.#createStreamSink(data);
        return;
      }
      action(data.data);
    };
    comObj.addEventListener("message", this._onComObjOnMessage);
  }
  on(actionName, handler) {
    const ah = this.actionHandler;
    if (ah[actionName]) {
      throw new Error(`There is already an actionName called "${actionName}"`);
    }
    ah[actionName] = handler;
  }
  send(actionName, data, transfers) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data
    }, transfers);
  }
  sendWithPromise(actionName, data, transfers) {
    const callbackId = this.callbackId++;
    const capability = new _util.PromiseCapability();
    this.callbackCapabilities[callbackId] = capability;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        callbackId,
        data
      }, transfers);
    } catch (ex) {
      capability.reject(ex);
    }
    return capability.promise;
  }
  sendWithStream(actionName, data, queueingStrategy, transfers) {
    const streamId = this.streamId++,
      sourceName = this.sourceName,
      targetName = this.targetName,
      comObj = this.comObj;
    return new ReadableStream({
      start: controller => {
        const startCapability = new _util.PromiseCapability();
        this.streamControllers[streamId] = {
          controller,
          startCall: startCapability,
          pullCall: null,
          cancelCall: null,
          isClosed: false
        };
        comObj.postMessage({
          sourceName,
          targetName,
          action: actionName,
          streamId,
          data,
          desiredSize: controller.desiredSize
        }, transfers);
        return startCapability.promise;
      },
      pull: controller => {
        const pullCapability = new _util.PromiseCapability();
        this.streamControllers[streamId].pullCall = pullCapability;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL,
          streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      },
      cancel: reason => {
        (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
        const cancelCapability = new _util.PromiseCapability();
        this.streamControllers[streamId].cancelCall = cancelCapability;
        this.streamControllers[streamId].isClosed = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL,
          streamId,
          reason: wrapReason(reason)
        });
        return cancelCapability.promise;
      }
    }, queueingStrategy);
  }
  #createStreamSink(data) {
    const streamId = data.streamId,
      sourceName = this.sourceName,
      targetName = data.sourceName,
      comObj = this.comObj;
    const self = this,
      action = this.actionHandler[data.action];
    const streamSink = {
      enqueue(chunk, size = 1, transfers) {
        if (this.isCancelled) {
          return;
        }
        const lastDesiredSize = this.desiredSize;
        this.desiredSize -= size;
        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
          this.sinkCapability = new _util.PromiseCapability();
          this.ready = this.sinkCapability.promise;
        }
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ENQUEUE,
          streamId,
          chunk
        }, transfers);
      },
      close() {
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CLOSE,
          streamId
        });
        delete self.streamSinks[streamId];
      },
      error(reason) {
        (0, _util.assert)(reason instanceof Error, "error must have a valid reason");
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ERROR,
          streamId,
          reason: wrapReason(reason)
        });
      },
      sinkCapability: new _util.PromiseCapability(),
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: data.desiredSize,
      ready: null
    };
    streamSink.sinkCapability.resolve();
    streamSink.ready = streamSink.sinkCapability.promise;
    this.streamSinks[streamId] = streamSink;
    new Promise(function (resolve) {
      resolve(action(data.data, streamSink));
    }).then(function () {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        success: true
      });
    }, function (reason) {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        reason: wrapReason(reason)
      });
    });
  }
  #processStreamMessage(data) {
    const streamId = data.streamId,
      sourceName = this.sourceName,
      targetName = data.sourceName,
      comObj = this.comObj;
    const streamController = this.streamControllers[streamId],
      streamSink = this.streamSinks[streamId];
    switch (data.stream) {
      case StreamKind.START_COMPLETE:
        if (data.success) {
          streamController.startCall.resolve();
        } else {
          streamController.startCall.reject(wrapReason(data.reason));
        }
        break;
      case StreamKind.PULL_COMPLETE:
        if (data.success) {
          streamController.pullCall.resolve();
        } else {
          streamController.pullCall.reject(wrapReason(data.reason));
        }
        break;
      case StreamKind.PULL:
        if (!streamSink) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
          break;
        }
        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
          streamSink.sinkCapability.resolve();
        }
        streamSink.desiredSize = data.desiredSize;
        new Promise(function (resolve) {
          resolve(streamSink.onPull?.());
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        break;
      case StreamKind.ENQUEUE:
        (0, _util.assert)(streamController, "enqueue should have stream controller");
        if (streamController.isClosed) {
          break;
        }
        streamController.controller.enqueue(data.chunk);
        break;
      case StreamKind.CLOSE:
        (0, _util.assert)(streamController, "close should have stream controller");
        if (streamController.isClosed) {
          break;
        }
        streamController.isClosed = true;
        streamController.controller.close();
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.ERROR:
        (0, _util.assert)(streamController, "error should have stream controller");
        streamController.controller.error(wrapReason(data.reason));
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.CANCEL_COMPLETE:
        if (data.success) {
          streamController.cancelCall.resolve();
        } else {
          streamController.cancelCall.reject(wrapReason(data.reason));
        }
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.CANCEL:
        if (!streamSink) {
          break;
        }
        new Promise(function (resolve) {
          resolve(streamSink.onCancel?.(wrapReason(data.reason)));
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        streamSink.sinkCapability.reject(wrapReason(data.reason));
        streamSink.isCancelled = true;
        delete this.streamSinks[streamId];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  }
  async #deleteStreamController(streamController, streamId) {
    await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);
    delete this.streamControllers[streamId];
  }
  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }
}
exports.MessageHandler = MessageHandler;

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Metadata = void 0;
var _util = __w_pdfjs_require__(1);
class Metadata {
  #metadataMap;
  #data;
  constructor({
    parsedData,
    rawData
  }) {
    this.#metadataMap = parsedData;
    this.#data = rawData;
  }
  getRaw() {
    return this.#data;
  }
  get(name) {
    return this.#metadataMap.get(name) ?? null;
  }
  getAll() {
    return (0, _util.objectFromMap)(this.#metadataMap);
  }
  has(name) {
    return this.#metadataMap.has(name);
  }
}
exports.Metadata = Metadata;

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OptionalContentConfig = void 0;
var _util = __w_pdfjs_require__(1);
var _murmurhash = __w_pdfjs_require__(8);
const INTERNAL = Symbol("INTERNAL");
class OptionalContentGroup {
  #visible = true;
  constructor(name, intent) {
    this.name = name;
    this.intent = intent;
  }
  get visible() {
    return this.#visible;
  }
  _setVisible(internal, visible) {
    if (internal !== INTERNAL) {
      (0, _util.unreachable)("Internal method `_setVisible` called.");
    }
    this.#visible = visible;
  }
}
class OptionalContentConfig {
  #cachedGetHash = null;
  #groups = new Map();
  #initialHash = null;
  #order = null;
  constructor(data) {
    this.name = null;
    this.creator = null;
    if (data === null) {
      return;
    }
    this.name = data.name;
    this.creator = data.creator;
    this.#order = data.order;
    for (const group of data.groups) {
      this.#groups.set(group.id, new OptionalContentGroup(group.name, group.intent));
    }
    if (data.baseState === "OFF") {
      for (const group of this.#groups.values()) {
        group._setVisible(INTERNAL, false);
      }
    }
    for (const on of data.on) {
      this.#groups.get(on)._setVisible(INTERNAL, true);
    }
    for (const off of data.off) {
      this.#groups.get(off)._setVisible(INTERNAL, false);
    }
    this.#initialHash = this.getHash();
  }
  #evaluateVisibilityExpression(array) {
    const length = array.length;
    if (length < 2) {
      return true;
    }
    const operator = array[0];
    for (let i = 1; i < length; i++) {
      const element = array[i];
      let state;
      if (Array.isArray(element)) {
        state = this.#evaluateVisibilityExpression(element);
      } else if (this.#groups.has(element)) {
        state = this.#groups.get(element).visible;
      } else {
        (0, _util.warn)(`Optional content group not found: ${element}`);
        return true;
      }
      switch (operator) {
        case "And":
          if (!state) {
            return false;
          }
          break;
        case "Or":
          if (state) {
            return true;
          }
          break;
        case "Not":
          return !state;
        default:
          return true;
      }
    }
    return operator === "And";
  }
  isVisible(group) {
    if (this.#groups.size === 0) {
      return true;
    }
    if (!group) {
      (0, _util.warn)("Optional content group not defined.");
      return true;
    }
    if (group.type === "OCG") {
      if (!this.#groups.has(group.id)) {
        (0, _util.warn)(`Optional content group not found: ${group.id}`);
        return true;
      }
      return this.#groups.get(group.id).visible;
    } else if (group.type === "OCMD") {
      if (group.expression) {
        return this.#evaluateVisibilityExpression(group.expression);
      }
      if (!group.policy || group.policy === "AnyOn") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }
          if (this.#groups.get(id).visible) {
            return true;
          }
        }
        return false;
      } else if (group.policy === "AllOn") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }
          if (!this.#groups.get(id).visible) {
            return false;
          }
        }
        return true;
      } else if (group.policy === "AnyOff") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }
          if (!this.#groups.get(id).visible) {
            return true;
          }
        }
        return false;
      } else if (group.policy === "AllOff") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }
          if (this.#groups.get(id).visible) {
            return false;
          }
        }
        return true;
      }
      (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);
      return true;
    }
    (0, _util.warn)(`Unknown group type ${group.type}.`);
    return true;
  }
  setVisibility(id, visible = true) {
    if (!this.#groups.has(id)) {
      (0, _util.warn)(`Optional content group not found: ${id}`);
      return;
    }
    this.#groups.get(id)._setVisible(INTERNAL, !!visible);
    this.#cachedGetHash = null;
  }
  get hasInitialVisibility() {
    return this.#initialHash === null || this.getHash() === this.#initialHash;
  }
  getOrder() {
    if (!this.#groups.size) {
      return null;
    }
    if (this.#order) {
      return this.#order.slice();
    }
    return [...this.#groups.keys()];
  }
  getGroups() {
    return this.#groups.size > 0 ? (0, _util.objectFromMap)(this.#groups) : null;
  }
  getGroup(id) {
    return this.#groups.get(id) || null;
  }
  getHash() {
    if (this.#cachedGetHash !== null) {
      return this.#cachedGetHash;
    }
    const hash = new _murmurhash.MurmurHash3_64();
    for (const [id, group] of this.#groups) {
      hash.update(`${id}:${group.visible}`);
    }
    return this.#cachedGetHash = hash.hexdigest();
  }
}
exports.OptionalContentConfig = OptionalContentConfig;

/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFDataTransportStream = void 0;
var _util = __w_pdfjs_require__(1);
var _display_utils = __w_pdfjs_require__(6);
class PDFDataTransportStream {
  constructor({
    length,
    initialData,
    progressiveDone = false,
    contentDispositionFilename = null,
    disableRange = false,
    disableStream = false
  }, pdfDataRangeTransport) {
    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    this._queuedChunks = [];
    this._progressiveDone = progressiveDone;
    this._contentDispositionFilename = contentDispositionFilename;
    if (initialData?.length > 0) {
      const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;
      this._queuedChunks.push(buffer);
    }
    this._pdfDataRangeTransport = pdfDataRangeTransport;
    this._isStreamingSupported = !disableStream;
    this._isRangeSupported = !disableRange;
    this._contentLength = length;
    this._fullRequestReader = null;
    this._rangeReaders = [];
    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
      this._onReceiveData({
        begin,
        chunk
      });
    });
    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
      this._onProgress({
        loaded,
        total
      });
    });
    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {
      this._onReceiveData({
        chunk
      });
    });
    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    });
    this._pdfDataRangeTransport.transportReady();
  }
  _onReceiveData({
    begin,
    chunk
  }) {
    const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;
    if (begin === undefined) {
      if (this._fullRequestReader) {
        this._fullRequestReader._enqueue(buffer);
      } else {
        this._queuedChunks.push(buffer);
      }
    } else {
      const found = this._rangeReaders.some(function (rangeReader) {
        if (rangeReader._begin !== begin) {
          return false;
        }
        rangeReader._enqueue(buffer);
        return true;
      });
      (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  _onProgress(evt) {
    if (evt.total === undefined) {
      this._rangeReaders[0]?.onProgress?.({
        loaded: evt.loaded
      });
    } else {
      this._fullRequestReader?.onProgress?.({
        loaded: evt.loaded,
        total: evt.total
      });
    }
  }
  _onProgressiveDone() {
    this._fullRequestReader?.progressiveDone();
    this._progressiveDone = true;
  }
  _removeRangeReader(reader) {
    const i = this._rangeReaders.indexOf(reader);
    if (i >= 0) {
      this._rangeReaders.splice(i, 1);
    }
  }
  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const queuedChunks = this._queuedChunks;
    this._queuedChunks = null;
    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
    this._pdfDataRangeTransport.requestDataRange(begin, end);
    this._rangeReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeReaders.slice(0)) {
      reader.cancel(reason);
    }
    this._pdfDataRangeTransport.abort();
  }
}
exports.PDFDataTransportStream = PDFDataTransportStream;
class PDFDataTransportStreamReader {
  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
    this._stream = stream;
    this._done = progressiveDone || false;
    this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
    this._queuedChunks = queuedChunks || [];
    this._loaded = 0;
    for (const chunk of this._queuedChunks) {
      this._loaded += chunk.byteLength;
    }
    this._requests = [];
    this._headersReady = Promise.resolve();
    stream._fullRequestReader = this;
    this.onProgress = null;
  }
  _enqueue(chunk) {
    if (this._done) {
      return;
    }
    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();
      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunks.push(chunk);
    }
    this._loaded += chunk.byteLength;
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0) {
      const chunk = this._queuedChunks.shift();
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }
    const requestCapability = new _util.PromiseCapability();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }
    this._requests.length = 0;
  }
  progressiveDone() {
    if (this._done) {
      return;
    }
    this._done = true;
  }
}
class PDFDataTransportStreamRangeReader {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._begin = begin;
    this._end = end;
    this._queuedChunk = null;
    this._requests = [];
    this._done = false;
    this.onProgress = null;
  }
  _enqueue(chunk) {
    if (this._done) {
      return;
    }
    if (this._requests.length === 0) {
      this._queuedChunk = chunk;
    } else {
      const requestsCapability = this._requests.shift();
      requestsCapability.resolve({
        value: chunk,
        done: false
      });
      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      }
      this._requests.length = 0;
    }
    this._done = true;
    this._stream._removeRangeReader(this);
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._queuedChunk) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }
    const requestCapability = new _util.PromiseCapability();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }
    this._requests.length = 0;
    this._stream._removeRangeReader(this);
  }
}

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFFetchStream = void 0;
var _util = __w_pdfjs_require__(1);
var _network_utils = __w_pdfjs_require__(20);
;
function createFetchOptions(headers, withCredentials, abortController) {
  return {
    method: "GET",
    headers,
    signal: abortController.signal,
    mode: "cors",
    credentials: withCredentials ? "include" : "same-origin",
    redirect: "follow"
  };
}
function createHeaders(httpHeaders) {
  const headers = new Headers();
  for (const property in httpHeaders) {
    const value = httpHeaders[property];
    if (value === undefined) {
      continue;
    }
    headers.append(property, value);
  }
  return headers;
}
function getArrayBuffer(val) {
  if (val instanceof Uint8Array) {
    return val.buffer;
  }
  if (val instanceof ArrayBuffer) {
    return val;
  }
  (0, _util.warn)(`getArrayBuffer - unexpected data format: ${val}`);
  return new Uint8Array(val).buffer;
}
class PDFFetchStream {
  constructor(source) {
    this.source = source;
    this.isHttp = /^https?:/i.test(source.url);
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFFetchStreamReader(this);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const reader = new PDFFetchStreamRangeReader(this, begin, end);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
}
exports.PDFFetchStream = PDFFetchStream;
class PDFFetchStreamReader {
  constructor(stream) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    this._filename = null;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._contentLength = source.length;
    this._headersCapability = new _util.PromiseCapability();
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._abortController = new AbortController();
    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._headers = createHeaders(this._stream.httpHeaders);
    const url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
        throw (0, _network_utils.createResponseStatusError)(response.status, url);
      }
      this._reader = response.body.getReader();
      this._headersCapability.resolve();
      const getResponseHeader = name => {
        return response.headers.get(name);
      };
      const {
        allowRangeRequests,
        suggestedLength
      } = (0, _network_utils.validateRangeRequestCapabilities)({
        getResponseHeader,
        isHttp: this._stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
      if (!this._isStreamingSupported && this._isRangeSupported) {
        this.cancel(new _util.AbortException("Streaming is disabled."));
      }
    }).catch(this._headersCapability.reject);
    this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._headersCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value,
        done
      };
    }
    this._loaded += value.byteLength;
    this.onProgress?.({
      loaded: this._loaded,
      total: this._contentLength
    });
    return {
      value: getArrayBuffer(value),
      done: false
    };
  }
  cancel(reason) {
    this._reader?.cancel(reason);
    this._abortController.abort();
  }
}
class PDFFetchStreamRangeReader {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._readCapability = new _util.PromiseCapability();
    this._isStreamingSupported = !source.disableStream;
    this._abortController = new AbortController();
    this._headers = createHeaders(this._stream.httpHeaders);
    this._headers.append("Range", `bytes=${begin}-${end - 1}`);
    const url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
        throw (0, _network_utils.createResponseStatusError)(response.status, url);
      }
      this._readCapability.resolve();
      this._reader = response.body.getReader();
    }).catch(this._readCapability.reject);
    this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._readCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value,
        done
      };
    }
    this._loaded += value.byteLength;
    this.onProgress?.({
      loaded: this._loaded
    });
    return {
      value: getArrayBuffer(value),
      done: false
    };
  }
  cancel(reason) {
    this._reader?.cancel(reason);
    this._abortController.abort();
  }
}

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createResponseStatusError = createResponseStatusError;
exports.extractFilenameFromHeader = extractFilenameFromHeader;
exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
exports.validateResponseStatus = validateResponseStatus;
var _util = __w_pdfjs_require__(1);
var _content_disposition = __w_pdfjs_require__(21);
var _display_utils = __w_pdfjs_require__(6);
function validateRangeRequestCapabilities({
  getResponseHeader,
  isHttp,
  rangeChunkSize,
  disableRange
}) {
  const returnValues = {
    allowRangeRequests: false,
    suggestedLength: undefined
  };
  const length = parseInt(getResponseHeader("Content-Length"), 10);
  if (!Number.isInteger(length)) {
    return returnValues;
  }
  returnValues.suggestedLength = length;
  if (length <= 2 * rangeChunkSize) {
    return returnValues;
  }
  if (disableRange || !isHttp) {
    return returnValues;
  }
  if (getResponseHeader("Accept-Ranges") !== "bytes") {
    return returnValues;
  }
  const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
  if (contentEncoding !== "identity") {
    return returnValues;
  }
  returnValues.allowRangeRequests = true;
  return returnValues;
}
function extractFilenameFromHeader(getResponseHeader) {
  const contentDisposition = getResponseHeader("Content-Disposition");
  if (contentDisposition) {
    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
    if (filename.includes("%")) {
      try {
        filename = decodeURIComponent(filename);
      } catch {}
    }
    if ((0, _display_utils.isPdfFile)(filename)) {
      return filename;
    }
  }
  return null;
}
function createResponseStatusError(status, url) {
  if (status === 404 || status === 0 && url.startsWith("file:")) {
    return new _util.MissingPDFException('Missing PDF "' + url + '".');
  }
  return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
}
function validateResponseStatus(status) {
  return status === 200 || status === 206;
}

/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
var _util = __w_pdfjs_require__(1);
function getFilenameFromContentDispositionHeader(contentDisposition) {
  let needsEncodingFixup = true;
  let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = unescape(filename);
    filename = rfc5987decode(filename);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  tmp = rfc2231getparam(contentDisposition);
  if (tmp) {
    const filename = rfc2047decode(tmp);
    return fixupEncoding(filename);
  }
  tmp = toParamRegExp("filename", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  function toParamRegExp(attributePattern, flags) {
    return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
  }
  function textdecode(encoding, value) {
    if (encoding) {
      if (!/^[\x00-\xFF]+$/.test(value)) {
        return value;
      }
      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = (0, _util.stringToBytes)(value);
        value = decoder.decode(buffer);
        needsEncodingFixup = false;
      } catch {}
    }
    return value;
  }
  function fixupEncoding(value) {
    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
      value = textdecode("utf-8", value);
      if (needsEncodingFixup) {
        value = textdecode("iso-8859-1", value);
      }
    }
    return value;
  }
  function rfc2231getparam(contentDispositionStr) {
    const matches = [];
    let match;
    const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    while ((match = iter.exec(contentDispositionStr)) !== null) {
      let [, n, quot, part] = match;
      n = parseInt(n, 10);
      if (n in matches) {
        if (n === 0) {
          break;
        }
        continue;
      }
      matches[n] = [quot, part];
    }
    const parts = [];
    for (let n = 0; n < matches.length; ++n) {
      if (!(n in matches)) {
        break;
      }
      let [quot, part] = matches[n];
      part = rfc2616unquote(part);
      if (quot) {
        part = unescape(part);
        if (n === 0) {
          part = rfc5987decode(part);
        }
      }
      parts.push(part);
    }
    return parts.join("");
  }
  function rfc2616unquote(value) {
    if (value.startsWith('"')) {
      const parts = value.slice(1).split('\\"');
      for (let i = 0; i < parts.length; ++i) {
        const quotindex = parts[i].indexOf('"');
        if (quotindex !== -1) {
          parts[i] = parts[i].slice(0, quotindex);
          parts.length = i + 1;
        }
        parts[i] = parts[i].replaceAll(/\\(.)/g, "$1");
      }
      value = parts.join('"');
    }
    return value;
  }
  function rfc5987decode(extvalue) {
    const encodingend = extvalue.indexOf("'");
    if (encodingend === -1) {
      return extvalue;
    }
    const encoding = extvalue.slice(0, encodingend);
    const langvalue = extvalue.slice(encodingend + 1);
    const value = langvalue.replace(/^[^']*'/, "");
    return textdecode(encoding, value);
  }
  function rfc2047decode(value) {
    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
      return value;
    }
    return value.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) {
      if (encoding === "q" || encoding === "Q") {
        text = text.replaceAll("_", " ");
        text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function (match, hex) {
          return String.fromCharCode(parseInt(hex, 16));
        });
        return textdecode(charset, text);
      }
      try {
        text = atob(text);
      } catch {}
      return textdecode(charset, text);
    });
  }
  return "";
}

/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFNetworkStream = void 0;
var _util = __w_pdfjs_require__(1);
var _network_utils = __w_pdfjs_require__(20);
;
const OK_RESPONSE = 200;
const PARTIAL_CONTENT_RESPONSE = 206;
function getArrayBuffer(xhr) {
  const data = xhr.response;
  if (typeof data !== "string") {
    return data;
  }
  return (0, _util.stringToBytes)(data).buffer;
}
class NetworkManager {
  constructor(url, args = {}) {
    this.url = url;
    this.isHttp = /^https?:/i.test(url);
    this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);
    this.withCredentials = args.withCredentials || false;
    this.currXhrId = 0;
    this.pendingRequests = Object.create(null);
  }
  requestRange(begin, end, listeners) {
    const args = {
      begin,
      end
    };
    for (const prop in listeners) {
      args[prop] = listeners[prop];
    }
    return this.request(args);
  }
  requestFull(listeners) {
    return this.request(listeners);
  }
  request(args) {
    const xhr = new XMLHttpRequest();
    const xhrId = this.currXhrId++;
    const pendingRequest = this.pendingRequests[xhrId] = {
      xhr
    };
    xhr.open("GET", this.url);
    xhr.withCredentials = this.withCredentials;
    for (const property in this.httpHeaders) {
      const value = this.httpHeaders[property];
      if (value === undefined) {
        continue;
      }
      xhr.setRequestHeader(property, value);
    }
    if (this.isHttp && "begin" in args && "end" in args) {
      xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
    } else {
      pendingRequest.expectedStatus = OK_RESPONSE;
    }
    xhr.responseType = "arraybuffer";
    if (args.onError) {
      xhr.onerror = function (evt) {
        args.onError(xhr.status);
      };
    }
    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
    xhr.onprogress = this.onProgress.bind(this, xhrId);
    pendingRequest.onHeadersReceived = args.onHeadersReceived;
    pendingRequest.onDone = args.onDone;
    pendingRequest.onError = args.onError;
    pendingRequest.onProgress = args.onProgress;
    xhr.send(null);
    return xhrId;
  }
  onProgress(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];
    if (!pendingRequest) {
      return;
    }
    pendingRequest.onProgress?.(evt);
  }
  onStateChange(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];
    if (!pendingRequest) {
      return;
    }
    const xhr = pendingRequest.xhr;
    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
      pendingRequest.onHeadersReceived();
      delete pendingRequest.onHeadersReceived;
    }
    if (xhr.readyState !== 4) {
      return;
    }
    if (!(xhrId in this.pendingRequests)) {
      return;
    }
    delete this.pendingRequests[xhrId];
    if (xhr.status === 0 && this.isHttp) {
      pendingRequest.onError?.(xhr.status);
      return;
    }
    const xhrStatus = xhr.status || OK_RESPONSE;
    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
      pendingRequest.onError?.(xhr.status);
      return;
    }
    const chunk = getArrayBuffer(xhr);
    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
      const rangeHeader = xhr.getResponseHeader("Content-Range");
      const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
      pendingRequest.onDone({
        begin: parseInt(matches[1], 10),
        chunk
      });
    } else if (chunk) {
      pendingRequest.onDone({
        begin: 0,
        chunk
      });
    } else {
      pendingRequest.onError?.(xhr.status);
    }
  }
  getRequestXhr(xhrId) {
    return this.pendingRequests[xhrId].xhr;
  }
  isPendingRequest(xhrId) {
    return xhrId in this.pendingRequests;
  }
  abortRequest(xhrId) {
    const xhr = this.pendingRequests[xhrId].xhr;
    delete this.pendingRequests[xhrId];
    xhr.abort();
  }
}
class PDFNetworkStream {
  constructor(source) {
    this._source = source;
    this._manager = new NetworkManager(source.url, {
      httpHeaders: source.httpHeaders,
      withCredentials: source.withCredentials
    });
    this._rangeChunkSize = source.rangeChunkSize;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(reader) {
    const i = this._rangeRequestReaders.indexOf(reader);
    if (i >= 0) {
      this._rangeRequestReaders.splice(i, 1);
    }
  }
  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
}
exports.PDFNetworkStream = PDFNetworkStream;
class PDFNetworkStreamFullRequestReader {
  constructor(manager, source) {
    this._manager = manager;
    const args = {
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = source.url;
    this._fullRequestId = manager.requestFull(args);
    this._headersReceivedCapability = new _util.PromiseCapability();
    this._disableRange = source.disableRange || false;
    this._contentLength = source.length;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._isStreamingSupported = false;
    this._isRangeSupported = false;
    this._cachedChunks = [];
    this._requests = [];
    this._done = false;
    this._storedError = undefined;
    this._filename = null;
    this.onProgress = null;
  }
  _onHeadersReceived() {
    const fullRequestXhrId = this._fullRequestId;
    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
    const getResponseHeader = name => {
      return fullRequestXhr.getResponseHeader(name);
    };
    const {
      allowRangeRequests,
      suggestedLength
    } = (0, _network_utils.validateRangeRequestCapabilities)({
      getResponseHeader,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });
    if (allowRangeRequests) {
      this._isRangeSupported = true;
    }
    this._contentLength = suggestedLength || this._contentLength;
    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
    if (this._isRangeSupported) {
      this._manager.abortRequest(fullRequestXhrId);
    }
    this._headersReceivedCapability.resolve();
  }
  _onDone(data) {
    if (data) {
      if (this._requests.length > 0) {
        const requestCapability = this._requests.shift();
        requestCapability.resolve({
          value: data.chunk,
          done: false
        });
      } else {
        this._cachedChunks.push(data.chunk);
      }
    }
    this._done = true;
    if (this._cachedChunks.length > 0) {
      return;
    }
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }
    this._requests.length = 0;
  }
  _onError(status) {
    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
    this._headersReceivedCapability.reject(this._storedError);
    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }
    this._requests.length = 0;
    this._cachedChunks.length = 0;
  }
  _onProgress(evt) {
    this.onProgress?.({
      loaded: evt.loaded,
      total: evt.lengthComputable ? evt.total : this._contentLength
    });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersReceivedCapability.promise;
  }
  async read() {
    if (this._storedError) {
      throw this._storedError;
    }
    if (this._cachedChunks.length > 0) {
      const chunk = this._cachedChunks.shift();
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }
    const requestCapability = new _util.PromiseCapability();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    this._headersReceivedCapability.reject(reason);
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }
    this._requests.length = 0;
    if (this._manager.isPendingRequest(this._fullRequestId)) {
      this._manager.abortRequest(this._fullRequestId);
    }
    this._fullRequestReader = null;
  }
}
class PDFNetworkStreamRangeRequestReader {
  constructor(manager, begin, end) {
    this._manager = manager;
    const args = {
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = manager.url;
    this._requestId = manager.requestRange(begin, end, args);
    this._requests = [];
    this._queuedChunk = null;
    this._done = false;
    this._storedError = undefined;
    this.onProgress = null;
    this.onClosed = null;
  }
  _close() {
    this.onClosed?.(this);
  }
  _onDone(data) {
    const chunk = data.chunk;
    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();
      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunk = chunk;
    }
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }
    this._requests.length = 0;
    this._close();
  }
  _onError(status) {
    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }
    this._requests.length = 0;
    this._queuedChunk = null;
  }
  _onProgress(evt) {
    if (!this.isStreamingSupported) {
      this.onProgress?.({
        loaded: evt.loaded
      });
    }
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._storedError) {
      throw this._storedError;
    }
    if (this._queuedChunk !== null) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }
    const requestCapability = new _util.PromiseCapability();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }
    this._requests.length = 0;
    if (this._manager.isPendingRequest(this._requestId)) {
      this._manager.abortRequest(this._requestId);
    }
    this._close();
  }
}

/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFNodeStream = void 0;
var _util = __w_pdfjs_require__(1);
var _network_utils = __w_pdfjs_require__(20);
;
const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
function parseUrl(sourceUrl) {
  const url = __webpack_require__(/*! url */ "?9f5f");
  const parsedUrl = url.parse(sourceUrl);
  if (parsedUrl.protocol === "file:" || parsedUrl.host) {
    return parsedUrl;
  }
  if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
    return url.parse(`file:///${sourceUrl}`);
  }
  if (!parsedUrl.host) {
    parsedUrl.protocol = "file:";
  }
  return parsedUrl;
}
class PDFNodeStream {
  constructor(source) {
    this.source = source;
    this.url = parseUrl(source.url);
    this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
    this.isFsUrl = this.url.protocol === "file:";
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
    return this._fullRequestReader;
  }
  getRangeReader(start, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
    this._rangeRequestReaders.push(rangeReader);
    return rangeReader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
}
exports.PDFNodeStream = PDFNodeStream;
class BaseFullReader {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    const source = stream.source;
    this._contentLength = source.length;
    this._loaded = 0;
    this._filename = null;
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._readableStream = null;
    this._readCapability = new _util.PromiseCapability();
    this._headersCapability = new _util.PromiseCapability();
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._readCapability.promise;
    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }
    if (this._storedError) {
      throw this._storedError;
    }
    const chunk = this._readableStream.read();
    if (chunk === null) {
      this._readCapability = new _util.PromiseCapability();
      return this.read();
    }
    this._loaded += chunk.length;
    this.onProgress?.({
      loaded: this._loaded,
      total: this._contentLength
    });
    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }
  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);
      return;
    }
    this._readableStream.destroy(reason);
  }
  _error(reason) {
    this._storedError = reason;
    this._readCapability.resolve();
  }
  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;
      this._readCapability.resolve();
    });
    readableStream.on("error", reason => {
      this._error(reason);
    });
    if (!this._isStreamingSupported && this._isRangeSupported) {
      this._error(new _util.AbortException("streaming is disabled"));
    }
    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }
}
class BaseRangeReader {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    this._loaded = 0;
    this._readableStream = null;
    this._readCapability = new _util.PromiseCapability();
    const source = stream.source;
    this._isStreamingSupported = !source.disableStream;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._readCapability.promise;
    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }
    if (this._storedError) {
      throw this._storedError;
    }
    const chunk = this._readableStream.read();
    if (chunk === null) {
      this._readCapability = new _util.PromiseCapability();
      return this.read();
    }
    this._loaded += chunk.length;
    this.onProgress?.({
      loaded: this._loaded
    });
    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }
  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);
      return;
    }
    this._readableStream.destroy(reason);
  }
  _error(reason) {
    this._storedError = reason;
    this._readCapability.resolve();
  }
  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;
      this._readCapability.resolve();
    });
    readableStream.on("error", reason => {
      this._error(reason);
    });
    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }
}
function createRequestOptions(parsedUrl, headers) {
  return {
    protocol: parsedUrl.protocol,
    auth: parsedUrl.auth,
    host: parsedUrl.hostname,
    port: parsedUrl.port,
    path: parsedUrl.path,
    method: "GET",
    headers
  };
}
class PDFNodeStreamFullReader extends BaseFullReader {
  constructor(stream) {
    super(stream);
    const handleResponse = response => {
      if (response.statusCode === 404) {
        const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
        this._storedError = error;
        this._headersCapability.reject(error);
        return;
      }
      this._headersCapability.resolve();
      this._setReadableStream(response);
      const getResponseHeader = name => {
        return this._readableStream.headers[name.toLowerCase()];
      };
      const {
        allowRangeRequests,
        suggestedLength
      } = (0, _network_utils.validateRangeRequestCapabilities)({
        getResponseHeader,
        isHttp: stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
    };
    this._request = null;
    if (this._url.protocol === "http:") {
      const http = __webpack_require__(/*! http */ "?d446");
      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
    } else {
      const https = __webpack_require__(/*! https */ "?4c38");
      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
    }
    this._request.on("error", reason => {
      this._storedError = reason;
      this._headersCapability.reject(reason);
    });
    this._request.end();
  }
}
class PDFNodeStreamRangeReader extends BaseRangeReader {
  constructor(stream, start, end) {
    super(stream);
    this._httpHeaders = {};
    for (const property in stream.httpHeaders) {
      const value = stream.httpHeaders[property];
      if (value === undefined) {
        continue;
      }
      this._httpHeaders[property] = value;
    }
    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;
    const handleResponse = response => {
      if (response.statusCode === 404) {
        const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
        this._storedError = error;
        return;
      }
      this._setReadableStream(response);
    };
    this._request = null;
    if (this._url.protocol === "http:") {
      const http = __webpack_require__(/*! http */ "?d446");
      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
    } else {
      const https = __webpack_require__(/*! https */ "?4c38");
      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
    }
    this._request.on("error", reason => {
      this._storedError = reason;
    });
    this._request.end();
  }
}
class PDFNodeStreamFsFullReader extends BaseFullReader {
  constructor(stream) {
    super(stream);
    let path = decodeURIComponent(this._url.path);
    if (fileUriRegex.test(this._url.href)) {
      path = path.replace(/^\//, "");
    }
    const fs = __webpack_require__(/*! fs */ "?fe90");
    fs.lstat(path, (error, stat) => {
      if (error) {
        if (error.code === "ENOENT") {
          error = new _util.MissingPDFException(`Missing PDF "${path}".`);
        }
        this._storedError = error;
        this._headersCapability.reject(error);
        return;
      }
      this._contentLength = stat.size;
      this._setReadableStream(fs.createReadStream(path));
      this._headersCapability.resolve();
    });
  }
}
class PDFNodeStreamFsRangeReader extends BaseRangeReader {
  constructor(stream, start, end) {
    super(stream);
    let path = decodeURIComponent(this._url.path);
    if (fileUriRegex.test(this._url.href)) {
      path = path.replace(/^\//, "");
    }
    const fs = __webpack_require__(/*! fs */ "?fe90");
    this._setReadableStream(fs.createReadStream(path, {
      start,
      end: end - 1
    }));
  }
}

/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SVGGraphics = void 0;
var _display_utils = __w_pdfjs_require__(6);
var _util = __w_pdfjs_require__(1);
;
const SVG_DEFAULTS = {
  fontStyle: "normal",
  fontWeight: "normal",
  fillColor: "#000000"
};
const XML_NS = "http://www.w3.org/XML/1998/namespace";
const XLINK_NS = "http://www.w3.org/1999/xlink";
const LINE_CAP_STYLES = ["butt", "round", "square"];
const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
const createObjectURL = function (data, contentType = "", forceDataSchema = false) {
  if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
    return URL.createObjectURL(new Blob([data], {
      type: contentType
    }));
  }
  const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let buffer = `data:${contentType};base64,`;
  for (let i = 0, ii = data.length; i < ii; i += 3) {
    const b1 = data[i] & 0xff;
    const b2 = data[i + 1] & 0xff;
    const b3 = data[i + 2] & 0xff;
    const d1 = b1 >> 2,
      d2 = (b1 & 3) << 4 | b2 >> 4;
    const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
    const d4 = i + 2 < ii ? b3 & 0x3f : 64;
    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
  }
  return buffer;
};
const convertImgDataToPng = function () {
  const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
  const CHUNK_WRAPPER_SIZE = 12;
  const crcTable = new Int32Array(256);
  for (let i = 0; i < 256; i++) {
    let c = i;
    for (let h = 0; h < 8; h++) {
      c = c & 1 ? 0xedb88320 ^ c >> 1 & 0x7fffffff : c >> 1 & 0x7fffffff;
    }
    crcTable[i] = c;
  }
  function crc32(data, start, end) {
    let crc = -1;
    for (let i = start; i < end; i++) {
      const a = (crc ^ data[i]) & 0xff;
      const b = crcTable[a];
      crc = crc >>> 8 ^ b;
    }
    return crc ^ -1;
  }
  function writePngChunk(type, body, data, offset) {
    let p = offset;
    const len = body.length;
    data[p] = len >> 24 & 0xff;
    data[p + 1] = len >> 16 & 0xff;
    data[p + 2] = len >> 8 & 0xff;
    data[p + 3] = len & 0xff;
    p += 4;
    data[p] = type.charCodeAt(0) & 0xff;
    data[p + 1] = type.charCodeAt(1) & 0xff;
    data[p + 2] = type.charCodeAt(2) & 0xff;
    data[p + 3] = type.charCodeAt(3) & 0xff;
    p += 4;
    data.set(body, p);
    p += body.length;
    const crc = crc32(data, offset + 4, p);
    data[p] = crc >> 24 & 0xff;
    data[p + 1] = crc >> 16 & 0xff;
    data[p + 2] = crc >> 8 & 0xff;
    data[p + 3] = crc & 0xff;
  }
  function adler32(data, start, end) {
    let a = 1;
    let b = 0;
    for (let i = start; i < end; ++i) {
      a = (a + (data[i] & 0xff)) % 65521;
      b = (b + a) % 65521;
    }
    return b << 16 | a;
  }
  function deflateSync(literals) {
    if (!_util.isNodeJS) {
      return deflateSyncUncompressed(literals);
    }
    try {
      const input = parseInt(process.versions.node) >= 8 ? literals : Buffer.from(literals);
      const output = (__webpack_require__(/*! zlib */ "?afbb").deflateSync)(input, {
        level: 9
      });
      return output instanceof Uint8Array ? output : new Uint8Array(output);
    } catch (e) {
      (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
    }
    return deflateSyncUncompressed(literals);
  }
  function deflateSyncUncompressed(literals) {
    let len = literals.length;
    const maxBlockLength = 0xffff;
    const deflateBlocks = Math.ceil(len / maxBlockLength);
    const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
    let pi = 0;
    idat[pi++] = 0x78;
    idat[pi++] = 0x9c;
    let pos = 0;
    while (len > maxBlockLength) {
      idat[pi++] = 0x00;
      idat[pi++] = 0xff;
      idat[pi++] = 0xff;
      idat[pi++] = 0x00;
      idat[pi++] = 0x00;
      idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
      pi += maxBlockLength;
      pos += maxBlockLength;
      len -= maxBlockLength;
    }
    idat[pi++] = 0x01;
    idat[pi++] = len & 0xff;
    idat[pi++] = len >> 8 & 0xff;
    idat[pi++] = ~len & 0xffff & 0xff;
    idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
    idat.set(literals.subarray(pos), pi);
    pi += literals.length - pos;
    const adler = adler32(literals, 0, literals.length);
    idat[pi++] = adler >> 24 & 0xff;
    idat[pi++] = adler >> 16 & 0xff;
    idat[pi++] = adler >> 8 & 0xff;
    idat[pi++] = adler & 0xff;
    return idat;
  }
  function encode(imgData, kind, forceDataSchema, isMask) {
    const width = imgData.width;
    const height = imgData.height;
    let bitDepth, colorType, lineSize;
    const bytes = imgData.data;
    switch (kind) {
      case _util.ImageKind.GRAYSCALE_1BPP:
        colorType = 0;
        bitDepth = 1;
        lineSize = width + 7 >> 3;
        break;
      case _util.ImageKind.RGB_24BPP:
        colorType = 2;
        bitDepth = 8;
        lineSize = width * 3;
        break;
      case _util.ImageKind.RGBA_32BPP:
        colorType = 6;
        bitDepth = 8;
        lineSize = width * 4;
        break;
      default:
        throw new Error("invalid format");
    }
    const literals = new Uint8Array((1 + lineSize) * height);
    let offsetLiterals = 0,
      offsetBytes = 0;
    for (let y = 0; y < height; ++y) {
      literals[offsetLiterals++] = 0;
      literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
      offsetBytes += lineSize;
      offsetLiterals += lineSize;
    }
    if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
      offsetLiterals = 0;
      for (let y = 0; y < height; y++) {
        offsetLiterals++;
        for (let i = 0; i < lineSize; i++) {
          literals[offsetLiterals++] ^= 0xff;
        }
      }
    }
    const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
    const idat = deflateSync(literals);
    const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
    const data = new Uint8Array(pngLength);
    let offset = 0;
    data.set(PNG_HEADER, offset);
    offset += PNG_HEADER.length;
    writePngChunk("IHDR", ihdr, data, offset);
    offset += CHUNK_WRAPPER_SIZE + ihdr.length;
    writePngChunk("IDATA", idat, data, offset);
    offset += CHUNK_WRAPPER_SIZE + idat.length;
    writePngChunk("IEND", new Uint8Array(0), data, offset);
    return createObjectURL(data, "image/png", forceDataSchema);
  }
  return function convertImgDataToPng(imgData, forceDataSchema, isMask) {
    const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
    return encode(imgData, kind, forceDataSchema, isMask);
  };
}();
class SVGExtraState {
  constructor() {
    this.fontSizeScale = 1;
    this.fontWeight = SVG_DEFAULTS.fontWeight;
    this.fontSize = 0;
    this.textMatrix = _util.IDENTITY_MATRIX;
    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
    this.leading = 0;
    this.textRenderingMode = _util.TextRenderingMode.FILL;
    this.textMatrixScale = 1;
    this.x = 0;
    this.y = 0;
    this.lineX = 0;
    this.lineY = 0;
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.textHScale = 1;
    this.textRise = 0;
    this.fillColor = SVG_DEFAULTS.fillColor;
    this.strokeColor = "#000000";
    this.fillAlpha = 1;
    this.strokeAlpha = 1;
    this.lineWidth = 1;
    this.lineJoin = "";
    this.lineCap = "";
    this.miterLimit = 0;
    this.dashArray = [];
    this.dashPhase = 0;
    this.dependencies = [];
    this.activeClipUrl = null;
    this.clipGroup = null;
    this.maskId = "";
  }
  clone() {
    return Object.create(this);
  }
  setCurrentPoint(x, y) {
    this.x = x;
    this.y = y;
  }
}
function opListToTree(opList) {
  let opTree = [];
  const tmp = [];
  for (const opListElement of opList) {
    if (opListElement.fn === "save") {
      opTree.push({
        fnId: 92,
        fn: "group",
        items: []
      });
      tmp.push(opTree);
      opTree = opTree.at(-1).items;
      continue;
    }
    if (opListElement.fn === "restore") {
      opTree = tmp.pop();
    } else {
      opTree.push(opListElement);
    }
  }
  return opTree;
}
function pf(value) {
  if (Number.isInteger(value)) {
    return value.toString();
  }
  const s = value.toFixed(10);
  let i = s.length - 1;
  if (s[i] !== "0") {
    return s;
  }
  do {
    i--;
  } while (s[i] === "0");
  return s.substring(0, s[i] === "." ? i : i + 1);
}
function pm(m) {
  if (m[4] === 0 && m[5] === 0) {
    if (m[1] === 0 && m[2] === 0) {
      if (m[0] === 1 && m[3] === 1) {
        return "";
      }
      return `scale(${pf(m[0])} ${pf(m[3])})`;
    }
    if (m[0] === m[3] && m[1] === -m[2]) {
      const a = Math.acos(m[0]) * 180 / Math.PI;
      return `rotate(${pf(a)})`;
    }
  } else if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
    return `translate(${pf(m[4])} ${pf(m[5])})`;
  }
  return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;
}
let clipCount = 0;
let maskCount = 0;
let shadingCount = 0;
class SVGGraphics {
  constructor(commonObjs, objs, forceDataSchema = false) {
    (0, _display_utils.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future.");
    this.svgFactory = new _display_utils.DOMSVGFactory();
    this.current = new SVGExtraState();
    this.transformMatrix = _util.IDENTITY_MATRIX;
    this.transformStack = [];
    this.extraStack = [];
    this.commonObjs = commonObjs;
    this.objs = objs;
    this.pendingClip = null;
    this.pendingEOFill = false;
    this.embedFonts = false;
    this.embeddedFonts = Object.create(null);
    this.cssStyle = null;
    this.forceDataSchema = !!forceDataSchema;
    this._operatorIdMapping = [];
    for (const op in _util.OPS) {
      this._operatorIdMapping[_util.OPS[op]] = op;
    }
  }
  getObject(data, fallback = null) {
    if (typeof data === "string") {
      return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
    }
    return fallback;
  }
  save() {
    this.transformStack.push(this.transformMatrix);
    const old = this.current;
    this.extraStack.push(old);
    this.current = old.clone();
  }
  restore() {
    this.transformMatrix = this.transformStack.pop();
    this.current = this.extraStack.pop();
    this.pendingClip = null;
    this.tgrp = null;
  }
  group(items) {
    this.save();
    this.executeOpTree(items);
    this.restore();
  }
  loadDependencies(operatorList) {
    const fnArray = operatorList.fnArray;
    const argsArray = operatorList.argsArray;
    for (let i = 0, ii = fnArray.length; i < ii; i++) {
      if (fnArray[i] !== _util.OPS.dependency) {
        continue;
      }
      for (const obj of argsArray[i]) {
        const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
        const promise = new Promise(resolve => {
          objsPool.get(obj, resolve);
        });
        this.current.dependencies.push(promise);
      }
    }
    return Promise.all(this.current.dependencies);
  }
  transform(a, b, c, d, e, f) {
    const transformMatrix = [a, b, c, d, e, f];
    this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
    this.tgrp = null;
  }
  getSVG(operatorList, viewport) {
    this.viewport = viewport;
    const svgElement = this._initialize(viewport);
    return this.loadDependencies(operatorList).then(() => {
      this.transformMatrix = _util.IDENTITY_MATRIX;
      this.executeOpTree(this.convertOpList(operatorList));
      return svgElement;
    });
  }
  convertOpList(operatorList) {
    const operatorIdMapping = this._operatorIdMapping;
    const argsArray = operatorList.argsArray;
    const fnArray = operatorList.fnArray;
    const opList = [];
    for (let i = 0, ii = fnArray.length; i < ii; i++) {
      const fnId = fnArray[i];
      opList.push({
        fnId,
        fn: operatorIdMapping[fnId],
        args: argsArray[i]
      });
    }
    return opListToTree(opList);
  }
  executeOpTree(opTree) {
    for (const opTreeElement of opTree) {
      const fn = opTreeElement.fn;
      const fnId = opTreeElement.fnId;
      const args = opTreeElement.args;
      switch (fnId | 0) {
        case _util.OPS.beginText:
          this.beginText();
          break;
        case _util.OPS.dependency:
          break;
        case _util.OPS.setLeading:
          this.setLeading(args);
          break;
        case _util.OPS.setLeadingMoveText:
          this.setLeadingMoveText(args[0], args[1]);
          break;
        case _util.OPS.setFont:
          this.setFont(args);
          break;
        case _util.OPS.showText:
          this.showText(args[0]);
          break;
        case _util.OPS.showSpacedText:
          this.showText(args[0]);
          break;
        case _util.OPS.endText:
          this.endText();
          break;
        case _util.OPS.moveText:
          this.moveText(args[0], args[1]);
          break;
        case _util.OPS.setCharSpacing:
          this.setCharSpacing(args[0]);
          break;
        case _util.OPS.setWordSpacing:
          this.setWordSpacing(args[0]);
          break;
        case _util.OPS.setHScale:
          this.setHScale(args[0]);
          break;
        case _util.OPS.setTextMatrix:
          this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
          break;
        case _util.OPS.setTextRise:
          this.setTextRise(args[0]);
          break;
        case _util.OPS.setTextRenderingMode:
          this.setTextRenderingMode(args[0]);
          break;
        case _util.OPS.setLineWidth:
          this.setLineWidth(args[0]);
          break;
        case _util.OPS.setLineJoin:
          this.setLineJoin(args[0]);
          break;
        case _util.OPS.setLineCap:
          this.setLineCap(args[0]);
          break;
        case _util.OPS.setMiterLimit:
          this.setMiterLimit(args[0]);
          break;
        case _util.OPS.setFillRGBColor:
          this.setFillRGBColor(args[0], args[1], args[2]);
          break;
        case _util.OPS.setStrokeRGBColor:
          this.setStrokeRGBColor(args[0], args[1], args[2]);
          break;
        case _util.OPS.setStrokeColorN:
          this.setStrokeColorN(args);
          break;
        case _util.OPS.setFillColorN:
          this.setFillColorN(args);
          break;
        case _util.OPS.shadingFill:
          this.shadingFill(args[0]);
          break;
        case _util.OPS.setDash:
          this.setDash(args[0], args[1]);
          break;
        case _util.OPS.setRenderingIntent:
          this.setRenderingIntent(args[0]);
          break;
        case _util.OPS.setFlatness:
          this.setFlatness(args[0]);
          break;
        case _util.OPS.setGState:
          this.setGState(args[0]);
          break;
        case _util.OPS.fill:
          this.fill();
          break;
        case _util.OPS.eoFill:
          this.eoFill();
          break;
        case _util.OPS.stroke:
          this.stroke();
          break;
        case _util.OPS.fillStroke:
          this.fillStroke();
          break;
        case _util.OPS.eoFillStroke:
          this.eoFillStroke();
          break;
        case _util.OPS.clip:
          this.clip("nonzero");
          break;
        case _util.OPS.eoClip:
          this.clip("evenodd");
          break;
        case _util.OPS.paintSolidColorImageMask:
          this.paintSolidColorImageMask();
          break;
        case _util.OPS.paintImageXObject:
          this.paintImageXObject(args[0]);
          break;
        case _util.OPS.paintInlineImageXObject:
          this.paintInlineImageXObject(args[0]);
          break;
        case _util.OPS.paintImageMaskXObject:
          this.paintImageMaskXObject(args[0]);
          break;
        case _util.OPS.paintFormXObjectBegin:
          this.paintFormXObjectBegin(args[0], args[1]);
          break;
        case _util.OPS.paintFormXObjectEnd:
          this.paintFormXObjectEnd();
          break;
        case _util.OPS.closePath:
          this.closePath();
          break;
        case _util.OPS.closeStroke:
          this.closeStroke();
          break;
        case _util.OPS.closeFillStroke:
          this.closeFillStroke();
          break;
        case _util.OPS.closeEOFillStroke:
          this.closeEOFillStroke();
          break;
        case _util.OPS.nextLine:
          this.nextLine();
          break;
        case _util.OPS.transform:
          this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
          break;
        case _util.OPS.constructPath:
          this.constructPath(args[0], args[1]);
          break;
        case _util.OPS.endPath:
          this.endPath();
          break;
        case 92:
          this.group(opTreeElement.items);
          break;
        default:
          (0, _util.warn)(`Unimplemented operator ${fn}`);
          break;
      }
    }
  }
  setWordSpacing(wordSpacing) {
    this.current.wordSpacing = wordSpacing;
  }
  setCharSpacing(charSpacing) {
    this.current.charSpacing = charSpacing;
  }
  nextLine() {
    this.moveText(0, this.current.leading);
  }
  setTextMatrix(a, b, c, d, e, f) {
    const current = this.current;
    current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
    current.textMatrixScale = Math.hypot(a, b);
    current.x = current.lineX = 0;
    current.y = current.lineY = 0;
    current.xcoords = [];
    current.ycoords = [];
    current.tspan = this.svgFactory.createElement("svg:tspan");
    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
    current.tspan.setAttributeNS(null, "y", pf(-current.y));
    current.txtElement = this.svgFactory.createElement("svg:text");
    current.txtElement.append(current.tspan);
  }
  beginText() {
    const current = this.current;
    current.x = current.lineX = 0;
    current.y = current.lineY = 0;
    current.textMatrix = _util.IDENTITY_MATRIX;
    current.lineMatrix = _util.IDENTITY_MATRIX;
    current.textMatrixScale = 1;
    current.tspan = this.svgFactory.createElement("svg:tspan");
    current.txtElement = this.svgFactory.createElement("svg:text");
    current.txtgrp = this.svgFactory.createElement("svg:g");
    current.xcoords = [];
    current.ycoords = [];
  }
  moveText(x, y) {
    const current = this.current;
    current.x = current.lineX += x;
    current.y = current.lineY += y;
    current.xcoords = [];
    current.ycoords = [];
    current.tspan = this.svgFactory.createElement("svg:tspan");
    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
    current.tspan.setAttributeNS(null, "y", pf(-current.y));
  }
  showText(glyphs) {
    const current = this.current;
    const font = current.font;
    const fontSize = current.fontSize;
    if (fontSize === 0) {
      return;
    }
    const fontSizeScale = current.fontSizeScale;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const fontDirection = current.fontDirection;
    const textHScale = current.textHScale * fontDirection;
    const vertical = font.vertical;
    const spacingDir = vertical ? 1 : -1;
    const defaultVMetrics = font.defaultVMetrics;
    const widthAdvanceScale = fontSize * current.fontMatrix[0];
    let x = 0;
    for (const glyph of glyphs) {
      if (glyph === null) {
        x += fontDirection * wordSpacing;
        continue;
      } else if (typeof glyph === "number") {
        x += spacingDir * glyph * fontSize / 1000;
        continue;
      }
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const character = glyph.fontChar;
      let scaledX, scaledY;
      let width = glyph.width;
      if (vertical) {
        let vx;
        const vmetric = glyph.vmetric || defaultVMetrics;
        vx = glyph.vmetric ? vmetric[1] : width * 0.5;
        vx = -vx * widthAdvanceScale;
        const vy = vmetric[2] * widthAdvanceScale;
        width = vmetric ? -vmetric[0] : width;
        scaledX = vx / fontSizeScale;
        scaledY = (x + vy) / fontSizeScale;
      } else {
        scaledX = x / fontSizeScale;
        scaledY = 0;
      }
      if (glyph.isInFont || font.missingFile) {
        current.xcoords.push(current.x + scaledX);
        if (vertical) {
          current.ycoords.push(-current.y + scaledY);
        }
        current.tspan.textContent += character;
      } else {}
      const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
      x += charWidth;
    }
    current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
    if (vertical) {
      current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
    } else {
      current.tspan.setAttributeNS(null, "y", pf(-current.y));
    }
    if (vertical) {
      current.y -= x;
    } else {
      current.x += x * textHScale;
    }
    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
    if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
      current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
    }
    if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
      current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
    }
    const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
    if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
      if (current.fillColor !== SVG_DEFAULTS.fillColor) {
        current.tspan.setAttributeNS(null, "fill", current.fillColor);
      }
      if (current.fillAlpha < 1) {
        current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
      }
    } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {
      current.tspan.setAttributeNS(null, "fill", "transparent");
    } else {
      current.tspan.setAttributeNS(null, "fill", "none");
    }
    if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
      const lineWidthScale = 1 / (current.textMatrixScale || 1);
      this._setStrokeAttributes(current.tspan, lineWidthScale);
    }
    let textMatrix = current.textMatrix;
    if (current.textRise !== 0) {
      textMatrix = textMatrix.slice();
      textMatrix[5] += current.textRise;
    }
    current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
    current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
    current.txtElement.append(current.tspan);
    current.txtgrp.append(current.txtElement);
    this._ensureTransformGroup().append(current.txtElement);
  }
  setLeadingMoveText(x, y) {
    this.setLeading(-y);
    this.moveText(x, y);
  }
  addFontStyle(fontObj) {
    if (!fontObj.data) {
      throw new Error("addFontStyle: No font data available, " + 'ensure that the "fontExtraProperties" API parameter is set.');
    }
    if (!this.cssStyle) {
      this.cssStyle = this.svgFactory.createElement("svg:style");
      this.cssStyle.setAttributeNS(null, "type", "text/css");
      this.defs.append(this.cssStyle);
    }
    const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
    this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}";` + ` src: url(${url}); }\n`;
  }
  setFont(details) {
    const current = this.current;
    const fontObj = this.commonObjs.get(details[0]);
    let size = details[1];
    current.font = fontObj;
    if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
      this.addFontStyle(fontObj);
      this.embeddedFonts[fontObj.loadedName] = fontObj;
    }
    current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
    let bold = "normal";
    if (fontObj.black) {
      bold = "900";
    } else if (fontObj.bold) {
      bold = "bold";
    }
    const italic = fontObj.italic ? "italic" : "normal";
    if (size < 0) {
      size = -size;
      current.fontDirection = -1;
    } else {
      current.fontDirection = 1;
    }
    current.fontSize = size;
    current.fontFamily = fontObj.loadedName;
    current.fontWeight = bold;
    current.fontStyle = italic;
    current.tspan = this.svgFactory.createElement("svg:tspan");
    current.tspan.setAttributeNS(null, "y", pf(-current.y));
    current.xcoords = [];
    current.ycoords = [];
  }
  endText() {
    const current = this.current;
    if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {
      current.element = current.txtElement;
      this.clip("nonzero");
      this.endPath();
    }
  }
  setLineWidth(width) {
    if (width > 0) {
      this.current.lineWidth = width;
    }
  }
  setLineCap(style) {
    this.current.lineCap = LINE_CAP_STYLES[style];
  }
  setLineJoin(style) {
    this.current.lineJoin = LINE_JOIN_STYLES[style];
  }
  setMiterLimit(limit) {
    this.current.miterLimit = limit;
  }
  setStrokeAlpha(strokeAlpha) {
    this.current.strokeAlpha = strokeAlpha;
  }
  setStrokeRGBColor(r, g, b) {
    this.current.strokeColor = _util.Util.makeHexColor(r, g, b);
  }
  setFillAlpha(fillAlpha) {
    this.current.fillAlpha = fillAlpha;
  }
  setFillRGBColor(r, g, b) {
    this.current.fillColor = _util.Util.makeHexColor(r, g, b);
    this.current.tspan = this.svgFactory.createElement("svg:tspan");
    this.current.xcoords = [];
    this.current.ycoords = [];
  }
  setStrokeColorN(args) {
    this.current.strokeColor = this._makeColorN_Pattern(args);
  }
  setFillColorN(args) {
    this.current.fillColor = this._makeColorN_Pattern(args);
  }
  shadingFill(args) {
    const {
      width,
      height
    } = this.viewport;
    const inv = _util.Util.inverseTransform(this.transformMatrix);
    const [x0, y0, x1, y1] = _util.Util.getAxialAlignedBoundingBox([0, 0, width, height], inv);
    const rect = this.svgFactory.createElement("svg:rect");
    rect.setAttributeNS(null, "x", x0);
    rect.setAttributeNS(null, "y", y0);
    rect.setAttributeNS(null, "width", x1 - x0);
    rect.setAttributeNS(null, "height", y1 - y0);
    rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
    if (this.current.fillAlpha < 1) {
      rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
    }
    this._ensureTransformGroup().append(rect);
  }
  _makeColorN_Pattern(args) {
    if (args[0] === "TilingPattern") {
      return this._makeTilingPattern(args);
    }
    return this._makeShadingPattern(args);
  }
  _makeTilingPattern(args) {
    const color = args[1];
    const operatorList = args[2];
    const matrix = args[3] || _util.IDENTITY_MATRIX;
    const [x0, y0, x1, y1] = args[4];
    const xstep = args[5];
    const ystep = args[6];
    const paintType = args[7];
    const tilingId = `shading${shadingCount++}`;
    const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]);
    const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);
    const txstep = xstep * xscale;
    const tystep = ystep * yscale;
    const tiling = this.svgFactory.createElement("svg:pattern");
    tiling.setAttributeNS(null, "id", tilingId);
    tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
    tiling.setAttributeNS(null, "width", txstep);
    tiling.setAttributeNS(null, "height", tystep);
    tiling.setAttributeNS(null, "x", `${tx0}`);
    tiling.setAttributeNS(null, "y", `${ty0}`);
    const svg = this.svg;
    const transformMatrix = this.transformMatrix;
    const fillColor = this.current.fillColor;
    const strokeColor = this.current.strokeColor;
    const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
    this.svg = bbox;
    this.transformMatrix = matrix;
    if (paintType === 2) {
      const cssColor = _util.Util.makeHexColor(...color);
      this.current.fillColor = cssColor;
      this.current.strokeColor = cssColor;
    }
    this.executeOpTree(this.convertOpList(operatorList));
    this.svg = svg;
    this.transformMatrix = transformMatrix;
    this.current.fillColor = fillColor;
    this.current.strokeColor = strokeColor;
    tiling.append(bbox.childNodes[0]);
    this.defs.append(tiling);
    return `url(#${tilingId})`;
  }
  _makeShadingPattern(args) {
    if (typeof args === "string") {
      args = this.objs.get(args);
    }
    switch (args[0]) {
      case "RadialAxial":
        const shadingId = `shading${shadingCount++}`;
        const colorStops = args[3];
        let gradient;
        switch (args[1]) {
          case "axial":
            const point0 = args[4];
            const point1 = args[5];
            gradient = this.svgFactory.createElement("svg:linearGradient");
            gradient.setAttributeNS(null, "id", shadingId);
            gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
            gradient.setAttributeNS(null, "x1", point0[0]);
            gradient.setAttributeNS(null, "y1", point0[1]);
            gradient.setAttributeNS(null, "x2", point1[0]);
            gradient.setAttributeNS(null, "y2", point1[1]);
            break;
          case "radial":
            const focalPoint = args[4];
            const circlePoint = args[5];
            const focalRadius = args[6];
            const circleRadius = args[7];
            gradient = this.svgFactory.createElement("svg:radialGradient");
            gradient.setAttributeNS(null, "id", shadingId);
            gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
            gradient.setAttributeNS(null, "cx", circlePoint[0]);
            gradient.setAttributeNS(null, "cy", circlePoint[1]);
            gradient.setAttributeNS(null, "r", circleRadius);
            gradient.setAttributeNS(null, "fx", focalPoint[0]);
            gradient.setAttributeNS(null, "fy", focalPoint[1]);
            gradient.setAttributeNS(null, "fr", focalRadius);
            break;
          default:
            throw new Error(`Unknown RadialAxial type: ${args[1]}`);
        }
        for (const colorStop of colorStops) {
          const stop = this.svgFactory.createElement("svg:stop");
          stop.setAttributeNS(null, "offset", colorStop[0]);
          stop.setAttributeNS(null, "stop-color", colorStop[1]);
          gradient.append(stop);
        }
        this.defs.append(gradient);
        return `url(#${shadingId})`;
      case "Mesh":
        (0, _util.warn)("Unimplemented pattern Mesh");
        return null;
      case "Dummy":
        return "hotpink";
      default:
        throw new Error(`Unknown IR type: ${args[0]}`);
    }
  }
  setDash(dashArray, dashPhase) {
    this.current.dashArray = dashArray;
    this.current.dashPhase = dashPhase;
  }
  constructPath(ops, args) {
    const current = this.current;
    let x = current.x,
      y = current.y;
    let d = [];
    let j = 0;
    for (const op of ops) {
      switch (op | 0) {
        case _util.OPS.rectangle:
          x = args[j++];
          y = args[j++];
          const width = args[j++];
          const height = args[j++];
          const xw = x + width;
          const yh = y + height;
          d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
          break;
        case _util.OPS.moveTo:
          x = args[j++];
          y = args[j++];
          d.push("M", pf(x), pf(y));
          break;
        case _util.OPS.lineTo:
          x = args[j++];
          y = args[j++];
          d.push("L", pf(x), pf(y));
          break;
        case _util.OPS.curveTo:
          x = args[j + 4];
          y = args[j + 5];
          d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
          j += 6;
          break;
        case _util.OPS.curveTo2:
          d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
          x = args[j + 2];
          y = args[j + 3];
          j += 4;
          break;
        case _util.OPS.curveTo3:
          x = args[j + 2];
          y = args[j + 3];
          d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
          j += 4;
          break;
        case _util.OPS.closePath:
          d.push("Z");
          break;
      }
    }
    d = d.join(" ");
    if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {
      d = current.path.getAttributeNS(null, "d") + d;
    } else {
      current.path = this.svgFactory.createElement("svg:path");
      this._ensureTransformGroup().append(current.path);
    }
    current.path.setAttributeNS(null, "d", d);
    current.path.setAttributeNS(null, "fill", "none");
    current.element = current.path;
    current.setCurrentPoint(x, y);
  }
  endPath() {
    const current = this.current;
    current.path = null;
    if (!this.pendingClip) {
      return;
    }
    if (!current.element) {
      this.pendingClip = null;
      return;
    }
    const clipId = `clippath${clipCount++}`;
    const clipPath = this.svgFactory.createElement("svg:clipPath");
    clipPath.setAttributeNS(null, "id", clipId);
    clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
    const clipElement = current.element.cloneNode(true);
    if (this.pendingClip === "evenodd") {
      clipElement.setAttributeNS(null, "clip-rule", "evenodd");
    } else {
      clipElement.setAttributeNS(null, "clip-rule", "nonzero");
    }
    this.pendingClip = null;
    clipPath.append(clipElement);
    this.defs.append(clipPath);
    if (current.activeClipUrl) {
      current.clipGroup = null;
      for (const prev of this.extraStack) {
        prev.clipGroup = null;
      }
      clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
    }
    current.activeClipUrl = `url(#${clipId})`;
    this.tgrp = null;
  }
  clip(type) {
    this.pendingClip = type;
  }
  closePath() {
    const current = this.current;
    if (current.path) {
      const d = `${current.path.getAttributeNS(null, "d")}Z`;
      current.path.setAttributeNS(null, "d", d);
    }
  }
  setLeading(leading) {
    this.current.leading = -leading;
  }
  setTextRise(textRise) {
    this.current.textRise = textRise;
  }
  setTextRenderingMode(textRenderingMode) {
    this.current.textRenderingMode = textRenderingMode;
  }
  setHScale(scale) {
    this.current.textHScale = scale / 100;
  }
  setRenderingIntent(intent) {}
  setFlatness(flatness) {}
  setGState(states) {
    for (const [key, value] of states) {
      switch (key) {
        case "LW":
          this.setLineWidth(value);
          break;
        case "LC":
          this.setLineCap(value);
          break;
        case "LJ":
          this.setLineJoin(value);
          break;
        case "ML":
          this.setMiterLimit(value);
          break;
        case "D":
          this.setDash(value[0], value[1]);
          break;
        case "RI":
          this.setRenderingIntent(value);
          break;
        case "FL":
          this.setFlatness(value);
          break;
        case "Font":
          this.setFont(value);
          break;
        case "CA":
          this.setStrokeAlpha(value);
          break;
        case "ca":
          this.setFillAlpha(value);
          break;
        default:
          (0, _util.warn)(`Unimplemented graphic state operator ${key}`);
          break;
      }
    }
  }
  fill() {
    const current = this.current;
    if (current.element) {
      current.element.setAttributeNS(null, "fill", current.fillColor);
      current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
      this.endPath();
    }
  }
  stroke() {
    const current = this.current;
    if (current.element) {
      this._setStrokeAttributes(current.element);
      current.element.setAttributeNS(null, "fill", "none");
      this.endPath();
    }
  }
  _setStrokeAttributes(element, lineWidthScale = 1) {
    const current = this.current;
    let dashArray = current.dashArray;
    if (lineWidthScale !== 1 && dashArray.length > 0) {
      dashArray = dashArray.map(function (value) {
        return lineWidthScale * value;
      });
    }
    element.setAttributeNS(null, "stroke", current.strokeColor);
    element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
    element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
    element.setAttributeNS(null, "stroke-linecap", current.lineCap);
    element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
    element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
    element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
    element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
  }
  eoFill() {
    this.current.element?.setAttributeNS(null, "fill-rule", "evenodd");
    this.fill();
  }
  fillStroke() {
    this.stroke();
    this.fill();
  }
  eoFillStroke() {
    this.current.element?.setAttributeNS(null, "fill-rule", "evenodd");
    this.fillStroke();
  }
  closeStroke() {
    this.closePath();
    this.stroke();
  }
  closeFillStroke() {
    this.closePath();
    this.fillStroke();
  }
  closeEOFillStroke() {
    this.closePath();
    this.eoFillStroke();
  }
  paintSolidColorImageMask() {
    const rect = this.svgFactory.createElement("svg:rect");
    rect.setAttributeNS(null, "x", "0");
    rect.setAttributeNS(null, "y", "0");
    rect.setAttributeNS(null, "width", "1px");
    rect.setAttributeNS(null, "height", "1px");
    rect.setAttributeNS(null, "fill", this.current.fillColor);
    this._ensureTransformGroup().append(rect);
  }
  paintImageXObject(objId) {
    const imgData = this.getObject(objId);
    if (!imgData) {
      (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);
      return;
    }
    this.paintInlineImageXObject(imgData);
  }
  paintInlineImageXObject(imgData, mask) {
    const width = imgData.width;
    const height = imgData.height;
    const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
    const cliprect = this.svgFactory.createElement("svg:rect");
    cliprect.setAttributeNS(null, "x", "0");
    cliprect.setAttributeNS(null, "y", "0");
    cliprect.setAttributeNS(null, "width", pf(width));
    cliprect.setAttributeNS(null, "height", pf(height));
    this.current.element = cliprect;
    this.clip("nonzero");
    const imgEl = this.svgFactory.createElement("svg:image");
    imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
    imgEl.setAttributeNS(null, "x", "0");
    imgEl.setAttributeNS(null, "y", pf(-height));
    imgEl.setAttributeNS(null, "width", pf(width) + "px");
    imgEl.setAttributeNS(null, "height", pf(height) + "px");
    imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);
    if (mask) {
      mask.append(imgEl);
    } else {
      this._ensureTransformGroup().append(imgEl);
    }
  }
  paintImageMaskXObject(img) {
    const imgData = this.getObject(img.data, img);
    if (imgData.bitmap) {
      (0, _util.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, " + "ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");
      return;
    }
    const current = this.current;
    const width = imgData.width;
    const height = imgData.height;
    const fillColor = current.fillColor;
    current.maskId = `mask${maskCount++}`;
    const mask = this.svgFactory.createElement("svg:mask");
    mask.setAttributeNS(null, "id", current.maskId);
    const rect = this.svgFactory.createElement("svg:rect");
    rect.setAttributeNS(null, "x", "0");
    rect.setAttributeNS(null, "y", "0");
    rect.setAttributeNS(null, "width", pf(width));
    rect.setAttributeNS(null, "height", pf(height));
    rect.setAttributeNS(null, "fill", fillColor);
    rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
    this.defs.append(mask);
    this._ensureTransformGroup().append(rect);
    this.paintInlineImageXObject(imgData, mask);
  }
  paintFormXObjectBegin(matrix, bbox) {
    if (Array.isArray(matrix) && matrix.length === 6) {
      this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
    }
    if (bbox) {
      const width = bbox[2] - bbox[0];
      const height = bbox[3] - bbox[1];
      const cliprect = this.svgFactory.createElement("svg:rect");
      cliprect.setAttributeNS(null, "x", bbox[0]);
      cliprect.setAttributeNS(null, "y", bbox[1]);
      cliprect.setAttributeNS(null, "width", pf(width));
      cliprect.setAttributeNS(null, "height", pf(height));
      this.current.element = cliprect;
      this.clip("nonzero");
      this.endPath();
    }
  }
  paintFormXObjectEnd() {}
  _initialize(viewport) {
    const svg = this.svgFactory.create(viewport.width, viewport.height);
    const definitions = this.svgFactory.createElement("svg:defs");
    svg.append(definitions);
    this.defs = definitions;
    const rootGroup = this.svgFactory.createElement("svg:g");
    rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
    svg.append(rootGroup);
    this.svg = rootGroup;
    return svg;
  }
  _ensureClipGroup() {
    if (!this.current.clipGroup) {
      const clipGroup = this.svgFactory.createElement("svg:g");
      clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
      this.svg.append(clipGroup);
      this.current.clipGroup = clipGroup;
    }
    return this.current.clipGroup;
  }
  _ensureTransformGroup() {
    if (!this.tgrp) {
      this.tgrp = this.svgFactory.createElement("svg:g");
      this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
      if (this.current.activeClipUrl) {
        this._ensureClipGroup().append(this.tgrp);
      } else {
        this.svg.append(this.tgrp);
      }
    }
    return this.tgrp;
  }
}
exports.SVGGraphics = SVGGraphics;

/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XfaText = void 0;
class XfaText {
  static textContent(xfa) {
    const items = [];
    const output = {
      items,
      styles: Object.create(null)
    };
    function walk(node) {
      if (!node) {
        return;
      }
      let str = null;
      const name = node.name;
      if (name === "#text") {
        str = node.value;
      } else if (!XfaText.shouldBuildText(name)) {
        return;
      } else if (node?.attributes?.textContent) {
        str = node.attributes.textContent;
      } else if (node.value) {
        str = node.value;
      }
      if (str !== null) {
        items.push({
          str
        });
      }
      if (!node.children) {
        return;
      }
      for (const child of node.children) {
        walk(child);
      }
    }
    walk(xfa);
    return output;
  }
  static shouldBuildText(name) {
    return !(name === "textarea" || name === "input" || name === "option" || name === "select");
  }
}
exports.XfaText = XfaText;

/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TextLayerRenderTask = void 0;
exports.renderTextLayer = renderTextLayer;
exports.updateTextLayer = updateTextLayer;
var _util = __w_pdfjs_require__(1);
var _display_utils = __w_pdfjs_require__(6);
const MAX_TEXT_DIVS_TO_RENDER = 100000;
const DEFAULT_FONT_SIZE = 30;
const DEFAULT_FONT_ASCENT = 0.8;
const ascentCache = new Map();
function getCtx(size, isOffscreenCanvasSupported) {
  let ctx;
  if (isOffscreenCanvasSupported && _util.FeatureTest.isOffscreenCanvasSupported) {
    ctx = new OffscreenCanvas(size, size).getContext("2d", {
      alpha: false
    });
  } else {
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = size;
    ctx = canvas.getContext("2d", {
      alpha: false
    });
  }
  return ctx;
}
function getAscent(fontFamily, isOffscreenCanvasSupported) {
  const cachedAscent = ascentCache.get(fontFamily);
  if (cachedAscent) {
    return cachedAscent;
  }
  const ctx = getCtx(DEFAULT_FONT_SIZE, isOffscreenCanvasSupported);
  ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
  const metrics = ctx.measureText("");
  let ascent = metrics.fontBoundingBoxAscent;
  let descent = Math.abs(metrics.fontBoundingBoxDescent);
  if (ascent) {
    const ratio = ascent / (ascent + descent);
    ascentCache.set(fontFamily, ratio);
    ctx.canvas.width = ctx.canvas.height = 0;
    return ratio;
  }
  ctx.strokeStyle = "red";
  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
  ctx.strokeText("g", 0, 0);
  let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
  descent = 0;
  for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
    if (pixels[i] > 0) {
      descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
      break;
    }
  }
  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
  ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
  pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
  ascent = 0;
  for (let i = 0, ii = pixels.length; i < ii; i += 4) {
    if (pixels[i] > 0) {
      ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
      break;
    }
  }
  ctx.canvas.width = ctx.canvas.height = 0;
  if (ascent) {
    const ratio = ascent / (ascent + descent);
    ascentCache.set(fontFamily, ratio);
    return ratio;
  }
  ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
  return DEFAULT_FONT_ASCENT;
}
function appendText(task, geom, styles) {
  const textDiv = document.createElement("span");
  const textDivProperties = {
    angle: 0,
    canvasWidth: 0,
    hasText: geom.str !== "",
    hasEOL: geom.hasEOL,
    fontSize: 0
  };
  task._textDivs.push(textDiv);
  const tx = _util.Util.transform(task._transform, geom.transform);
  let angle = Math.atan2(tx[1], tx[0]);
  const style = styles[geom.fontName];
  if (style.vertical) {
    angle += Math.PI / 2;
  }
  const fontHeight = Math.hypot(tx[2], tx[3]);
  const fontAscent = fontHeight * getAscent(style.fontFamily, task._isOffscreenCanvasSupported);
  let left, top;
  if (angle === 0) {
    left = tx[4];
    top = tx[5] - fontAscent;
  } else {
    left = tx[4] + fontAscent * Math.sin(angle);
    top = tx[5] - fontAscent * Math.cos(angle);
  }
  const scaleFactorStr = "calc(var(--scale-factor)*";
  const divStyle = textDiv.style;
  if (task._container === task._rootContainer) {
    divStyle.left = `${(100 * left / task._pageWidth).toFixed(2)}%`;
    divStyle.top = `${(100 * top / task._pageHeight).toFixed(2)}%`;
  } else {
    divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;
    divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;
  }
  divStyle.fontSize = `${scaleFactorStr}${fontHeight.toFixed(2)}px)`;
  divStyle.fontFamily = style.fontFamily;
  textDivProperties.fontSize = fontHeight;
  textDiv.setAttribute("role", "presentation");
  textDiv.textContent = geom.str;
  textDiv.dir = geom.dir;
  if (task._fontInspectorEnabled) {
    textDiv.dataset.fontName = geom.fontName;
  }
  if (angle !== 0) {
    textDivProperties.angle = angle * (180 / Math.PI);
  }
  let shouldScaleText = false;
  if (geom.str.length > 1) {
    shouldScaleText = true;
  } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
    const absScaleX = Math.abs(geom.transform[0]),
      absScaleY = Math.abs(geom.transform[3]);
    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
      shouldScaleText = true;
    }
  }
  if (shouldScaleText) {
    textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;
  }
  task._textDivProperties.set(textDiv, textDivProperties);
  if (task._isReadableStream) {
    task._layoutText(textDiv);
  }
}
function layout(params) {
  const {
    div,
    scale,
    properties,
    ctx,
    prevFontSize,
    prevFontFamily
  } = params;
  const {
    style
  } = div;
  let transform = "";
  if (properties.canvasWidth !== 0 && properties.hasText) {
    const {
      fontFamily
    } = style;
    const {
      canvasWidth,
      fontSize
    } = properties;
    if (prevFontSize !== fontSize || prevFontFamily !== fontFamily) {
      ctx.font = `${fontSize * scale}px ${fontFamily}`;
      params.prevFontSize = fontSize;
      params.prevFontFamily = fontFamily;
    }
    const {
      width
    } = ctx.measureText(div.textContent);
    if (width > 0) {
      transform = `scaleX(${canvasWidth * scale / width})`;
    }
  }
  if (properties.angle !== 0) {
    transform = `rotate(${properties.angle}deg) ${transform}`;
  }
  if (transform.length > 0) {
    style.transform = transform;
  }
}
function render(task) {
  if (task._canceled) {
    return;
  }
  const textDivs = task._textDivs;
  const capability = task._capability;
  const textDivsLength = textDivs.length;
  if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
    capability.resolve();
    return;
  }
  if (!task._isReadableStream) {
    for (const textDiv of textDivs) {
      task._layoutText(textDiv);
    }
  }
  capability.resolve();
}
class TextLayerRenderTask {
  constructor({
    textContentSource,
    container,
    viewport,
    textDivs,
    textDivProperties,
    textContentItemsStr,
    isOffscreenCanvasSupported
  }) {
    this._textContentSource = textContentSource;
    this._isReadableStream = textContentSource instanceof ReadableStream;
    this._container = this._rootContainer = container;
    this._textDivs = textDivs || [];
    this._textContentItemsStr = textContentItemsStr || [];
    this._isOffscreenCanvasSupported = isOffscreenCanvasSupported;
    this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
    this._reader = null;
    this._textDivProperties = textDivProperties || new WeakMap();
    this._canceled = false;
    this._capability = new _util.PromiseCapability();
    this._layoutTextParams = {
      prevFontSize: null,
      prevFontFamily: null,
      div: null,
      scale: viewport.scale * (globalThis.devicePixelRatio || 1),
      properties: null,
      ctx: getCtx(0, isOffscreenCanvasSupported)
    };
    const {
      pageWidth,
      pageHeight,
      pageX,
      pageY
    } = viewport.rawDims;
    this._transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];
    this._pageWidth = pageWidth;
    this._pageHeight = pageHeight;
    (0, _display_utils.setLayerDimensions)(container, viewport);
    this._capability.promise.finally(() => {
      this._layoutTextParams = null;
    }).catch(() => {});
  }
  get promise() {
    return this._capability.promise;
  }
  cancel() {
    this._canceled = true;
    if (this._reader) {
      this._reader.cancel(new _util.AbortException("TextLayer task cancelled.")).catch(() => {});
      this._reader = null;
    }
    this._capability.reject(new _util.AbortException("TextLayer task cancelled."));
  }
  _processItems(items, styleCache) {
    for (const item of items) {
      if (item.str === undefined) {
        if (item.type === "beginMarkedContentProps" || item.type === "beginMarkedContent") {
          const parent = this._container;
          this._container = document.createElement("span");
          this._container.classList.add("markedContent");
          if (item.id !== null) {
            this._container.setAttribute("id", `${item.id}`);
          }
          parent.append(this._container);
        } else if (item.type === "endMarkedContent") {
          this._container = this._container.parentNode;
        }
        continue;
      }
      this._textContentItemsStr.push(item.str);
      appendText(this, item, styleCache);
    }
  }
  _layoutText(textDiv) {
    const textDivProperties = this._layoutTextParams.properties = this._textDivProperties.get(textDiv);
    this._layoutTextParams.div = textDiv;
    layout(this._layoutTextParams);
    if (textDivProperties.hasText) {
      this._container.append(textDiv);
    }
    if (textDivProperties.hasEOL) {
      const br = document.createElement("br");
      br.setAttribute("role", "presentation");
      this._container.append(br);
    }
  }
  _render() {
    const capability = new _util.PromiseCapability();
    let styleCache = Object.create(null);
    if (this._isReadableStream) {
      const pump = () => {
        this._reader.read().then(({
          value,
          done
        }) => {
          if (done) {
            capability.resolve();
            return;
          }
          Object.assign(styleCache, value.styles);
          this._processItems(value.items, styleCache);
          pump();
        }, capability.reject);
      };
      this._reader = this._textContentSource.getReader();
      pump();
    } else if (this._textContentSource) {
      const {
        items,
        styles
      } = this._textContentSource;
      this._processItems(items, styles);
      capability.resolve();
    } else {
      throw new Error('No "textContentSource" parameter specified.');
    }
    capability.promise.then(() => {
      styleCache = null;
      render(this);
    }, this._capability.reject);
  }
}
exports.TextLayerRenderTask = TextLayerRenderTask;
function renderTextLayer(params) {
  if (!params.textContentSource && (params.textContent || params.textContentStream)) {
    (0, _display_utils.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters " + "will be removed in the future, please use `textContentSource` instead.");
    params.textContentSource = params.textContent || params.textContentStream;
  }
  const {
    container,
    viewport
  } = params;
  const style = getComputedStyle(container);
  const visibility = style.getPropertyValue("visibility");
  const scaleFactor = parseFloat(style.getPropertyValue("--scale-factor"));
  if (visibility === "visible" && (!scaleFactor || Math.abs(scaleFactor - viewport.scale) > 1e-5)) {
    console.error("The `--scale-factor` CSS-variable must be set, " + "to the same value as `viewport.scale`, " + "either on the `container`-element itself or higher up in the DOM.");
  }
  const task = new TextLayerRenderTask(params);
  task._render();
  return task;
}
function updateTextLayer({
  container,
  viewport,
  textDivs,
  textDivProperties,
  isOffscreenCanvasSupported,
  mustRotate = true,
  mustRescale = true
}) {
  if (mustRotate) {
    (0, _display_utils.setLayerDimensions)(container, {
      rotation: viewport.rotation
    });
  }
  if (mustRescale) {
    const ctx = getCtx(0, isOffscreenCanvasSupported);
    const scale = viewport.scale * (globalThis.devicePixelRatio || 1);
    const params = {
      prevFontSize: null,
      prevFontFamily: null,
      div: null,
      scale,
      properties: null,
      ctx
    };
    for (const div of textDivs) {
      params.properties = textDivProperties.get(div);
      params.div = div;
      layout(params);
    }
  }
}

/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AnnotationEditorLayer = void 0;
var _util = __w_pdfjs_require__(1);
var _editor = __w_pdfjs_require__(4);
var _freetext = __w_pdfjs_require__(28);
var _ink = __w_pdfjs_require__(33);
var _display_utils = __w_pdfjs_require__(6);
var _stamp = __w_pdfjs_require__(34);
class AnnotationEditorLayer {
  #accessibilityManager;
  #allowClick = false;
  #annotationLayer = null;
  #boundPointerup = this.pointerup.bind(this);
  #boundPointerdown = this.pointerdown.bind(this);
  #editors = new Map();
  #hadPointerDown = false;
  #isCleaningUp = false;
  #isDisabling = false;
  #uiManager;
  static _initialized = false;
  constructor({
    uiManager,
    pageIndex,
    div,
    accessibilityManager,
    annotationLayer,
    viewport,
    l10n
  }) {
    const editorTypes = [_freetext.FreeTextEditor, _ink.InkEditor, _stamp.StampEditor];
    if (!AnnotationEditorLayer._initialized) {
      AnnotationEditorLayer._initialized = true;
      for (const editorType of editorTypes) {
        editorType.initialize(l10n);
      }
    }
    uiManager.registerEditorTypes(editorTypes);
    this.#uiManager = uiManager;
    this.pageIndex = pageIndex;
    this.div = div;
    this.#accessibilityManager = accessibilityManager;
    this.#annotationLayer = annotationLayer;
    this.viewport = viewport;
    this.#uiManager.addLayer(this);
  }
  get isEmpty() {
    return this.#editors.size === 0;
  }
  updateToolbar(mode) {
    this.#uiManager.updateToolbar(mode);
  }
  updateMode(mode = this.#uiManager.getMode()) {
    this.#cleanup();
    if (mode === _util.AnnotationEditorType.INK) {
      this.addInkEditorIfNeeded(false);
      this.disableClick();
    } else {
      this.enableClick();
    }
    if (mode !== _util.AnnotationEditorType.NONE) {
      this.div.classList.toggle("freeTextEditing", mode === _util.AnnotationEditorType.FREETEXT);
      this.div.classList.toggle("inkEditing", mode === _util.AnnotationEditorType.INK);
      this.div.classList.toggle("stampEditing", mode === _util.AnnotationEditorType.STAMP);
      this.div.hidden = false;
    }
  }
  addInkEditorIfNeeded(isCommitting) {
    if (!isCommitting && this.#uiManager.getMode() !== _util.AnnotationEditorType.INK) {
      return;
    }
    if (!isCommitting) {
      for (const editor of this.#editors.values()) {
        if (editor.isEmpty()) {
          editor.setInBackground();
          return;
        }
      }
    }
    const editor = this.#createAndAddNewEditor({
      offsetX: 0,
      offsetY: 0
    }, false);
    editor.setInBackground();
  }
  setEditingState(isEditing) {
    this.#uiManager.setEditingState(isEditing);
  }
  addCommands(params) {
    this.#uiManager.addCommands(params);
  }
  enable() {
    this.div.style.pointerEvents = "auto";
    const annotationElementIds = new Set();
    for (const editor of this.#editors.values()) {
      editor.enableEditing();
      if (editor.annotationElementId) {
        annotationElementIds.add(editor.annotationElementId);
      }
    }
    if (!this.#annotationLayer) {
      return;
    }
    const editables = this.#annotationLayer.getEditableAnnotations();
    for (const editable of editables) {
      editable.hide();
      if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {
        continue;
      }
      if (annotationElementIds.has(editable.data.id)) {
        continue;
      }
      const editor = this.deserialize(editable);
      if (!editor) {
        continue;
      }
      this.addOrRebuild(editor);
      editor.enableEditing();
    }
  }
  disable() {
    this.#isDisabling = true;
    this.div.style.pointerEvents = "none";
    const hiddenAnnotationIds = new Set();
    for (const editor of this.#editors.values()) {
      editor.disableEditing();
      if (!editor.annotationElementId || editor.serialize() !== null) {
        hiddenAnnotationIds.add(editor.annotationElementId);
        continue;
      }
      this.getEditableAnnotation(editor.annotationElementId)?.show();
      editor.remove();
    }
    if (this.#annotationLayer) {
      const editables = this.#annotationLayer.getEditableAnnotations();
      for (const editable of editables) {
        const {
          id
        } = editable.data;
        if (hiddenAnnotationIds.has(id) || this.#uiManager.isDeletedAnnotationElement(id)) {
          continue;
        }
        editable.show();
      }
    }
    this.#cleanup();
    if (this.isEmpty) {
      this.div.hidden = true;
    }
    this.#isDisabling = false;
  }
  getEditableAnnotation(id) {
    return this.#annotationLayer?.getEditableAnnotation(id) || null;
  }
  setActiveEditor(editor) {
    const currentActive = this.#uiManager.getActive();
    if (currentActive === editor) {
      return;
    }
    this.#uiManager.setActiveEditor(editor);
  }
  enableClick() {
    this.div.addEventListener("pointerdown", this.#boundPointerdown);
    this.div.addEventListener("pointerup", this.#boundPointerup);
  }
  disableClick() {
    this.div.removeEventListener("pointerdown", this.#boundPointerdown);
    this.div.removeEventListener("pointerup", this.#boundPointerup);
  }
  attach(editor) {
    this.#editors.set(editor.id, editor);
    const {
      annotationElementId
    } = editor;
    if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {
      this.#uiManager.removeDeletedAnnotationElement(editor);
    }
  }
  detach(editor) {
    this.#editors.delete(editor.id);
    this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
    if (!this.#isDisabling && editor.annotationElementId) {
      this.#uiManager.addDeletedAnnotationElement(editor);
    }
  }
  remove(editor) {
    this.detach(editor);
    this.#uiManager.removeEditor(editor);
    if (editor.div.contains(document.activeElement)) {
      setTimeout(() => {
        this.#uiManager.focusMainContainer();
      }, 0);
    }
    editor.div.remove();
    editor.isAttachedToDOM = false;
    if (!this.#isCleaningUp) {
      this.addInkEditorIfNeeded(false);
    }
  }
  changeParent(editor) {
    if (editor.parent === this) {
      return;
    }
    if (editor.annotationElementId) {
      this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);
      _editor.AnnotationEditor.deleteAnnotationElement(editor);
      editor.annotationElementId = null;
    }
    this.attach(editor);
    editor.parent?.detach(editor);
    editor.setParent(this);
    if (editor.div && editor.isAttachedToDOM) {
      editor.div.remove();
      this.div.append(editor.div);
    }
  }
  add(editor) {
    this.changeParent(editor);
    this.#uiManager.addEditor(editor);
    this.attach(editor);
    if (!editor.isAttachedToDOM) {
      const div = editor.render();
      this.div.append(div);
      editor.isAttachedToDOM = true;
    }
    editor.fixAndSetPosition();
    editor.onceAdded();
    this.#uiManager.addToAnnotationStorage(editor);
  }
  moveEditorInDOM(editor) {
    if (!editor.isAttachedToDOM) {
      return;
    }
    const {
      activeElement
    } = document;
    if (editor.div.contains(activeElement)) {
      editor._focusEventsAllowed = false;
      setTimeout(() => {
        if (!editor.div.contains(document.activeElement)) {
          editor.div.addEventListener("focusin", () => {
            editor._focusEventsAllowed = true;
          }, {
            once: true
          });
          activeElement.focus();
        } else {
          editor._focusEventsAllowed = true;
        }
      }, 0);
    }
    editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
  }
  addOrRebuild(editor) {
    if (editor.needsToBeRebuilt()) {
      editor.rebuild();
    } else {
      this.add(editor);
    }
  }
  addUndoableEditor(editor) {
    const cmd = () => editor._uiManager.rebuild(editor);
    const undo = () => {
      editor.remove();
    };
    this.addCommands({
      cmd,
      undo,
      mustExec: false
    });
  }
  getNextId() {
    return this.#uiManager.getId();
  }
  #createNewEditor(params) {
    switch (this.#uiManager.getMode()) {
      case _util.AnnotationEditorType.FREETEXT:
        return new _freetext.FreeTextEditor(params);
      case _util.AnnotationEditorType.INK:
        return new _ink.InkEditor(params);
      case _util.AnnotationEditorType.STAMP:
        return new _stamp.StampEditor(params);
    }
    return null;
  }
  pasteEditor(mode, params) {
    this.#uiManager.updateToolbar(mode);
    this.#uiManager.updateMode(mode);
    const {
      offsetX,
      offsetY
    } = this.#getCenterPoint();
    const id = this.getNextId();
    const editor = this.#createNewEditor({
      parent: this,
      id,
      x: offsetX,
      y: offsetY,
      uiManager: this.#uiManager,
      isCentered: true,
      ...params
    });
    if (editor) {
      this.add(editor);
    }
  }
  deserialize(data) {
    switch (data.annotationType ?? data.annotationEditorType) {
      case _util.AnnotationEditorType.FREETEXT:
        return _freetext.FreeTextEditor.deserialize(data, this, this.#uiManager);
      case _util.AnnotationEditorType.INK:
        return _ink.InkEditor.deserialize(data, this, this.#uiManager);
      case _util.AnnotationEditorType.STAMP:
        return _stamp.StampEditor.deserialize(data, this, this.#uiManager);
    }
    return null;
  }
  #createAndAddNewEditor(event, isCentered) {
    const id = this.getNextId();
    const editor = this.#createNewEditor({
      parent: this,
      id,
      x: event.offsetX,
      y: event.offsetY,
      uiManager: this.#uiManager,
      isCentered
    });
    if (editor) {
      this.add(editor);
    }
    return editor;
  }
  #getCenterPoint() {
    const {
      x,
      y,
      width,
      height
    } = this.div.getBoundingClientRect();
    const tlX = Math.max(0, x);
    const tlY = Math.max(0, y);
    const brX = Math.min(window.innerWidth, x + width);
    const brY = Math.min(window.innerHeight, y + height);
    const centerX = (tlX + brX) / 2 - x;
    const centerY = (tlY + brY) / 2 - y;
    const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];
    return {
      offsetX,
      offsetY
    };
  }
  addNewEditor() {
    this.#createAndAddNewEditor(this.#getCenterPoint(), true);
  }
  setSelected(editor) {
    this.#uiManager.setSelected(editor);
  }
  toggleSelected(editor) {
    this.#uiManager.toggleSelected(editor);
  }
  isSelected(editor) {
    return this.#uiManager.isSelected(editor);
  }
  unselect(editor) {
    this.#uiManager.unselect(editor);
  }
  pointerup(event) {
    const {
      isMac
    } = _util.FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    if (event.target !== this.div) {
      return;
    }
    if (!this.#hadPointerDown) {
      return;
    }
    this.#hadPointerDown = false;
    if (!this.#allowClick) {
      this.#allowClick = true;
      return;
    }
    if (this.#uiManager.getMode() === _util.AnnotationEditorType.STAMP) {
      this.#uiManager.unselectAll();
      return;
    }
    this.#createAndAddNewEditor(event, false);
  }
  pointerdown(event) {
    if (this.#hadPointerDown) {
      this.#hadPointerDown = false;
      return;
    }
    const {
      isMac
    } = _util.FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    if (event.target !== this.div) {
      return;
    }
    this.#hadPointerDown = true;
    const editor = this.#uiManager.getActive();
    this.#allowClick = !editor || editor.isEmpty();
  }
  findNewParent(editor, x, y) {
    const layer = this.#uiManager.findParent(x, y);
    if (layer === null || layer === this) {
      return false;
    }
    layer.changeParent(editor);
    return true;
  }
  destroy() {
    if (this.#uiManager.getActive()?.parent === this) {
      this.#uiManager.commitOrRemove();
      this.#uiManager.setActiveEditor(null);
    }
    for (const editor of this.#editors.values()) {
      this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
      editor.setParent(null);
      editor.isAttachedToDOM = false;
      editor.div.remove();
    }
    this.div = null;
    this.#editors.clear();
    this.#uiManager.removeLayer(this);
  }
  #cleanup() {
    this.#isCleaningUp = true;
    for (const editor of this.#editors.values()) {
      if (editor.isEmpty()) {
        editor.remove();
      }
    }
    this.#isCleaningUp = false;
  }
  render({
    viewport
  }) {
    this.viewport = viewport;
    (0, _display_utils.setLayerDimensions)(this.div, viewport);
    for (const editor of this.#uiManager.getEditors(this.pageIndex)) {
      this.add(editor);
    }
    this.updateMode();
  }
  update({
    viewport
  }) {
    this.#uiManager.commitOrRemove();
    this.viewport = viewport;
    (0, _display_utils.setLayerDimensions)(this.div, {
      rotation: viewport.rotation
    });
    this.updateMode();
  }
  get pageDimensions() {
    const {
      pageWidth,
      pageHeight
    } = this.viewport.rawDims;
    return [pageWidth, pageHeight];
  }
}
exports.AnnotationEditorLayer = AnnotationEditorLayer;

/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FreeTextEditor = void 0;
var _util = __w_pdfjs_require__(1);
var _tools = __w_pdfjs_require__(5);
var _editor = __w_pdfjs_require__(4);
var _annotation_layer = __w_pdfjs_require__(29);
class FreeTextEditor extends _editor.AnnotationEditor {
  #boundEditorDivBlur = this.editorDivBlur.bind(this);
  #boundEditorDivFocus = this.editorDivFocus.bind(this);
  #boundEditorDivInput = this.editorDivInput.bind(this);
  #boundEditorDivKeydown = this.editorDivKeydown.bind(this);
  #color;
  #content = "";
  #editorDivId = `${this.id}-editor`;
  #fontSize;
  #initialData = null;
  static _freeTextDefaultContent = "";
  static _internalPadding = 0;
  static _defaultColor = null;
  static _defaultFontSize = 10;
  static get _keyboardManager() {
    const proto = FreeTextEditor.prototype;
    const arrowChecker = self => self.isEmpty();
    const small = _tools.AnnotationEditorUIManager.TRANSLATE_SMALL;
    const big = _tools.AnnotationEditorUIManager.TRANSLATE_BIG;
    return (0, _util.shadow)(this, "_keyboardManager", new _tools.KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], proto.commitOrRemove, {
      bubbles: true
    }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], proto.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], proto._translateEmpty, {
      args: [-small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto._translateEmpty, {
      args: [-big, 0],
      checker: arrowChecker
    }], [["ArrowRight", "mac+ArrowRight"], proto._translateEmpty, {
      args: [small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto._translateEmpty, {
      args: [big, 0],
      checker: arrowChecker
    }], [["ArrowUp", "mac+ArrowUp"], proto._translateEmpty, {
      args: [0, -small],
      checker: arrowChecker
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto._translateEmpty, {
      args: [0, -big],
      checker: arrowChecker
    }], [["ArrowDown", "mac+ArrowDown"], proto._translateEmpty, {
      args: [0, small],
      checker: arrowChecker
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto._translateEmpty, {
      args: [0, big],
      checker: arrowChecker
    }]]));
  }
  static _type = "freetext";
  constructor(params) {
    super({
      ...params,
      name: "freeTextEditor"
    });
    this.#color = params.color || FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;
    this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;
  }
  static initialize(l10n) {
    _editor.AnnotationEditor.initialize(l10n, {
      strings: ["free_text2_default_content", "editor_free_text2_aria_label"]
    });
    const style = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(type, value) {
    switch (type) {
      case _util.AnnotationEditorParamsType.FREETEXT_SIZE:
        FreeTextEditor._defaultFontSize = value;
        break;
      case _util.AnnotationEditorParamsType.FREETEXT_COLOR:
        FreeTextEditor._defaultColor = value;
        break;
    }
  }
  updateParams(type, value) {
    switch (type) {
      case _util.AnnotationEditorParamsType.FREETEXT_SIZE:
        this.#updateFontSize(value);
        break;
      case _util.AnnotationEditorParamsType.FREETEXT_COLOR:
        this.#updateColor(value);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, this.#color]];
  }
  #updateFontSize(fontSize) {
    const setFontsize = size => {
      this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;
      this.translate(0, -(size - this.#fontSize) * this.parentScale);
      this.#fontSize = size;
      this.#setEditorDimensions();
    };
    const savedFontsize = this.#fontSize;
    this.addCommands({
      cmd: () => {
        setFontsize(fontSize);
      },
      undo: () => {
        setFontsize(savedFontsize);
      },
      mustExec: true,
      type: _util.AnnotationEditorParamsType.FREETEXT_SIZE,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  #updateColor(color) {
    const savedColor = this.#color;
    this.addCommands({
      cmd: () => {
        this.#color = this.editorDiv.style.color = color;
      },
      undo: () => {
        this.#color = this.editorDiv.style.color = savedColor;
      },
      mustExec: true,
      type: _util.AnnotationEditorParamsType.FREETEXT_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  _translateEmpty(x, y) {
    this._uiManager.translateSelectedEditors(x, y, true);
  }
  getInitialTranslation() {
    const scale = this.parentScale;
    return [-FreeTextEditor._internalPadding * scale, -(FreeTextEditor._internalPadding + this.#fontSize) * scale];
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  enableEditMode() {
    if (this.isInEditMode()) {
      return;
    }
    this.parent.setEditingState(false);
    this.parent.updateToolbar(_util.AnnotationEditorType.FREETEXT);
    super.enableEditMode();
    this.overlayDiv.classList.remove("enabled");
    this.editorDiv.contentEditable = true;
    this._isDraggable = false;
    this.div.removeAttribute("aria-activedescendant");
    this.editorDiv.addEventListener("keydown", this.#boundEditorDivKeydown);
    this.editorDiv.addEventListener("focus", this.#boundEditorDivFocus);
    this.editorDiv.addEventListener("blur", this.#boundEditorDivBlur);
    this.editorDiv.addEventListener("input", this.#boundEditorDivInput);
  }
  disableEditMode() {
    if (!this.isInEditMode()) {
      return;
    }
    this.parent.setEditingState(true);
    super.disableEditMode();
    this.overlayDiv.classList.add("enabled");
    this.editorDiv.contentEditable = false;
    this.div.setAttribute("aria-activedescendant", this.#editorDivId);
    this._isDraggable = true;
    this.editorDiv.removeEventListener("keydown", this.#boundEditorDivKeydown);
    this.editorDiv.removeEventListener("focus", this.#boundEditorDivFocus);
    this.editorDiv.removeEventListener("blur", this.#boundEditorDivBlur);
    this.editorDiv.removeEventListener("input", this.#boundEditorDivInput);
    this.div.focus({
      preventScroll: true
    });
    this.isEditing = false;
    this.parent.div.classList.add("freeTextEditing");
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    super.focusin(event);
    if (event.target !== this.editorDiv) {
      this.editorDiv.focus();
    }
  }
  onceAdded() {
    if (this.width) {
      this.#cheatInitialRect();
      return;
    }
    this.enableEditMode();
    this.editorDiv.focus();
    if (this._initialOptions?.isCentered) {
      this.center();
    }
    this._initialOptions = null;
  }
  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }
  remove() {
    this.isEditing = false;
    if (this.parent) {
      this.parent.setEditingState(true);
      this.parent.div.classList.add("freeTextEditing");
    }
    super.remove();
  }
  #extractText() {
    const divs = this.editorDiv.getElementsByTagName("div");
    if (divs.length === 0) {
      return this.editorDiv.innerText;
    }
    const buffer = [];
    for (const div of divs) {
      buffer.push(div.innerText.replace(/\r\n?|\n/, ""));
    }
    return buffer.join("\n");
  }
  #setEditorDimensions() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    let rect;
    if (this.isAttachedToDOM) {
      rect = this.div.getBoundingClientRect();
    } else {
      const {
        currentLayer,
        div
      } = this;
      const savedDisplay = div.style.display;
      div.style.display = "hidden";
      currentLayer.div.append(this.div);
      rect = div.getBoundingClientRect();
      div.remove();
      div.style.display = savedDisplay;
    }
    if (this.rotation % 180 === this.parentRotation % 180) {
      this.width = rect.width / parentWidth;
      this.height = rect.height / parentHeight;
    } else {
      this.width = rect.height / parentWidth;
      this.height = rect.width / parentHeight;
    }
    this.fixAndSetPosition();
  }
  commit() {
    if (!this.isInEditMode()) {
      return;
    }
    super.commit();
    this.disableEditMode();
    const savedText = this.#content;
    const newText = this.#content = this.#extractText().trimEnd();
    if (savedText === newText) {
      return;
    }
    const setText = text => {
      this.#content = text;
      if (!text) {
        this.remove();
        return;
      }
      this.#setContent();
      this._uiManager.rebuild(this);
      this.#setEditorDimensions();
    };
    this.addCommands({
      cmd: () => {
        setText(newText);
      },
      undo: () => {
        setText(savedText);
      },
      mustExec: false
    });
    this.#setEditorDimensions();
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode();
    this.editorDiv.focus();
  }
  dblclick(event) {
    this.enterInEditMode();
  }
  keydown(event) {
    if (event.target === this.div && event.key === "Enter") {
      this.enterInEditMode();
      event.preventDefault();
    }
  }
  editorDivKeydown(event) {
    FreeTextEditor._keyboardManager.exec(this, event);
  }
  editorDivFocus(event) {
    this.isEditing = true;
  }
  editorDivBlur(event) {
    this.isEditing = false;
  }
  editorDivInput(event) {
    this.parent.div.classList.toggle("freeTextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment");
    this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox");
    this.editorDiv.setAttribute("aria-multiline", true);
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this.width) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    this.editorDiv = document.createElement("div");
    this.editorDiv.className = "internal";
    this.editorDiv.setAttribute("id", this.#editorDivId);
    this.enableEditing();
    _editor.AnnotationEditor._l10nPromise.get("editor_free_text2_aria_label").then(msg => this.editorDiv?.setAttribute("aria-label", msg));
    _editor.AnnotationEditor._l10nPromise.get("free_text2_default_content").then(msg => this.editorDiv?.setAttribute("default-content", msg));
    this.editorDiv.contentEditable = true;
    const {
      style
    } = this.editorDiv;
    style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;
    style.color = this.#color;
    this.div.append(this.editorDiv);
    this.overlayDiv = document.createElement("div");
    this.overlayDiv.classList.add("overlay", "enabled");
    this.div.append(this.overlayDiv);
    (0, _tools.bindEvents)(this, this.div, ["dblclick", "keydown"]);
    if (this.width) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      if (this.annotationElementId) {
        const {
          position
        } = this.#initialData;
        let [tx, ty] = this.getInitialTranslation();
        [tx, ty] = this.pageTranslationToScreen(tx, ty);
        const [pageWidth, pageHeight] = this.pageDimensions;
        const [pageX, pageY] = this.pageTranslation;
        let posX, posY;
        switch (this.rotation) {
          case 0:
            posX = baseX + (position[0] - pageX) / pageWidth;
            posY = baseY + this.height - (position[1] - pageY) / pageHeight;
            break;
          case 90:
            posX = baseX + (position[0] - pageX) / pageWidth;
            posY = baseY - (position[1] - pageY) / pageHeight;
            [tx, ty] = [ty, -tx];
            break;
          case 180:
            posX = baseX - this.width + (position[0] - pageX) / pageWidth;
            posY = baseY - (position[1] - pageY) / pageHeight;
            [tx, ty] = [-tx, -ty];
            break;
          case 270:
            posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;
            posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;
            [tx, ty] = [-ty, tx];
            break;
        }
        this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);
      } else {
        this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
      }
      this.#setContent();
      this._isDraggable = true;
      this.editorDiv.contentEditable = false;
    } else {
      this._isDraggable = false;
      this.editorDiv.contentEditable = true;
    }
    return this.div;
  }
  #setContent() {
    this.editorDiv.replaceChildren();
    if (!this.#content) {
      return;
    }
    for (const line of this.#content.split("\n")) {
      const div = document.createElement("div");
      div.append(line ? document.createTextNode(line) : document.createElement("br"));
      this.editorDiv.append(div);
    }
  }
  get contentDiv() {
    return this.editorDiv;
  }
  static deserialize(data, parent, uiManager) {
    let initialData = null;
    if (data instanceof _annotation_layer.FreeTextAnnotationElement) {
      const {
        data: {
          defaultAppearanceData: {
            fontSize,
            fontColor
          },
          rect,
          rotation,
          id
        },
        textContent,
        textPosition,
        parent: {
          page: {
            pageNumber
          }
        }
      } = data;
      if (!textContent || textContent.length === 0) {
        return null;
      }
      initialData = data = {
        annotationType: _util.AnnotationEditorType.FREETEXT,
        color: Array.from(fontColor),
        fontSize,
        value: textContent.join("\n"),
        position: textPosition,
        pageIndex: pageNumber - 1,
        rect,
        rotation,
        id,
        deleted: false
      };
    }
    const editor = super.deserialize(data, parent, uiManager);
    editor.#fontSize = data.fontSize;
    editor.#color = _util.Util.makeHexColor(...data.color);
    editor.#content = data.value;
    editor.annotationElementId = data.id || null;
    editor.#initialData = initialData;
    return editor;
  }
  serialize(isForCopying = false) {
    if (this.isEmpty()) {
      return null;
    }
    if (this.deleted) {
      return {
        pageIndex: this.pageIndex,
        id: this.annotationElementId,
        deleted: true
      };
    }
    const padding = FreeTextEditor._internalPadding * this.parentScale;
    const rect = this.getRect(padding, padding);
    const color = _editor.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);
    const serialized = {
      annotationType: _util.AnnotationEditorType.FREETEXT,
      color,
      fontSize: this.#fontSize,
      value: this.#content,
      pageIndex: this.pageIndex,
      rect,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
    if (isForCopying) {
      return serialized;
    }
    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
      return null;
    }
    serialized.id = this.annotationElementId;
    return serialized;
  }
  #hasElementChanged(serialized) {
    const {
      value,
      fontSize,
      color,
      rect,
      pageIndex
    } = this.#initialData;
    return serialized.value !== value || serialized.fontSize !== fontSize || serialized.rect.some((x, i) => Math.abs(x - rect[i]) >= 1) || serialized.color.some((c, i) => c !== color[i]) || serialized.pageIndex !== pageIndex;
  }
  #cheatInitialRect(delayed = false) {
    if (!this.annotationElementId) {
      return;
    }
    this.#setEditorDimensions();
    if (!delayed && (this.width === 0 || this.height === 0)) {
      setTimeout(() => this.#cheatInitialRect(true), 0);
      return;
    }
    const padding = FreeTextEditor._internalPadding * this.parentScale;
    this.#initialData.rect = this.getRect(padding, padding);
  }
}
exports.FreeTextEditor = FreeTextEditor;

/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StampAnnotationElement = exports.InkAnnotationElement = exports.FreeTextAnnotationElement = exports.AnnotationLayer = void 0;
var _util = __w_pdfjs_require__(1);
var _display_utils = __w_pdfjs_require__(6);
var _annotation_storage = __w_pdfjs_require__(3);
var _scripting_utils = __w_pdfjs_require__(30);
var _displayL10n_utils = __w_pdfjs_require__(31);
var _xfa_layer = __w_pdfjs_require__(32);
const DEFAULT_TAB_INDEX = 1000;
const DEFAULT_FONT_SIZE = 9;
const GetElementsByNameSet = new WeakSet();
function getRectDims(rect) {
  return {
    width: rect[2] - rect[0],
    height: rect[3] - rect[1]
  };
}
class AnnotationElementFactory {
  static create(parameters) {
    const subtype = parameters.data.annotationType;
    switch (subtype) {
      case _util.AnnotationType.LINK:
        return new LinkAnnotationElement(parameters);
      case _util.AnnotationType.TEXT:
        return new TextAnnotationElement(parameters);
      case _util.AnnotationType.WIDGET:
        const fieldType = parameters.data.fieldType;
        switch (fieldType) {
          case "Tx":
            return new TextWidgetAnnotationElement(parameters);
          case "Btn":
            if (parameters.data.radioButton) {
              return new RadioButtonWidgetAnnotationElement(parameters);
            } else if (parameters.data.checkBox) {
              return new CheckboxWidgetAnnotationElement(parameters);
            }
            return new PushButtonWidgetAnnotationElement(parameters);
          case "Ch":
            return new ChoiceWidgetAnnotationElement(parameters);
          case "Sig":
            return new SignatureWidgetAnnotationElement(parameters);
        }
        return new WidgetAnnotationElement(parameters);
      case _util.AnnotationType.POPUP:
        return new PopupAnnotationElement(parameters);
      case _util.AnnotationType.FREETEXT:
        return new FreeTextAnnotationElement(parameters);
      case _util.AnnotationType.LINE:
        return new LineAnnotationElement(parameters);
      case _util.AnnotationType.SQUARE:
        return new SquareAnnotationElement(parameters);
      case _util.AnnotationType.CIRCLE:
        return new CircleAnnotationElement(parameters);
      case _util.AnnotationType.POLYLINE:
        return new PolylineAnnotationElement(parameters);
      case _util.AnnotationType.CARET:
        return new CaretAnnotationElement(parameters);
      case _util.AnnotationType.INK:
        return new InkAnnotationElement(parameters);
      case _util.AnnotationType.POLYGON:
        return new PolygonAnnotationElement(parameters);
      case _util.AnnotationType.HIGHLIGHT:
        return new HighlightAnnotationElement(parameters);
      case _util.AnnotationType.UNDERLINE:
        return new UnderlineAnnotationElement(parameters);
      case _util.AnnotationType.SQUIGGLY:
        return new SquigglyAnnotationElement(parameters);
      case _util.AnnotationType.STRIKEOUT:
        return new StrikeOutAnnotationElement(parameters);
      case _util.AnnotationType.STAMP:
        return new StampAnnotationElement(parameters);
      case _util.AnnotationType.FILEATTACHMENT:
        return new FileAttachmentAnnotationElement(parameters);
      default:
        return new AnnotationElement(parameters);
    }
  }
}
class AnnotationElement {
  #hasBorder = false;
  constructor(parameters, {
    isRenderable = false,
    ignoreBorder = false,
    createQuadrilaterals = false
  } = {}) {
    this.isRenderable = isRenderable;
    this.data = parameters.data;
    this.layer = parameters.layer;
    this.linkService = parameters.linkService;
    this.downloadManager = parameters.downloadManager;
    this.imageResourcesPath = parameters.imageResourcesPath;
    this.renderForms = parameters.renderForms;
    this.svgFactory = parameters.svgFactory;
    this.annotationStorage = parameters.annotationStorage;
    this.enableScripting = parameters.enableScripting;
    this.hasJSActions = parameters.hasJSActions;
    this._fieldObjects = parameters.fieldObjects;
    this.parent = parameters.parent;
    if (isRenderable) {
      this.container = this._createContainer(ignoreBorder);
    }
    if (createQuadrilaterals) {
      this._createQuadrilaterals();
    }
  }
  static _hasPopupData({
    titleObj,
    contentsObj,
    richText
  }) {
    return !!(titleObj?.str || contentsObj?.str || richText?.str);
  }
  get hasPopupData() {
    return AnnotationElement._hasPopupData(this.data);
  }
  _createContainer(ignoreBorder) {
    const {
      data,
      parent: {
        page,
        viewport
      }
    } = this;
    const container = document.createElement("section");
    container.setAttribute("data-annotation-id", data.id);
    if (!(this instanceof WidgetAnnotationElement)) {
      container.tabIndex = DEFAULT_TAB_INDEX;
    }
    container.style.zIndex = this.parent.zIndex++;
    if (this.data.popupRef) {
      container.setAttribute("aria-haspopup", "dialog");
    }
    if (data.noRotate) {
      container.classList.add("norotate");
    }
    const {
      pageWidth,
      pageHeight,
      pageX,
      pageY
    } = viewport.rawDims;
    if (!data.rect || this instanceof PopupAnnotationElement) {
      const {
        rotation
      } = data;
      if (!data.hasOwnCanvas && rotation !== 0) {
        this.setRotation(rotation, container);
      }
      return container;
    }
    const {
      width,
      height
    } = getRectDims(data.rect);
    const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
    if (!ignoreBorder && data.borderStyle.width > 0) {
      container.style.borderWidth = `${data.borderStyle.width}px`;
      const horizontalRadius = data.borderStyle.horizontalCornerRadius;
      const verticalRadius = data.borderStyle.verticalCornerRadius;
      if (horizontalRadius > 0 || verticalRadius > 0) {
        const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
        container.style.borderRadius = radius;
      } else if (this instanceof RadioButtonWidgetAnnotationElement) {
        const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
        container.style.borderRadius = radius;
      }
      switch (data.borderStyle.style) {
        case _util.AnnotationBorderStyleType.SOLID:
          container.style.borderStyle = "solid";
          break;
        case _util.AnnotationBorderStyleType.DASHED:
          container.style.borderStyle = "dashed";
          break;
        case _util.AnnotationBorderStyleType.BEVELED:
          (0, _util.warn)("Unimplemented border style: beveled");
          break;
        case _util.AnnotationBorderStyleType.INSET:
          (0, _util.warn)("Unimplemented border style: inset");
          break;
        case _util.AnnotationBorderStyleType.UNDERLINE:
          container.style.borderBottomStyle = "solid";
          break;
        default:
          break;
      }
      const borderColor = data.borderColor || null;
      if (borderColor) {
        this.#hasBorder = true;
        container.style.borderColor = _util.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
      } else {
        container.style.borderWidth = 0;
      }
    }
    container.style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
    container.style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;
    const {
      rotation
    } = data;
    if (data.hasOwnCanvas || rotation === 0) {
      container.style.width = `${100 * width / pageWidth}%`;
      container.style.height = `${100 * height / pageHeight}%`;
    } else {
      this.setRotation(rotation, container);
    }
    return container;
  }
  setRotation(angle, container = this.container) {
    if (!this.data.rect) {
      return;
    }
    const {
      pageWidth,
      pageHeight
    } = this.parent.viewport.rawDims;
    const {
      width,
      height
    } = getRectDims(this.data.rect);
    let elementWidth, elementHeight;
    if (angle % 180 === 0) {
      elementWidth = 100 * width / pageWidth;
      elementHeight = 100 * height / pageHeight;
    } else {
      elementWidth = 100 * height / pageWidth;
      elementHeight = 100 * width / pageHeight;
    }
    container.style.width = `${elementWidth}%`;
    container.style.height = `${elementHeight}%`;
    container.setAttribute("data-main-rotation", (360 - angle) % 360);
  }
  get _commonActions() {
    const setColor = (jsName, styleName, event) => {
      const color = event.detail[jsName];
      const colorType = color[0];
      const colorArray = color.slice(1);
      event.target.style[styleName] = _scripting_utils.ColorConverters[`${colorType}_HTML`](colorArray);
      this.annotationStorage.setValue(this.data.id, {
        [styleName]: _scripting_utils.ColorConverters[`${colorType}_rgb`](colorArray)
      });
    };
    return (0, _util.shadow)(this, "_commonActions", {
      display: event => {
        const {
          display
        } = event.detail;
        const hidden = display % 2 === 1;
        this.container.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          noView: hidden,
          noPrint: display === 1 || display === 2
        });
      },
      print: event => {
        this.annotationStorage.setValue(this.data.id, {
          noPrint: !event.detail.print
        });
      },
      hidden: event => {
        const {
          hidden
        } = event.detail;
        this.container.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          noPrint: hidden,
          noView: hidden
        });
      },
      focus: event => {
        setTimeout(() => event.target.focus({
          preventScroll: false
        }), 0);
      },
      userName: event => {
        event.target.title = event.detail.userName;
      },
      readonly: event => {
        event.target.disabled = event.detail.readonly;
      },
      required: event => {
        this._setRequired(event.target, event.detail.required);
      },
      bgColor: event => {
        setColor("bgColor", "backgroundColor", event);
      },
      fillColor: event => {
        setColor("fillColor", "backgroundColor", event);
      },
      fgColor: event => {
        setColor("fgColor", "color", event);
      },
      textColor: event => {
        setColor("textColor", "color", event);
      },
      borderColor: event => {
        setColor("borderColor", "borderColor", event);
      },
      strokeColor: event => {
        setColor("strokeColor", "borderColor", event);
      },
      rotation: event => {
        const angle = event.detail.rotation;
        this.setRotation(angle);
        this.annotationStorage.setValue(this.data.id, {
          rotation: angle
        });
      }
    });
  }
  _dispatchEventFromSandbox(actions, jsEvent) {
    const commonActions = this._commonActions;
    for (const name of Object.keys(jsEvent.detail)) {
      const action = actions[name] || commonActions[name];
      action?.(jsEvent);
    }
  }
  _setDefaultPropertiesFromJS(element) {
    if (!this.enableScripting) {
      return;
    }
    const storedData = this.annotationStorage.getRawValue(this.data.id);
    if (!storedData) {
      return;
    }
    const commonActions = this._commonActions;
    for (const [actionName, detail] of Object.entries(storedData)) {
      const action = commonActions[actionName];
      if (action) {
        const eventProxy = {
          detail: {
            [actionName]: detail
          },
          target: element
        };
        action(eventProxy);
        delete storedData[actionName];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container) {
      return;
    }
    const {
      quadPoints
    } = this.data;
    if (!quadPoints) {
      return;
    }
    const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect;
    if (quadPoints.length === 1) {
      const [, {
        x: trX,
        y: trY
      }, {
        x: blX,
        y: blY
      }] = quadPoints[0];
      if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {
        return;
      }
    }
    const {
      style
    } = this.container;
    let svgBuffer;
    if (this.#hasBorder) {
      const {
        borderColor,
        borderWidth
      } = style;
      style.borderWidth = 0;
      svgBuffer = ["url('data:image/svg+xml;utf8,", `<svg xmlns="http://www.w3.org/2000/svg"`, ` preserveAspectRatio="none" viewBox="0 0 1 1">`, `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`];
      this.container.classList.add("hasBorder");
    }
    const width = rectTrX - rectBlX;
    const height = rectTrY - rectBlY;
    const {
      svgFactory
    } = this;
    const svg = svgFactory.createElement("svg");
    svg.classList.add("quadrilateralsContainer");
    svg.setAttribute("width", 0);
    svg.setAttribute("height", 0);
    const defs = svgFactory.createElement("defs");
    svg.append(defs);
    const clipPath = svgFactory.createElement("clipPath");
    const id = `clippath_${this.data.id}`;
    clipPath.setAttribute("id", id);
    clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
    defs.append(clipPath);
    for (const [, {
      x: trX,
      y: trY
    }, {
      x: blX,
      y: blY
    }] of quadPoints) {
      const rect = svgFactory.createElement("rect");
      const x = (blX - rectBlX) / width;
      const y = (rectTrY - trY) / height;
      const rectWidth = (trX - blX) / width;
      const rectHeight = (trY - blY) / height;
      rect.setAttribute("x", x);
      rect.setAttribute("y", y);
      rect.setAttribute("width", rectWidth);
      rect.setAttribute("height", rectHeight);
      clipPath.append(rect);
      svgBuffer?.push(`<rect vector-effect="non-scaling-stroke" x="${x}" y="${y}" width="${rectWidth}" height="${rectHeight}"/>`);
    }
    if (this.#hasBorder) {
      svgBuffer.push(`</g></svg>')`);
      style.backgroundImage = svgBuffer.join("");
    }
    this.container.append(svg);
    this.container.style.clipPath = `url(#${id})`;
  }
  _createPopup() {
    const {
      container,
      data
    } = this;
    container.setAttribute("aria-haspopup", "dialog");
    const popup = new PopupAnnotationElement({
      data: {
        color: data.color,
        titleObj: data.titleObj,
        modificationDate: data.modificationDate,
        contentsObj: data.contentsObj,
        richText: data.richText,
        parentRect: data.rect,
        borderStyle: 0,
        id: `popup_${data.id}`,
        rotation: data.rotation
      },
      parent: this.parent,
      elements: [this]
    });
    this.parent.div.append(popup.render());
  }
  render() {
    (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(name, skipId = null) {
    const fields = [];
    if (this._fieldObjects) {
      const fieldObj = this._fieldObjects[name];
      if (fieldObj) {
        for (const {
          page,
          id,
          exportValues
        } of fieldObj) {
          if (page === -1) {
            continue;
          }
          if (id === skipId) {
            continue;
          }
          const exportValue = typeof exportValues === "string" ? exportValues : null;
          const domElement = document.querySelector(`[data-element-id="${id}"]`);
          if (domElement && !GetElementsByNameSet.has(domElement)) {
            (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`);
            continue;
          }
          fields.push({
            id,
            exportValue,
            domElement
          });
        }
      }
      return fields;
    }
    for (const domElement of document.getElementsByName(name)) {
      const {
        exportValue
      } = domElement;
      const id = domElement.getAttribute("data-element-id");
      if (id === skipId) {
        continue;
      }
      if (!GetElementsByNameSet.has(domElement)) {
        continue;
      }
      fields.push({
        id,
        exportValue,
        domElement
      });
    }
    return fields;
  }
  show() {
    if (this.container) {
      this.container.hidden = false;
    }
    this.popup?.maybeShow();
  }
  hide() {
    if (this.container) {
      this.container.hidden = true;
    }
    this.popup?.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const triggers = this.getElementsToTriggerPopup();
    if (Array.isArray(triggers)) {
      for (const element of triggers) {
        element.classList.add("highlightArea");
      }
    } else {
      triggers.classList.add("highlightArea");
    }
  }
  _editOnDoubleClick() {
    const {
      annotationEditorType: mode,
      data: {
        id: editId
      }
    } = this;
    this.container.addEventListener("dblclick", () => {
      this.linkService.eventBus?.dispatch("switchannotationeditormode", {
        source: this,
        mode,
        editId
      });
    });
  }
}
class LinkAnnotationElement extends AnnotationElement {
  constructor(parameters, options = null) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: !!options?.ignoreBorder,
      createQuadrilaterals: true
    });
    this.isTooltipOnly = parameters.data.isTooltipOnly;
  }
  render() {
    const {
      data,
      linkService
    } = this;
    const link = document.createElement("a");
    link.setAttribute("data-element-id", data.id);
    let isBound = false;
    if (data.url) {
      linkService.addLinkAttributes(link, data.url, data.newWindow);
      isBound = true;
    } else if (data.action) {
      this._bindNamedAction(link, data.action);
      isBound = true;
    } else if (data.attachment) {
      this._bindAttachment(link, data.attachment);
      isBound = true;
    } else if (data.setOCGState) {
      this.#bindSetOCGState(link, data.setOCGState);
      isBound = true;
    } else if (data.dest) {
      this._bindLink(link, data.dest);
      isBound = true;
    } else {
      if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
        this._bindJSAction(link, data);
        isBound = true;
      }
      if (data.resetForm) {
        this._bindResetFormAction(link, data.resetForm);
        isBound = true;
      } else if (this.isTooltipOnly && !isBound) {
        this._bindLink(link, "");
        isBound = true;
      }
    }
    this.container.classList.add("linkAnnotation");
    if (isBound) {
      this.container.append(link);
    }
    return this.container;
  }
  #setInternalLink() {
    this.container.setAttribute("data-internal-link", "");
  }
  _bindLink(link, destination) {
    link.href = this.linkService.getDestinationHash(destination);
    link.onclick = () => {
      if (destination) {
        this.linkService.goToDestination(destination);
      }
      return false;
    };
    if (destination || destination === "") {
      this.#setInternalLink();
    }
  }
  _bindNamedAction(link, action) {
    link.href = this.linkService.getAnchorUrl("");
    link.onclick = () => {
      this.linkService.executeNamedAction(action);
      return false;
    };
    this.#setInternalLink();
  }
  _bindAttachment(link, attachment) {
    link.href = this.linkService.getAnchorUrl("");
    link.onclick = () => {
      this.downloadManager?.openOrDownloadData(this.container, attachment.content, attachment.filename);
      return false;
    };
    this.#setInternalLink();
  }
  #bindSetOCGState(link, action) {
    link.href = this.linkService.getAnchorUrl("");
    link.onclick = () => {
      this.linkService.executeSetOCGState(action);
      return false;
    };
    this.#setInternalLink();
  }
  _bindJSAction(link, data) {
    link.href = this.linkService.getAnchorUrl("");
    const map = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const name of Object.keys(data.actions)) {
      const jsName = map.get(name);
      if (!jsName) {
        continue;
      }
      link[jsName] = () => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: data.id,
            name
          }
        });
        return false;
      };
    }
    if (!link.onclick) {
      link.onclick = () => false;
    }
    this.#setInternalLink();
  }
  _bindResetFormAction(link, resetForm) {
    const otherClickAction = link.onclick;
    if (!otherClickAction) {
      link.href = this.linkService.getAnchorUrl("");
    }
    this.#setInternalLink();
    if (!this._fieldObjects) {
      (0, _util.warn)(`_bindResetFormAction - "resetForm" action not supported, ` + "ensure that the `fieldObjects` parameter is provided.");
      if (!otherClickAction) {
        link.onclick = () => false;
      }
      return;
    }
    link.onclick = () => {
      otherClickAction?.();
      const {
        fields: resetFormFields,
        refs: resetFormRefs,
        include
      } = resetForm;
      const allFields = [];
      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
        const fieldIds = new Set(resetFormRefs);
        for (const fieldName of resetFormFields) {
          const fields = this._fieldObjects[fieldName] || [];
          for (const {
            id
          } of fields) {
            fieldIds.add(id);
          }
        }
        for (const fields of Object.values(this._fieldObjects)) {
          for (const field of fields) {
            if (fieldIds.has(field.id) === include) {
              allFields.push(field);
            }
          }
        }
      } else {
        for (const fields of Object.values(this._fieldObjects)) {
          allFields.push(...fields);
        }
      }
      const storage = this.annotationStorage;
      const allIds = [];
      for (const field of allFields) {
        const {
          id
        } = field;
        allIds.push(id);
        switch (field.type) {
          case "text":
            {
              const value = field.defaultValue || "";
              storage.setValue(id, {
                value
              });
              break;
            }
          case "checkbox":
          case "radiobutton":
            {
              const value = field.defaultValue === field.exportValues;
              storage.setValue(id, {
                value
              });
              break;
            }
          case "combobox":
          case "listbox":
            {
              const value = field.defaultValue || "";
              storage.setValue(id, {
                value
              });
              break;
            }
          default:
            continue;
        }
        const domElement = document.querySelector(`[data-element-id="${id}"]`);
        if (!domElement) {
          continue;
        } else if (!GetElementsByNameSet.has(domElement)) {
          (0, _util.warn)(`_bindResetFormAction - element not allowed: ${id}`);
          continue;
        }
        domElement.dispatchEvent(new Event("resetform"));
      }
      if (this.enableScripting) {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: "app",
            ids: allIds,
            name: "ResetForm"
          }
        });
      }
      return false;
    };
  }
}
class TextAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true
    });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const image = document.createElement("img");
    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
    image.alt = "[{{type}} Annotation]";
    image.dataset.l10nId = "text_annotation_type";
    image.dataset.l10nArgs = JSON.stringify({
      type: this.data.name
    });
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.append(image);
    return this.container;
  }
}
class WidgetAnnotationElement extends AnnotationElement {
  render() {
    if (this.data.alternativeText) {
      this.container.title = this.data.alternativeText;
    }
    return this.container;
  }
  showElementAndHideCanvas(element) {
    if (this.data.hasOwnCanvas) {
      if (element.previousSibling?.nodeName === "CANVAS") {
        element.previousSibling.hidden = true;
      }
      element.hidden = false;
    }
  }
  _getKeyModifier(event) {
    const {
      isWin,
      isMac
    } = _util.FeatureTest.platform;
    return isWin && event.ctrlKey || isMac && event.metaKey;
  }
  _setEventListener(element, elementData, baseName, eventName, valueGetter) {
    if (baseName.includes("mouse")) {
      element.addEventListener(baseName, event => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event),
            shift: event.shiftKey,
            modifier: this._getKeyModifier(event)
          }
        });
      });
    } else {
      element.addEventListener(baseName, event => {
        if (baseName === "blur") {
          if (!elementData.focused || !event.relatedTarget) {
            return;
          }
          elementData.focused = false;
        } else if (baseName === "focus") {
          if (elementData.focused) {
            return;
          }
          elementData.focused = true;
        }
        if (!valueGetter) {
          return;
        }
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event)
          }
        });
      });
    }
  }
  _setEventListeners(element, elementData, names, getter) {
    for (const [baseName, eventName] of names) {
      if (eventName === "Action" || this.data.actions?.[eventName]) {
        if (eventName === "Focus" || eventName === "Blur") {
          elementData ||= {
            focused: false
          };
        }
        this._setEventListener(element, elementData, baseName, eventName, getter);
        if (eventName === "Focus" && !this.data.actions?.Blur) {
          this._setEventListener(element, elementData, "blur", "Blur", null);
        } else if (eventName === "Blur" && !this.data.actions?.Focus) {
          this._setEventListener(element, elementData, "focus", "Focus", null);
        }
      }
    }
  }
  _setBackgroundColor(element) {
    const color = this.data.backgroundColor || null;
    element.style.backgroundColor = color === null ? "transparent" : _util.Util.makeHexColor(color[0], color[1], color[2]);
  }
  _setTextStyle(element) {
    const TEXT_ALIGNMENT = ["left", "center", "right"];
    const {
      fontColor
    } = this.data.defaultAppearanceData;
    const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
    const style = element.style;
    let computedFontSize;
    const BORDER_SIZE = 2;
    const roundToOneDecimal = x => Math.round(10 * x) / 10;
    if (this.data.multiLine) {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
      const numberOfLines = Math.round(height / (_util.LINE_FACTOR * fontSize)) || 1;
      const lineHeight = height / numberOfLines;
      computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / _util.LINE_FACTOR));
    } else {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
      computedFontSize = Math.min(fontSize, roundToOneDecimal(height / _util.LINE_FACTOR));
    }
    style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
    style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
    if (this.data.textAlignment !== null) {
      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
    }
  }
  _setRequired(element, isRequired) {
    if (isRequired) {
      element.setAttribute("required", true);
    } else {
      element.removeAttribute("required");
    }
    element.setAttribute("aria-required", isRequired);
  }
}
class TextWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
    super(parameters, {
      isRenderable
    });
  }
  setPropertyOnSiblings(base, key, value, keyInStorage) {
    const storage = this.annotationStorage;
    for (const element of this._getElementsByName(base.name, base.id)) {
      if (element.domElement) {
        element.domElement[key] = value;
      }
      storage.setValue(element.id, {
        [keyInStorage]: value
      });
    }
  }
  render() {
    const storage = this.annotationStorage;
    const id = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let element = null;
    if (this.renderForms) {
      const storedData = storage.getValue(id, {
        value: this.data.fieldValue
      });
      let textContent = storedData.value || "";
      const maxLen = storage.getValue(id, {
        charLimit: this.data.maxLen
      }).charLimit;
      if (maxLen && textContent.length > maxLen) {
        textContent = textContent.slice(0, maxLen);
      }
      let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join("\n") || null;
      if (fieldFormattedValues && this.data.comb) {
        fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
      }
      const elementData = {
        userValue: textContent,
        formattedValue: fieldFormattedValues,
        lastCommittedValue: null,
        commitKey: 1,
        focused: false
      };
      if (this.data.multiLine) {
        element = document.createElement("textarea");
        element.textContent = fieldFormattedValues ?? textContent;
        if (this.data.doNotScroll) {
          element.style.overflowY = "hidden";
        }
      } else {
        element = document.createElement("input");
        element.type = "text";
        element.setAttribute("value", fieldFormattedValues ?? textContent);
        if (this.data.doNotScroll) {
          element.style.overflowX = "hidden";
        }
      }
      if (this.data.hasOwnCanvas) {
        element.hidden = true;
      }
      GetElementsByNameSet.add(element);
      element.setAttribute("data-element-id", id);
      element.disabled = this.data.readOnly;
      element.name = this.data.fieldName;
      element.tabIndex = DEFAULT_TAB_INDEX;
      this._setRequired(element, this.data.required);
      if (maxLen) {
        element.maxLength = maxLen;
      }
      element.addEventListener("input", event => {
        storage.setValue(id, {
          value: event.target.value
        });
        this.setPropertyOnSiblings(element, "value", event.target.value, "value");
        elementData.formattedValue = null;
      });
      element.addEventListener("resetform", event => {
        const defaultValue = this.data.defaultFieldValue ?? "";
        element.value = elementData.userValue = defaultValue;
        elementData.formattedValue = null;
      });
      let blurListener = event => {
        const {
          formattedValue
        } = elementData;
        if (formattedValue !== null && formattedValue !== undefined) {
          event.target.value = formattedValue;
        }
        event.target.scrollLeft = 0;
      };
      if (this.enableScripting && this.hasJSActions) {
        element.addEventListener("focus", event => {
          if (elementData.focused) {
            return;
          }
          const {
            target
          } = event;
          if (elementData.userValue) {
            target.value = elementData.userValue;
          }
          elementData.lastCommittedValue = target.value;
          elementData.commitKey = 1;
          elementData.focused = true;
        });
        element.addEventListener("updatefromsandbox", jsEvent => {
          this.showElementAndHideCanvas(jsEvent.target);
          const actions = {
            value(event) {
              elementData.userValue = event.detail.value ?? "";
              storage.setValue(id, {
                value: elementData.userValue.toString()
              });
              event.target.value = elementData.userValue;
            },
            formattedValue(event) {
              const {
                formattedValue
              } = event.detail;
              elementData.formattedValue = formattedValue;
              if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {
                event.target.value = formattedValue;
              }
              storage.setValue(id, {
                formattedValue
              });
            },
            selRange(event) {
              event.target.setSelectionRange(...event.detail.selRange);
            },
            charLimit: event => {
              const {
                charLimit
              } = event.detail;
              const {
                target
              } = event;
              if (charLimit === 0) {
                target.removeAttribute("maxLength");
                return;
              }
              target.setAttribute("maxLength", charLimit);
              let value = elementData.userValue;
              if (!value || value.length <= charLimit) {
                return;
              }
              value = value.slice(0, charLimit);
              target.value = elementData.userValue = value;
              storage.setValue(id, {
                value
              });
              this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id,
                  name: "Keystroke",
                  value,
                  willCommit: true,
                  commitKey: 1,
                  selStart: target.selectionStart,
                  selEnd: target.selectionEnd
                }
              });
            }
          };
          this._dispatchEventFromSandbox(actions, jsEvent);
        });
        element.addEventListener("keydown", event => {
          elementData.commitKey = 1;
          let commitKey = -1;
          if (event.key === "Escape") {
            commitKey = 0;
          } else if (event.key === "Enter" && !this.data.multiLine) {
            commitKey = 2;
          } else if (event.key === "Tab") {
            elementData.commitKey = 3;
          }
          if (commitKey === -1) {
            return;
          }
          const {
            value
          } = event.target;
          if (elementData.lastCommittedValue === value) {
            return;
          }
          elementData.lastCommittedValue = value;
          elementData.userValue = value;
          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id,
              name: "Keystroke",
              value,
              willCommit: true,
              commitKey,
              selStart: event.target.selectionStart,
              selEnd: event.target.selectionEnd
            }
          });
        });
        const _blurListener = blurListener;
        blurListener = null;
        element.addEventListener("blur", event => {
          if (!elementData.focused || !event.relatedTarget) {
            return;
          }
          elementData.focused = false;
          const {
            value
          } = event.target;
          elementData.userValue = value;
          if (elementData.lastCommittedValue !== value) {
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                willCommit: true,
                commitKey: elementData.commitKey,
                selStart: event.target.selectionStart,
                selEnd: event.target.selectionEnd
              }
            });
          }
          _blurListener(event);
        });
        if (this.data.actions?.Keystroke) {
          element.addEventListener("beforeinput", event => {
            elementData.lastCommittedValue = null;
            const {
              data,
              target
            } = event;
            const {
              value,
              selectionStart,
              selectionEnd
            } = target;
            let selStart = selectionStart,
              selEnd = selectionEnd;
            switch (event.inputType) {
              case "deleteWordBackward":
                {
                  const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                  if (match) {
                    selStart -= match[0].length;
                  }
                  break;
                }
              case "deleteWordForward":
                {
                  const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                  if (match) {
                    selEnd += match[0].length;
                  }
                  break;
                }
              case "deleteContentBackward":
                if (selectionStart === selectionEnd) {
                  selStart -= 1;
                }
                break;
              case "deleteContentForward":
                if (selectionStart === selectionEnd) {
                  selEnd += 1;
                }
                break;
            }
            event.preventDefault();
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                change: data || "",
                willCommit: false,
                selStart,
                selEnd
              }
            });
          });
        }
        this._setEventListeners(element, elementData, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.value);
      }
      if (blurListener) {
        element.addEventListener("blur", blurListener);
      }
      if (this.data.comb) {
        const fieldWidth = this.data.rect[2] - this.data.rect[0];
        const combWidth = fieldWidth / maxLen;
        element.classList.add("comb");
        element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
      }
    } else {
      element = document.createElement("div");
      element.textContent = this.data.fieldValue;
      element.style.verticalAlign = "middle";
      element.style.display = "table-cell";
    }
    this._setTextStyle(element);
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
}
class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: !!parameters.data.hasOwnCanvas
    });
  }
}
class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.exportValue === data.fieldValue
    }).value;
    if (typeof value === "string") {
      value = value !== "Off";
      storage.setValue(id, {
        value
      });
    }
    this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id);
    element.disabled = data.readOnly;
    this._setRequired(element, this.data.required);
    element.type = "checkbox";
    element.name = data.fieldName;
    if (value) {
      element.setAttribute("checked", true);
    }
    element.setAttribute("exportValue", data.exportValue);
    element.tabIndex = DEFAULT_TAB_INDEX;
    element.addEventListener("change", event => {
      const {
        name,
        checked
      } = event.target;
      for (const checkbox of this._getElementsByName(name, id)) {
        const curChecked = checked && checkbox.exportValue === data.exportValue;
        if (checkbox.domElement) {
          checkbox.domElement.checked = curChecked;
        }
        storage.setValue(checkbox.id, {
          value: curChecked
        });
      }
      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", event => {
      const defaultValue = data.defaultFieldValue || "Off";
      event.target.checked = defaultValue === data.exportValue;
    });
    if (this.enableScripting && this.hasJSActions) {
      element.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value(event) {
            event.target.checked = event.detail.value !== "Off";
            storage.setValue(id, {
              value: event.target.checked
            });
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
    }
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
}
class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.fieldValue === data.buttonValue
    }).value;
    if (typeof value === "string") {
      value = value !== data.buttonValue;
      storage.setValue(id, {
        value
      });
    }
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id);
    element.disabled = data.readOnly;
    this._setRequired(element, this.data.required);
    element.type = "radio";
    element.name = data.fieldName;
    if (value) {
      element.setAttribute("checked", true);
    }
    element.tabIndex = DEFAULT_TAB_INDEX;
    element.addEventListener("change", event => {
      const {
        name,
        checked
      } = event.target;
      for (const radio of this._getElementsByName(name, id)) {
        storage.setValue(radio.id, {
          value: false
        });
      }
      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", event => {
      const defaultValue = data.defaultFieldValue;
      event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;
    });
    if (this.enableScripting && this.hasJSActions) {
      const pdfButtonValue = data.buttonValue;
      element.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value: event => {
            const checked = pdfButtonValue === event.detail.value;
            for (const radio of this._getElementsByName(event.target.name)) {
              const curChecked = checked && radio.id === id;
              if (radio.domElement) {
                radio.domElement.checked = curChecked;
              }
              storage.setValue(radio.id, {
                value: curChecked
              });
            }
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
    }
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
}
class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      ignoreBorder: parameters.data.hasAppearance
    });
  }
  render() {
    const container = super.render();
    container.classList.add("buttonWidgetAnnotation", "pushButton");
    if (this.data.alternativeText) {
      container.title = this.data.alternativeText;
    }
    const linkElement = container.lastChild;
    if (this.enableScripting && this.hasJSActions && linkElement) {
      this._setDefaultPropertiesFromJS(linkElement);
      linkElement.addEventListener("updatefromsandbox", jsEvent => {
        this._dispatchEventFromSandbox({}, jsEvent);
      });
    }
    return container;
  }
}
class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const storage = this.annotationStorage;
    const id = this.data.id;
    const storedData = storage.getValue(id, {
      value: this.data.fieldValue
    });
    const selectElement = document.createElement("select");
    GetElementsByNameSet.add(selectElement);
    selectElement.setAttribute("data-element-id", id);
    selectElement.disabled = this.data.readOnly;
    this._setRequired(selectElement, this.data.required);
    selectElement.name = this.data.fieldName;
    selectElement.tabIndex = DEFAULT_TAB_INDEX;
    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
    if (!this.data.combo) {
      selectElement.size = this.data.options.length;
      if (this.data.multiSelect) {
        selectElement.multiple = true;
      }
    }
    selectElement.addEventListener("resetform", event => {
      const defaultValue = this.data.defaultFieldValue;
      for (const option of selectElement.options) {
        option.selected = option.value === defaultValue;
      }
    });
    for (const option of this.data.options) {
      const optionElement = document.createElement("option");
      optionElement.textContent = option.displayValue;
      optionElement.value = option.exportValue;
      if (storedData.value.includes(option.exportValue)) {
        optionElement.setAttribute("selected", true);
        addAnEmptyEntry = false;
      }
      selectElement.append(optionElement);
    }
    let removeEmptyEntry = null;
    if (addAnEmptyEntry) {
      const noneOptionElement = document.createElement("option");
      noneOptionElement.value = " ";
      noneOptionElement.setAttribute("hidden", true);
      noneOptionElement.setAttribute("selected", true);
      selectElement.prepend(noneOptionElement);
      removeEmptyEntry = () => {
        noneOptionElement.remove();
        selectElement.removeEventListener("input", removeEmptyEntry);
        removeEmptyEntry = null;
      };
      selectElement.addEventListener("input", removeEmptyEntry);
    }
    const getValue = isExport => {
      const name = isExport ? "value" : "textContent";
      const {
        options,
        multiple
      } = selectElement;
      if (!multiple) {
        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
      }
      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);
    };
    let selectedValues = getValue(false);
    const getItems = event => {
      const options = event.target.options;
      return Array.prototype.map.call(options, option => {
        return {
          displayValue: option.textContent,
          exportValue: option.value
        };
      });
    };
    if (this.enableScripting && this.hasJSActions) {
      selectElement.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value(event) {
            removeEmptyEntry?.();
            const value = event.detail.value;
            const values = new Set(Array.isArray(value) ? value : [value]);
            for (const option of selectElement.options) {
              option.selected = values.has(option.value);
            }
            storage.setValue(id, {
              value: getValue(true)
            });
            selectedValues = getValue(false);
          },
          multipleSelection(event) {
            selectElement.multiple = true;
          },
          remove(event) {
            const options = selectElement.options;
            const index = event.detail.remove;
            options[index].selected = false;
            selectElement.remove(index);
            if (options.length > 0) {
              const i = Array.prototype.findIndex.call(options, option => option.selected);
              if (i === -1) {
                options[0].selected = true;
              }
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          clear(event) {
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }
            storage.setValue(id, {
              value: null,
              items: []
            });
            selectedValues = getValue(false);
          },
          insert(event) {
            const {
              index,
              displayValue,
              exportValue
            } = event.detail.insert;
            const selectChild = selectElement.children[index];
            const optionElement = document.createElement("option");
            optionElement.textContent = displayValue;
            optionElement.value = exportValue;
            if (selectChild) {
              selectChild.before(optionElement);
            } else {
              selectElement.append(optionElement);
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          items(event) {
            const {
              items
            } = event.detail;
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }
            for (const item of items) {
              const {
                displayValue,
                exportValue
              } = item;
              const optionElement = document.createElement("option");
              optionElement.textContent = displayValue;
              optionElement.value = exportValue;
              selectElement.append(optionElement);
            }
            if (selectElement.options.length > 0) {
              selectElement.options[0].selected = true;
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          indices(event) {
            const indices = new Set(event.detail.indices);
            for (const option of event.target.options) {
              option.selected = indices.has(option.index);
            }
            storage.setValue(id, {
              value: getValue(true)
            });
            selectedValues = getValue(false);
          },
          editable(event) {
            event.target.disabled = !event.detail.editable;
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      selectElement.addEventListener("input", event => {
        const exportValue = getValue(true);
        storage.setValue(id, {
          value: exportValue
        });
        event.preventDefault();
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id,
            name: "Keystroke",
            value: selectedValues,
            changeEx: exportValue,
            willCommit: false,
            commitKey: 1,
            keyDown: false
          }
        });
      });
      this._setEventListeners(selectElement, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], event => event.target.value);
    } else {
      selectElement.addEventListener("input", function (event) {
        storage.setValue(id, {
          value: getValue(true)
        });
      });
    }
    if (this.data.combo) {
      this._setTextStyle(selectElement);
    } else {}
    this._setBackgroundColor(selectElement);
    this._setDefaultPropertiesFromJS(selectElement);
    this.container.append(selectElement);
    return this.container;
  }
}
class PopupAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const {
      data,
      elements
    } = parameters;
    super(parameters, {
      isRenderable: AnnotationElement._hasPopupData(data)
    });
    this.elements = elements;
  }
  render() {
    this.container.classList.add("popupAnnotation");
    const popup = new PopupElement({
      container: this.container,
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText,
      rect: this.data.rect,
      parentRect: this.data.parentRect || null,
      parent: this.parent,
      elements: this.elements,
      open: this.data.open
    });
    const elementIds = [];
    for (const element of this.elements) {
      element.popup = popup;
      elementIds.push(element.data.id);
      element.addHighlightArea();
    }
    this.container.setAttribute("aria-controls", elementIds.map(id => `${_util.AnnotationPrefix}${id}`).join(","));
    return this.container;
  }
}
class PopupElement {
  #dateTimePromise = null;
  #boundKeyDown = this.#keyDown.bind(this);
  #boundHide = this.#hide.bind(this);
  #boundShow = this.#show.bind(this);
  #boundToggle = this.#toggle.bind(this);
  #color = null;
  #container = null;
  #contentsObj = null;
  #elements = null;
  #parent = null;
  #parentRect = null;
  #pinned = false;
  #popup = null;
  #rect = null;
  #richText = null;
  #titleObj = null;
  #wasVisible = false;
  constructor({
    container,
    color,
    elements,
    titleObj,
    modificationDate,
    contentsObj,
    richText,
    parent,
    rect,
    parentRect,
    open
  }) {
    this.#container = container;
    this.#titleObj = titleObj;
    this.#contentsObj = contentsObj;
    this.#richText = richText;
    this.#parent = parent;
    this.#color = color;
    this.#rect = rect;
    this.#parentRect = parentRect;
    this.#elements = elements;
    const dateObject = _display_utils.PDFDateString.toDateObject(modificationDate);
    if (dateObject) {
      this.#dateTimePromise = parent.l10n.get("annotation_date_string", {
        date: dateObject.toLocaleDateString(),
        time: dateObject.toLocaleTimeString()
      });
    }
    this.trigger = elements.flatMap(e => e.getElementsToTriggerPopup());
    for (const element of this.trigger) {
      element.addEventListener("click", this.#boundToggle);
      element.addEventListener("mouseenter", this.#boundShow);
      element.addEventListener("mouseleave", this.#boundHide);
      element.classList.add("popupTriggerArea");
    }
    for (const element of elements) {
      element.container?.addEventListener("keydown", this.#boundKeyDown);
    }
    this.#container.hidden = true;
    if (open) {
      this.#toggle();
    }
  }
  render() {
    if (this.#popup) {
      return;
    }
    const {
      page: {
        view
      },
      viewport: {
        rawDims: {
          pageWidth,
          pageHeight,
          pageX,
          pageY
        }
      }
    } = this.#parent;
    const popup = this.#popup = document.createElement("div");
    popup.className = "popup";
    if (this.#color) {
      const baseColor = popup.style.outlineColor = _util.Util.makeHexColor(...this.#color);
      if (CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")) {
        popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
      } else {
        const BACKGROUND_ENLIGHT = 0.7;
        popup.style.backgroundColor = _util.Util.makeHexColor(...this.#color.map(c => Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)));
      }
    }
    const header = document.createElement("span");
    header.className = "header";
    const title = document.createElement("h1");
    header.append(title);
    ({
      dir: title.dir,
      str: title.textContent
    } = this.#titleObj);
    popup.append(header);
    if (this.#dateTimePromise) {
      const modificationDate = document.createElement("span");
      modificationDate.classList.add("popupDate");
      this.#dateTimePromise.then(localized => {
        modificationDate.textContent = localized;
      });
      header.append(modificationDate);
    }
    const contentsObj = this.#contentsObj;
    const richText = this.#richText;
    if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {
      _xfa_layer.XfaLayer.render({
        xfaHtml: richText.html,
        intent: "richText",
        div: popup
      });
      popup.lastChild.classList.add("richText", "popupContent");
    } else {
      const contents = this._formatContents(contentsObj);
      popup.append(contents);
    }
    let useParentRect = !!this.#parentRect;
    let rect = useParentRect ? this.#parentRect : this.#rect;
    for (const element of this.#elements) {
      if (!rect || _util.Util.intersect(element.data.rect, rect) !== null) {
        rect = element.data.rect;
        useParentRect = true;
        break;
      }
    }
    const normalizedRect = _util.Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);
    const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
    const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;
    const popupLeft = normalizedRect[0] + parentWidth;
    const popupTop = normalizedRect[1];
    const {
      style
    } = this.#container;
    style.left = `${100 * (popupLeft - pageX) / pageWidth}%`;
    style.top = `${100 * (popupTop - pageY) / pageHeight}%`;
    this.#container.append(popup);
  }
  _formatContents({
    str,
    dir
  }) {
    const p = document.createElement("p");
    p.classList.add("popupContent");
    p.dir = dir;
    const lines = str.split(/(?:\r\n?|\n)/);
    for (let i = 0, ii = lines.length; i < ii; ++i) {
      const line = lines[i];
      p.append(document.createTextNode(line));
      if (i < ii - 1) {
        p.append(document.createElement("br"));
      }
    }
    return p;
  }
  #keyDown(event) {
    if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
      return;
    }
    if (event.key === "Enter" || event.key === "Escape" && this.#pinned) {
      this.#toggle();
    }
  }
  #toggle() {
    this.#pinned = !this.#pinned;
    if (this.#pinned) {
      this.#show();
      this.#container.addEventListener("click", this.#boundToggle);
      this.#container.addEventListener("keydown", this.#boundKeyDown);
    } else {
      this.#hide();
      this.#container.removeEventListener("click", this.#boundToggle);
      this.#container.removeEventListener("keydown", this.#boundKeyDown);
    }
  }
  #show() {
    if (!this.#popup) {
      this.render();
    }
    if (!this.isVisible) {
      this.#container.hidden = false;
      this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;
    } else if (this.#pinned) {
      this.#container.classList.add("focused");
    }
  }
  #hide() {
    this.#container.classList.remove("focused");
    if (this.#pinned || !this.isVisible) {
      return;
    }
    this.#container.hidden = true;
    this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;
  }
  forceHide() {
    this.#wasVisible = this.isVisible;
    if (!this.#wasVisible) {
      return;
    }
    this.#container.hidden = true;
  }
  maybeShow() {
    if (!this.#wasVisible) {
      return;
    }
    this.#wasVisible = false;
    this.#container.hidden = false;
  }
  get isVisible() {
    return this.#container.hidden === false;
  }
}
class FreeTextAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.textContent = parameters.data.textContent;
    this.textPosition = parameters.data.textPosition;
    this.annotationEditorType = _util.AnnotationEditorType.FREETEXT;
  }
  render() {
    this.container.classList.add("freeTextAnnotation");
    if (this.textContent) {
      const content = document.createElement("div");
      content.classList.add("annotationTextContent");
      content.setAttribute("role", "comment");
      for (const line of this.textContent) {
        const lineSpan = document.createElement("span");
        lineSpan.textContent = line;
        content.append(lineSpan);
      }
      this.container.append(content);
    }
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this._editOnDoubleClick();
    return this.container;
  }
}
exports.FreeTextAnnotationElement = FreeTextAnnotationElement;
class LineAnnotationElement extends AnnotationElement {
  #line = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    const line = this.#line = this.svgFactory.createElement("svg:line");
    line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
    line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
    line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
    line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
    line.setAttribute("stroke-width", data.borderStyle.width || 1);
    line.setAttribute("stroke", "transparent");
    line.setAttribute("fill", "transparent");
    svg.append(line);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#line;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class SquareAnnotationElement extends AnnotationElement {
  #square = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data.borderStyle.width;
    const square = this.#square = this.svgFactory.createElement("svg:rect");
    square.setAttribute("x", borderWidth / 2);
    square.setAttribute("y", borderWidth / 2);
    square.setAttribute("width", width - borderWidth);
    square.setAttribute("height", height - borderWidth);
    square.setAttribute("stroke-width", borderWidth || 1);
    square.setAttribute("stroke", "transparent");
    square.setAttribute("fill", "transparent");
    svg.append(square);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#square;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class CircleAnnotationElement extends AnnotationElement {
  #circle = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data.borderStyle.width;
    const circle = this.#circle = this.svgFactory.createElement("svg:ellipse");
    circle.setAttribute("cx", width / 2);
    circle.setAttribute("cy", height / 2);
    circle.setAttribute("rx", width / 2 - borderWidth / 2);
    circle.setAttribute("ry", height / 2 - borderWidth / 2);
    circle.setAttribute("stroke-width", borderWidth || 1);
    circle.setAttribute("stroke", "transparent");
    circle.setAttribute("fill", "transparent");
    svg.append(circle);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#circle;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class PolylineAnnotationElement extends AnnotationElement {
  #polyline = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.containerClassName = "polylineAnnotation";
    this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    let points = [];
    for (const coordinate of data.vertices) {
      const x = coordinate.x - data.rect[0];
      const y = data.rect[3] - coordinate.y;
      points.push(x + "," + y);
    }
    points = points.join(" ");
    const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);
    polyline.setAttribute("points", points);
    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
    polyline.setAttribute("stroke", "transparent");
    polyline.setAttribute("fill", "transparent");
    svg.append(polyline);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#polyline;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class PolygonAnnotationElement extends PolylineAnnotationElement {
  constructor(parameters) {
    super(parameters);
    this.containerClassName = "polygonAnnotation";
    this.svgElementName = "svg:polygon";
  }
}
class CaretAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("caretAnnotation");
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
}
class InkAnnotationElement extends AnnotationElement {
  #polylines = [];
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.containerClassName = "inkAnnotation";
    this.svgElementName = "svg:polyline";
    this.annotationEditorType = _util.AnnotationEditorType.INK;
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    for (const inkList of data.inkLists) {
      let points = [];
      for (const coordinate of inkList) {
        const x = coordinate.x - data.rect[0];
        const y = data.rect[3] - coordinate.y;
        points.push(`${x},${y}`);
      }
      points = points.join(" ");
      const polyline = this.svgFactory.createElement(this.svgElementName);
      this.#polylines.push(polyline);
      polyline.setAttribute("points", points);
      polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
      polyline.setAttribute("stroke", "transparent");
      polyline.setAttribute("fill", "transparent");
      if (!data.popupRef && this.hasPopupData) {
        this._createPopup();
      }
      svg.append(polyline);
    }
    this.container.append(svg);
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#polylines;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
exports.InkAnnotationElement = InkAnnotationElement;
class HighlightAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("highlightAnnotation");
    return this.container;
  }
}
class UnderlineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("underlineAnnotation");
    return this.container;
  }
}
class SquigglyAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("squigglyAnnotation");
    return this.container;
  }
}
class StrikeOutAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("strikeoutAnnotation");
    return this.container;
  }
}
class StampAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("stampAnnotation");
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
}
exports.StampAnnotationElement = StampAnnotationElement;
class FileAttachmentAnnotationElement extends AnnotationElement {
  #trigger = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true
    });
    const {
      filename,
      content
    } = this.data.file;
    this.filename = (0, _display_utils.getFilenameFromUrl)(filename, true);
    this.content = content;
    this.linkService.eventBus?.dispatch("fileattachmentannotation", {
      source: this,
      filename,
      content
    });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const {
      container,
      data
    } = this;
    let trigger;
    if (data.hasAppearance || data.fillAlpha === 0) {
      trigger = document.createElement("div");
    } else {
      trigger = document.createElement("img");
      trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? "paperclip" : "pushpin"}.svg`;
      if (data.fillAlpha && data.fillAlpha < 1) {
        trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;
      }
    }
    trigger.addEventListener("dblclick", this.#download.bind(this));
    this.#trigger = trigger;
    const {
      isMac
    } = _util.FeatureTest.platform;
    container.addEventListener("keydown", evt => {
      if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) {
        this.#download();
      }
    });
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    } else {
      trigger.classList.add("popupTriggerArea");
    }
    container.append(trigger);
    return container;
  }
  getElementsToTriggerPopup() {
    return this.#trigger;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
  #download() {
    this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);
  }
}
class AnnotationLayer {
  #accessibilityManager = null;
  #annotationCanvasMap = null;
  #editableAnnotations = new Map();
  constructor({
    div,
    accessibilityManager,
    annotationCanvasMap,
    l10n,
    page,
    viewport
  }) {
    this.div = div;
    this.#accessibilityManager = accessibilityManager;
    this.#annotationCanvasMap = annotationCanvasMap;
    this.l10n = l10n;
    this.page = page;
    this.viewport = viewport;
    this.zIndex = 0;
    this.l10n ||= _displayL10n_utils.NullL10n;
  }
  #appendElement(element, id) {
    const contentElement = element.firstChild || element;
    contentElement.id = `${_util.AnnotationPrefix}${id}`;
    this.div.append(element);
    this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);
  }
  async render(params) {
    const {
      annotations
    } = params;
    const layer = this.div;
    (0, _display_utils.setLayerDimensions)(layer, this.viewport);
    const popupToElements = new Map();
    const elementParams = {
      data: null,
      layer,
      linkService: params.linkService,
      downloadManager: params.downloadManager,
      imageResourcesPath: params.imageResourcesPath || "",
      renderForms: params.renderForms !== false,
      svgFactory: new _display_utils.DOMSVGFactory(),
      annotationStorage: params.annotationStorage || new _annotation_storage.AnnotationStorage(),
      enableScripting: params.enableScripting === true,
      hasJSActions: params.hasJSActions,
      fieldObjects: params.fieldObjects,
      parent: this,
      elements: null
    };
    for (const data of annotations) {
      if (data.noHTML) {
        continue;
      }
      const isPopupAnnotation = data.annotationType === _util.AnnotationType.POPUP;
      if (!isPopupAnnotation) {
        const {
          width,
          height
        } = getRectDims(data.rect);
        if (width <= 0 || height <= 0) {
          continue;
        }
      } else {
        const elements = popupToElements.get(data.id);
        if (!elements) {
          continue;
        }
        elementParams.elements = elements;
      }
      elementParams.data = data;
      const element = AnnotationElementFactory.create(elementParams);
      if (!element.isRenderable) {
        continue;
      }
      if (!isPopupAnnotation && data.popupRef) {
        const elements = popupToElements.get(data.popupRef);
        if (!elements) {
          popupToElements.set(data.popupRef, [element]);
        } else {
          elements.push(element);
        }
      }
      if (element.annotationEditorType > 0) {
        this.#editableAnnotations.set(element.data.id, element);
      }
      const rendered = element.render();
      if (data.hidden) {
        rendered.style.visibility = "hidden";
      }
      this.#appendElement(rendered, data.id);
    }
    this.#setAnnotationCanvasMap();
    await this.l10n.translate(layer);
  }
  update({
    viewport
  }) {
    const layer = this.div;
    this.viewport = viewport;
    (0, _display_utils.setLayerDimensions)(layer, {
      rotation: viewport.rotation
    });
    this.#setAnnotationCanvasMap();
    layer.hidden = false;
  }
  #setAnnotationCanvasMap() {
    if (!this.#annotationCanvasMap) {
      return;
    }
    const layer = this.div;
    for (const [id, canvas] of this.#annotationCanvasMap) {
      const element = layer.querySelector(`[data-annotation-id="${id}"]`);
      if (!element) {
        continue;
      }
      const {
        firstChild
      } = element;
      if (!firstChild) {
        element.append(canvas);
      } else if (firstChild.nodeName === "CANVAS") {
        firstChild.replaceWith(canvas);
      } else {
        firstChild.before(canvas);
      }
    }
    this.#annotationCanvasMap.clear();
  }
  getEditableAnnotations() {
    return Array.from(this.#editableAnnotations.values());
  }
  getEditableAnnotation(id) {
    return this.#editableAnnotations.get(id);
  }
}
exports.AnnotationLayer = AnnotationLayer;

/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ColorConverters = void 0;
function makeColorComp(n) {
  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
}
function scaleAndClamp(x) {
  return Math.max(0, Math.min(255, 255 * x));
}
class ColorConverters {
  static CMYK_G([c, y, m, k]) {
    return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
  }
  static G_CMYK([g]) {
    return ["CMYK", 0, 0, 0, 1 - g];
  }
  static G_RGB([g]) {
    return ["RGB", g, g, g];
  }
  static G_rgb([g]) {
    g = scaleAndClamp(g);
    return [g, g, g];
  }
  static G_HTML([g]) {
    const G = makeColorComp(g);
    return `#${G}${G}${G}`;
  }
  static RGB_G([r, g, b]) {
    return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
  }
  static RGB_rgb(color) {
    return color.map(scaleAndClamp);
  }
  static RGB_HTML(color) {
    return `#${color.map(makeColorComp).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([c, y, m, k]) {
    return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
  }
  static CMYK_rgb([c, y, m, k]) {
    return [scaleAndClamp(1 - Math.min(1, c + k)), scaleAndClamp(1 - Math.min(1, m + k)), scaleAndClamp(1 - Math.min(1, y + k))];
  }
  static CMYK_HTML(components) {
    const rgb = this.CMYK_RGB(components).slice(1);
    return this.RGB_HTML(rgb);
  }
  static RGB_CMYK([r, g, b]) {
    const c = 1 - r;
    const m = 1 - g;
    const y = 1 - b;
    const k = Math.min(c, m, y);
    return ["CMYK", c, m, y, k];
  }
}
exports.ColorConverters = ColorConverters;

/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NullL10n = void 0;
exports.getL10nFallback = getL10nFallback;
const DEFAULT_L10N_STRINGS = {
  of_pages: "of {{pagesCount}}",
  page_of_pages: "({{pageNumber}} of {{pagesCount}})",
  document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
  document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
  document_properties_date_string: "{{date}}, {{time}}",
  document_properties_page_size_unit_inches: "in",
  document_properties_page_size_unit_millimeters: "mm",
  document_properties_page_size_orientation_portrait: "portrait",
  document_properties_page_size_orientation_landscape: "landscape",
  document_properties_page_size_name_a3: "A3",
  document_properties_page_size_name_a4: "A4",
  document_properties_page_size_name_letter: "Letter",
  document_properties_page_size_name_legal: "Legal",
  document_properties_page_size_dimension_string: "{{width}}  {{height}} {{unit}} ({{orientation}})",
  document_properties_page_size_dimension_name_string: "{{width}}  {{height}} {{unit}} ({{name}}, {{orientation}})",
  document_properties_linearized_yes: "Yes",
  document_properties_linearized_no: "No",
  additional_layers: "Additional Layers",
  page_landmark: "Page {{page}}",
  thumb_page_title: "Page {{page}}",
  thumb_page_canvas: "Thumbnail of Page {{page}}",
  find_reached_top: "Reached top of document, continued from bottom",
  find_reached_bottom: "Reached end of document, continued from top",
  "find_match_count[one]": "{{current}} of {{total}} match",
  "find_match_count[other]": "{{current}} of {{total}} matches",
  "find_match_count_limit[one]": "More than {{limit}} match",
  "find_match_count_limit[other]": "More than {{limit}} matches",
  find_not_found: "Phrase not found",
  page_scale_width: "Page Width",
  page_scale_fit: "Page Fit",
  page_scale_auto: "Automatic Zoom",
  page_scale_actual: "Actual Size",
  page_scale_percent: "{{scale}}%",
  loading_error: "An error occurred while loading the PDF.",
  invalid_file_error: "Invalid or corrupted PDF file.",
  missing_file_error: "Missing PDF file.",
  unexpected_response_error: "Unexpected server response.",
  rendering_error: "An error occurred while rendering the page.",
  annotation_date_string: "{{date}}, {{time}}",
  printing_not_supported: "Warning: Printing is not fully supported by this browser.",
  printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
  web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.",
  free_text2_default_content: "Start typing",
  editor_free_text2_aria_label: "Text Editor",
  editor_ink2_aria_label: "Draw Editor",
  editor_ink_canvas_aria_label: "User-created image",
  editor_alt_text_button_label: "Alt text",
  editor_alt_text_edit_button_label: "Edit alt text",
  editor_alt_text_decorative_tooltip: "Marked as decorative"
};
{
  DEFAULT_L10N_STRINGS.print_progress_percent = "{{progress}}%";
}
function getL10nFallback(key, args) {
  switch (key) {
    case "find_match_count":
      key = `find_match_count[${args.total === 1 ? "one" : "other"}]`;
      break;
    case "find_match_count_limit":
      key = `find_match_count_limit[${args.limit === 1 ? "one" : "other"}]`;
      break;
  }
  return DEFAULT_L10N_STRINGS[key] || "";
}
function formatL10nValue(text, args) {
  if (!args) {
    return text;
  }
  return text.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (all, name) => {
    return name in args ? args[name] : "{{" + name + "}}";
  });
}
const NullL10n = {
  async getLanguage() {
    return "en-us";
  },
  async getDirection() {
    return "ltr";
  },
  async get(key, args = null, fallback = getL10nFallback(key, args)) {
    return formatL10nValue(fallback, args);
  },
  async translate(element) {}
};
exports.NullL10n = NullL10n;

/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XfaLayer = void 0;
var _xfa_text = __w_pdfjs_require__(25);
class XfaLayer {
  static setupStorage(html, id, element, storage, intent) {
    const storedData = storage.getValue(id, {
      value: null
    });
    switch (element.name) {
      case "textarea":
        if (storedData.value !== null) {
          html.textContent = storedData.value;
        }
        if (intent === "print") {
          break;
        }
        html.addEventListener("input", event => {
          storage.setValue(id, {
            value: event.target.value
          });
        });
        break;
      case "input":
        if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
          if (storedData.value === element.attributes.xfaOn) {
            html.setAttribute("checked", true);
          } else if (storedData.value === element.attributes.xfaOff) {
            html.removeAttribute("checked");
          }
          if (intent === "print") {
            break;
          }
          html.addEventListener("change", event => {
            storage.setValue(id, {
              value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (storedData.value !== null) {
            html.setAttribute("value", storedData.value);
          }
          if (intent === "print") {
            break;
          }
          html.addEventListener("input", event => {
            storage.setValue(id, {
              value: event.target.value
            });
          });
        }
        break;
      case "select":
        if (storedData.value !== null) {
          html.setAttribute("value", storedData.value);
          for (const option of element.children) {
            if (option.attributes.value === storedData.value) {
              option.attributes.selected = true;
            } else if (option.attributes.hasOwnProperty("selected")) {
              delete option.attributes.selected;
            }
          }
        }
        html.addEventListener("input", event => {
          const options = event.target.options;
          const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
          storage.setValue(id, {
            value
          });
        });
        break;
    }
  }
  static setAttributes({
    html,
    element,
    storage = null,
    intent,
    linkService
  }) {
    const {
      attributes
    } = element;
    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
    if (attributes.type === "radio") {
      attributes.name = `${attributes.name}-${intent}`;
    }
    for (const [key, value] of Object.entries(attributes)) {
      if (value === null || value === undefined) {
        continue;
      }
      switch (key) {
        case "class":
          if (value.length) {
            html.setAttribute(key, value.join(" "));
          }
          break;
        case "dataId":
          break;
        case "id":
          html.setAttribute("data-element-id", value);
          break;
        case "style":
          Object.assign(html.style, value);
          break;
        case "textContent":
          html.textContent = value;
          break;
        default:
          if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
            html.setAttribute(key, value);
          }
      }
    }
    if (isHTMLAnchorElement) {
      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
    }
    if (storage && attributes.dataId) {
      this.setupStorage(html, attributes.dataId, element, storage);
    }
  }
  static render(parameters) {
    const storage = parameters.annotationStorage;
    const linkService = parameters.linkService;
    const root = parameters.xfaHtml;
    const intent = parameters.intent || "display";
    const rootHtml = document.createElement(root.name);
    if (root.attributes) {
      this.setAttributes({
        html: rootHtml,
        element: root,
        intent,
        linkService
      });
    }
    const stack = [[root, -1, rootHtml]];
    const rootDiv = parameters.div;
    rootDiv.append(rootHtml);
    if (parameters.viewport) {
      const transform = `matrix(${parameters.viewport.transform.join(",")})`;
      rootDiv.style.transform = transform;
    }
    if (intent !== "richText") {
      rootDiv.setAttribute("class", "xfaLayer xfaFont");
    }
    const textDivs = [];
    while (stack.length > 0) {
      const [parent, i, html] = stack.at(-1);
      if (i + 1 === parent.children.length) {
        stack.pop();
        continue;
      }
      const child = parent.children[++stack.at(-1)[1]];
      if (child === null) {
        continue;
      }
      const {
        name
      } = child;
      if (name === "#text") {
        const node = document.createTextNode(child.value);
        textDivs.push(node);
        html.append(node);
        continue;
      }
      const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);
      html.append(childHtml);
      if (child.attributes) {
        this.setAttributes({
          html: childHtml,
          element: child,
          storage,
          intent,
          linkService
        });
      }
      if (child.children && child.children.length > 0) {
        stack.push([child, -1, childHtml]);
      } else if (child.value) {
        const node = document.createTextNode(child.value);
        if (_xfa_text.XfaText.shouldBuildText(name)) {
          textDivs.push(node);
        }
        childHtml.append(node);
      }
    }
    for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
      el.setAttribute("readOnly", true);
    }
    return {
      textDivs
    };
  }
  static update(parameters) {
    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
    parameters.div.style.transform = transform;
    parameters.div.hidden = false;
  }
}
exports.XfaLayer = XfaLayer;

/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.InkEditor = void 0;
var _util = __w_pdfjs_require__(1);
var _editor = __w_pdfjs_require__(4);
var _annotation_layer = __w_pdfjs_require__(29);
var _display_utils = __w_pdfjs_require__(6);
var _tools = __w_pdfjs_require__(5);
class InkEditor extends _editor.AnnotationEditor {
  #baseHeight = 0;
  #baseWidth = 0;
  #boundCanvasPointermove = this.canvasPointermove.bind(this);
  #boundCanvasPointerleave = this.canvasPointerleave.bind(this);
  #boundCanvasPointerup = this.canvasPointerup.bind(this);
  #boundCanvasPointerdown = this.canvasPointerdown.bind(this);
  #currentPath2D = new Path2D();
  #disableEditing = false;
  #hasSomethingToDraw = false;
  #isCanvasInitialized = false;
  #observer = null;
  #realWidth = 0;
  #realHeight = 0;
  #requestFrameCallback = null;
  static _defaultColor = null;
  static _defaultOpacity = 1;
  static _defaultThickness = 1;
  static _type = "ink";
  constructor(params) {
    super({
      ...params,
      name: "inkEditor"
    });
    this.color = params.color || null;
    this.thickness = params.thickness || null;
    this.opacity = params.opacity || null;
    this.paths = [];
    this.bezierPath2D = [];
    this.allRawPaths = [];
    this.currentPath = [];
    this.scaleFactor = 1;
    this.translationX = this.translationY = 0;
    this.x = 0;
    this.y = 0;
    this._willKeepAspectRatio = true;
  }
  static initialize(l10n) {
    _editor.AnnotationEditor.initialize(l10n, {
      strings: ["editor_ink_canvas_aria_label", "editor_ink2_aria_label"]
    });
  }
  static updateDefaultParams(type, value) {
    switch (type) {
      case _util.AnnotationEditorParamsType.INK_THICKNESS:
        InkEditor._defaultThickness = value;
        break;
      case _util.AnnotationEditorParamsType.INK_COLOR:
        InkEditor._defaultColor = value;
        break;
      case _util.AnnotationEditorParamsType.INK_OPACITY:
        InkEditor._defaultOpacity = value / 100;
        break;
    }
  }
  updateParams(type, value) {
    switch (type) {
      case _util.AnnotationEditorParamsType.INK_THICKNESS:
        this.#updateThickness(value);
        break;
      case _util.AnnotationEditorParamsType.INK_COLOR:
        this.#updateColor(value);
        break;
      case _util.AnnotationEditorParamsType.INK_OPACITY:
        this.#updateOpacity(value);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[_util.AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]];
  }
  get propertiesToUpdate() {
    return [[_util.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))]];
  }
  #updateThickness(thickness) {
    const savedThickness = this.thickness;
    this.addCommands({
      cmd: () => {
        this.thickness = thickness;
        this.#fitToContent();
      },
      undo: () => {
        this.thickness = savedThickness;
        this.#fitToContent();
      },
      mustExec: true,
      type: _util.AnnotationEditorParamsType.INK_THICKNESS,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  #updateColor(color) {
    const savedColor = this.color;
    this.addCommands({
      cmd: () => {
        this.color = color;
        this.#redraw();
      },
      undo: () => {
        this.color = savedColor;
        this.#redraw();
      },
      mustExec: true,
      type: _util.AnnotationEditorParamsType.INK_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  #updateOpacity(opacity) {
    opacity /= 100;
    const savedOpacity = this.opacity;
    this.addCommands({
      cmd: () => {
        this.opacity = opacity;
        this.#redraw();
      },
      undo: () => {
        this.opacity = savedOpacity;
        this.#redraw();
      },
      mustExec: true,
      type: _util.AnnotationEditorParamsType.INK_OPACITY,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (!this.canvas) {
      this.#createCanvas();
      this.#createObserver();
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
      this.#setCanvasDims();
    }
    this.#fitToContent();
  }
  remove() {
    if (this.canvas === null) {
      return;
    }
    if (!this.isEmpty()) {
      this.commit();
    }
    this.canvas.width = this.canvas.height = 0;
    this.canvas.remove();
    this.canvas = null;
    this.#observer.disconnect();
    this.#observer = null;
    super.remove();
  }
  setParent(parent) {
    if (!this.parent && parent) {
      this._uiManager.removeShouldRescale(this);
    } else if (this.parent && parent === null) {
      this._uiManager.addShouldRescale(this);
    }
    super.setParent(parent);
  }
  onScaleChanging() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const width = this.width * parentWidth;
    const height = this.height * parentHeight;
    this.setDimensions(width, height);
  }
  enableEditMode() {
    if (this.#disableEditing || this.canvas === null) {
      return;
    }
    super.enableEditMode();
    this._isDraggable = false;
    this.canvas.addEventListener("pointerdown", this.#boundCanvasPointerdown);
  }
  disableEditMode() {
    if (!this.isInEditMode() || this.canvas === null) {
      return;
    }
    super.disableEditMode();
    this._isDraggable = !this.isEmpty();
    this.div.classList.remove("editing");
    this.canvas.removeEventListener("pointerdown", this.#boundCanvasPointerdown);
  }
  onceAdded() {
    this._isDraggable = !this.isEmpty();
  }
  isEmpty() {
    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
  }
  #getInitialBBox() {
    const {
      parentRotation,
      parentDimensions: [width, height]
    } = this;
    switch (parentRotation) {
      case 90:
        return [0, height, height, width];
      case 180:
        return [width, height, width, height];
      case 270:
        return [width, 0, height, width];
      default:
        return [0, 0, width, height];
    }
  }
  #setStroke() {
    const {
      ctx,
      color,
      opacity,
      thickness,
      parentScale,
      scaleFactor
    } = this;
    ctx.lineWidth = thickness * parentScale / scaleFactor;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.miterLimit = 10;
    ctx.strokeStyle = `${color}${(0, _tools.opacityToHex)(opacity)}`;
  }
  #startDrawing(x, y) {
    this.canvas.addEventListener("contextmenu", _display_utils.noContextMenu);
    this.canvas.addEventListener("pointerleave", this.#boundCanvasPointerleave);
    this.canvas.addEventListener("pointermove", this.#boundCanvasPointermove);
    this.canvas.addEventListener("pointerup", this.#boundCanvasPointerup);
    this.canvas.removeEventListener("pointerdown", this.#boundCanvasPointerdown);
    this.isEditing = true;
    if (!this.#isCanvasInitialized) {
      this.#isCanvasInitialized = true;
      this.#setCanvasDims();
      this.thickness ||= InkEditor._defaultThickness;
      this.color ||= InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;
      this.opacity ??= InkEditor._defaultOpacity;
    }
    this.currentPath.push([x, y]);
    this.#hasSomethingToDraw = false;
    this.#setStroke();
    this.#requestFrameCallback = () => {
      this.#drawPoints();
      if (this.#requestFrameCallback) {
        window.requestAnimationFrame(this.#requestFrameCallback);
      }
    };
    window.requestAnimationFrame(this.#requestFrameCallback);
  }
  #draw(x, y) {
    const [lastX, lastY] = this.currentPath.at(-1);
    if (this.currentPath.length > 1 && x === lastX && y === lastY) {
      return;
    }
    const currentPath = this.currentPath;
    let path2D = this.#currentPath2D;
    currentPath.push([x, y]);
    this.#hasSomethingToDraw = true;
    if (currentPath.length <= 2) {
      path2D.moveTo(...currentPath[0]);
      path2D.lineTo(x, y);
      return;
    }
    if (currentPath.length === 3) {
      this.#currentPath2D = path2D = new Path2D();
      path2D.moveTo(...currentPath[0]);
    }
    this.#makeBezierCurve(path2D, ...currentPath.at(-3), ...currentPath.at(-2), x, y);
  }
  #endPath() {
    if (this.currentPath.length === 0) {
      return;
    }
    const lastPoint = this.currentPath.at(-1);
    this.#currentPath2D.lineTo(...lastPoint);
  }
  #stopDrawing(x, y) {
    this.#requestFrameCallback = null;
    x = Math.min(Math.max(x, 0), this.canvas.width);
    y = Math.min(Math.max(y, 0), this.canvas.height);
    this.#draw(x, y);
    this.#endPath();
    let bezier;
    if (this.currentPath.length !== 1) {
      bezier = this.#generateBezierPoints();
    } else {
      const xy = [x, y];
      bezier = [[xy, xy.slice(), xy.slice(), xy]];
    }
    const path2D = this.#currentPath2D;
    const currentPath = this.currentPath;
    this.currentPath = [];
    this.#currentPath2D = new Path2D();
    const cmd = () => {
      this.allRawPaths.push(currentPath);
      this.paths.push(bezier);
      this.bezierPath2D.push(path2D);
      this.rebuild();
    };
    const undo = () => {
      this.allRawPaths.pop();
      this.paths.pop();
      this.bezierPath2D.pop();
      if (this.paths.length === 0) {
        this.remove();
      } else {
        if (!this.canvas) {
          this.#createCanvas();
          this.#createObserver();
        }
        this.#fitToContent();
      }
    };
    this.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }
  #drawPoints() {
    if (!this.#hasSomethingToDraw) {
      return;
    }
    this.#hasSomethingToDraw = false;
    const thickness = Math.ceil(this.thickness * this.parentScale);
    const lastPoints = this.currentPath.slice(-3);
    const x = lastPoints.map(xy => xy[0]);
    const y = lastPoints.map(xy => xy[1]);
    const xMin = Math.min(...x) - thickness;
    const xMax = Math.max(...x) + thickness;
    const yMin = Math.min(...y) - thickness;
    const yMax = Math.max(...y) + thickness;
    const {
      ctx
    } = this;
    ctx.save();
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    for (const path of this.bezierPath2D) {
      ctx.stroke(path);
    }
    ctx.stroke(this.#currentPath2D);
    ctx.restore();
  }
  #makeBezierCurve(path2D, x0, y0, x1, y1, x2, y2) {
    const prevX = (x0 + x1) / 2;
    const prevY = (y0 + y1) / 2;
    const x3 = (x1 + x2) / 2;
    const y3 = (y1 + y2) / 2;
    path2D.bezierCurveTo(prevX + 2 * (x1 - prevX) / 3, prevY + 2 * (y1 - prevY) / 3, x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3, x3, y3);
  }
  #generateBezierPoints() {
    const path = this.currentPath;
    if (path.length <= 2) {
      return [[path[0], path[0], path.at(-1), path.at(-1)]];
    }
    const bezierPoints = [];
    let i;
    let [x0, y0] = path[0];
    for (i = 1; i < path.length - 2; i++) {
      const [x1, y1] = path[i];
      const [x2, y2] = path[i + 1];
      const x3 = (x1 + x2) / 2;
      const y3 = (y1 + y2) / 2;
      const control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];
      const control2 = [x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3];
      bezierPoints.push([[x0, y0], control1, control2, [x3, y3]]);
      [x0, y0] = [x3, y3];
    }
    const [x1, y1] = path[i];
    const [x2, y2] = path[i + 1];
    const control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];
    const control2 = [x2 + 2 * (x1 - x2) / 3, y2 + 2 * (y1 - y2) / 3];
    bezierPoints.push([[x0, y0], control1, control2, [x2, y2]]);
    return bezierPoints;
  }
  #redraw() {
    if (this.isEmpty()) {
      this.#updateTransform();
      return;
    }
    this.#setStroke();
    const {
      canvas,
      ctx
    } = this;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    this.#updateTransform();
    for (const path of this.bezierPath2D) {
      ctx.stroke(path);
    }
  }
  commit() {
    if (this.#disableEditing) {
      return;
    }
    super.commit();
    this.isEditing = false;
    this.disableEditMode();
    this.setInForeground();
    this.#disableEditing = true;
    this.div.classList.add("disabled");
    this.#fitToContent(true);
    this.makeResizable();
    this.parent.addInkEditorIfNeeded(true);
    this.moveInDOM();
    this.div.focus({
      preventScroll: true
    });
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    super.focusin(event);
    this.enableEditMode();
  }
  canvasPointerdown(event) {
    if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) {
      return;
    }
    this.setInForeground();
    event.preventDefault();
    if (event.type !== "mouse") {
      this.div.focus();
    }
    this.#startDrawing(event.offsetX, event.offsetY);
  }
  canvasPointermove(event) {
    event.preventDefault();
    this.#draw(event.offsetX, event.offsetY);
  }
  canvasPointerup(event) {
    event.preventDefault();
    this.#endDrawing(event);
  }
  canvasPointerleave(event) {
    this.#endDrawing(event);
  }
  #endDrawing(event) {
    this.canvas.removeEventListener("pointerleave", this.#boundCanvasPointerleave);
    this.canvas.removeEventListener("pointermove", this.#boundCanvasPointermove);
    this.canvas.removeEventListener("pointerup", this.#boundCanvasPointerup);
    this.canvas.addEventListener("pointerdown", this.#boundCanvasPointerdown);
    setTimeout(() => {
      this.canvas.removeEventListener("contextmenu", _display_utils.noContextMenu);
    }, 10);
    this.#stopDrawing(event.offsetX, event.offsetY);
    this.addToAnnotationStorage();
    this.setInBackground();
  }
  #createCanvas() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.canvas.height = 0;
    this.canvas.className = "inkEditorCanvas";
    _editor.AnnotationEditor._l10nPromise.get("editor_ink_canvas_aria_label").then(msg => this.canvas?.setAttribute("aria-label", msg));
    this.div.append(this.canvas);
    this.ctx = this.canvas.getContext("2d");
  }
  #createObserver() {
    this.#observer = new ResizeObserver(entries => {
      const rect = entries[0].contentRect;
      if (rect.width && rect.height) {
        this.setDimensions(rect.width, rect.height);
      }
    });
    this.#observer.observe(this.div);
  }
  get isResizable() {
    return !this.isEmpty() && this.#disableEditing;
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this.width) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    _editor.AnnotationEditor._l10nPromise.get("editor_ink2_aria_label").then(msg => this.div?.setAttribute("aria-label", msg));
    const [x, y, w, h] = this.#getInitialBBox();
    this.setAt(x, y, 0, 0);
    this.setDims(w, h);
    this.#createCanvas();
    if (this.width) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      this.setAspectRatio(this.width * parentWidth, this.height * parentHeight);
      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
      this.#isCanvasInitialized = true;
      this.#setCanvasDims();
      this.setDims(this.width * parentWidth, this.height * parentHeight);
      this.#redraw();
      this.div.classList.add("disabled");
    } else {
      this.div.classList.add("editing");
      this.enableEditMode();
    }
    this.#createObserver();
    return this.div;
  }
  #setCanvasDims() {
    if (!this.#isCanvasInitialized) {
      return;
    }
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.canvas.width = Math.ceil(this.width * parentWidth);
    this.canvas.height = Math.ceil(this.height * parentHeight);
    this.#updateTransform();
  }
  setDimensions(width, height) {
    const roundedWidth = Math.round(width);
    const roundedHeight = Math.round(height);
    if (this.#realWidth === roundedWidth && this.#realHeight === roundedHeight) {
      return;
    }
    this.#realWidth = roundedWidth;
    this.#realHeight = roundedHeight;
    this.canvas.style.visibility = "hidden";
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.width = width / parentWidth;
    this.height = height / parentHeight;
    this.fixAndSetPosition();
    if (this.#disableEditing) {
      this.#setScaleFactor(width, height);
    }
    this.#setCanvasDims();
    this.#redraw();
    this.canvas.style.visibility = "visible";
    this.fixDims();
  }
  #setScaleFactor(width, height) {
    const padding = this.#getPadding();
    const scaleFactorW = (width - padding) / this.#baseWidth;
    const scaleFactorH = (height - padding) / this.#baseHeight;
    this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);
  }
  #updateTransform() {
    const padding = this.#getPadding() / 2;
    this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);
  }
  static #buildPath2D(bezier) {
    const path2D = new Path2D();
    for (let i = 0, ii = bezier.length; i < ii; i++) {
      const [first, control1, control2, second] = bezier[i];
      if (i === 0) {
        path2D.moveTo(...first);
      }
      path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);
    }
    return path2D;
  }
  static #toPDFCoordinates(points, rect, rotation) {
    const [blX, blY, trX, trY] = rect;
    switch (rotation) {
      case 0:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          points[i] += blX;
          points[i + 1] = trY - points[i + 1];
        }
        break;
      case 90:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          const x = points[i];
          points[i] = points[i + 1] + blX;
          points[i + 1] = x + blY;
        }
        break;
      case 180:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          points[i] = trX - points[i];
          points[i + 1] += blY;
        }
        break;
      case 270:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          const x = points[i];
          points[i] = trX - points[i + 1];
          points[i + 1] = trY - x;
        }
        break;
      default:
        throw new Error("Invalid rotation");
    }
    return points;
  }
  static #fromPDFCoordinates(points, rect, rotation) {
    const [blX, blY, trX, trY] = rect;
    switch (rotation) {
      case 0:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          points[i] -= blX;
          points[i + 1] = trY - points[i + 1];
        }
        break;
      case 90:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          const x = points[i];
          points[i] = points[i + 1] - blY;
          points[i + 1] = x - blX;
        }
        break;
      case 180:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          points[i] = trX - points[i];
          points[i + 1] -= blY;
        }
        break;
      case 270:
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          const x = points[i];
          points[i] = trY - points[i + 1];
          points[i + 1] = trX - x;
        }
        break;
      default:
        throw new Error("Invalid rotation");
    }
    return points;
  }
  #serializePaths(s, tx, ty, rect) {
    const paths = [];
    const padding = this.thickness / 2;
    const shiftX = s * tx + padding;
    const shiftY = s * ty + padding;
    for (const bezier of this.paths) {
      const buffer = [];
      const points = [];
      for (let j = 0, jj = bezier.length; j < jj; j++) {
        const [first, control1, control2, second] = bezier[j];
        const p10 = s * first[0] + shiftX;
        const p11 = s * first[1] + shiftY;
        const p20 = s * control1[0] + shiftX;
        const p21 = s * control1[1] + shiftY;
        const p30 = s * control2[0] + shiftX;
        const p31 = s * control2[1] + shiftY;
        const p40 = s * second[0] + shiftX;
        const p41 = s * second[1] + shiftY;
        if (j === 0) {
          buffer.push(p10, p11);
          points.push(p10, p11);
        }
        buffer.push(p20, p21, p30, p31, p40, p41);
        points.push(p20, p21);
        if (j === jj - 1) {
          points.push(p40, p41);
        }
      }
      paths.push({
        bezier: InkEditor.#toPDFCoordinates(buffer, rect, this.rotation),
        points: InkEditor.#toPDFCoordinates(points, rect, this.rotation)
      });
    }
    return paths;
  }
  #getBbox() {
    let xMin = Infinity;
    let xMax = -Infinity;
    let yMin = Infinity;
    let yMax = -Infinity;
    for (const path of this.paths) {
      for (const [first, control1, control2, second] of path) {
        const bbox = _util.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);
        xMin = Math.min(xMin, bbox[0]);
        yMin = Math.min(yMin, bbox[1]);
        xMax = Math.max(xMax, bbox[2]);
        yMax = Math.max(yMax, bbox[3]);
      }
    }
    return [xMin, yMin, xMax, yMax];
  }
  #getPadding() {
    return this.#disableEditing ? Math.ceil(this.thickness * this.parentScale) : 0;
  }
  #fitToContent(firstTime = false) {
    if (this.isEmpty()) {
      return;
    }
    if (!this.#disableEditing) {
      this.#redraw();
      return;
    }
    const bbox = this.#getBbox();
    const padding = this.#getPadding();
    this.#baseWidth = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);
    this.#baseHeight = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);
    const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor);
    const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor);
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.width = width / parentWidth;
    this.height = height / parentHeight;
    this.setAspectRatio(width, height);
    const prevTranslationX = this.translationX;
    const prevTranslationY = this.translationY;
    this.translationX = -bbox[0];
    this.translationY = -bbox[1];
    this.#setCanvasDims();
    this.#redraw();
    this.#realWidth = width;
    this.#realHeight = height;
    this.setDims(width, height);
    const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;
    this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);
  }
  static deserialize(data, parent, uiManager) {
    if (data instanceof _annotation_layer.InkAnnotationElement) {
      return null;
    }
    const editor = super.deserialize(data, parent, uiManager);
    editor.thickness = data.thickness;
    editor.color = _util.Util.makeHexColor(...data.color);
    editor.opacity = data.opacity;
    const [pageWidth, pageHeight] = editor.pageDimensions;
    const width = editor.width * pageWidth;
    const height = editor.height * pageHeight;
    const scaleFactor = editor.parentScale;
    const padding = data.thickness / 2;
    editor.#disableEditing = true;
    editor.#realWidth = Math.round(width);
    editor.#realHeight = Math.round(height);
    const {
      paths,
      rect,
      rotation
    } = data;
    for (let {
      bezier
    } of paths) {
      bezier = InkEditor.#fromPDFCoordinates(bezier, rect, rotation);
      const path = [];
      editor.paths.push(path);
      let p0 = scaleFactor * (bezier[0] - padding);
      let p1 = scaleFactor * (bezier[1] - padding);
      for (let i = 2, ii = bezier.length; i < ii; i += 6) {
        const p10 = scaleFactor * (bezier[i] - padding);
        const p11 = scaleFactor * (bezier[i + 1] - padding);
        const p20 = scaleFactor * (bezier[i + 2] - padding);
        const p21 = scaleFactor * (bezier[i + 3] - padding);
        const p30 = scaleFactor * (bezier[i + 4] - padding);
        const p31 = scaleFactor * (bezier[i + 5] - padding);
        path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);
        p0 = p30;
        p1 = p31;
      }
      const path2D = this.#buildPath2D(path);
      editor.bezierPath2D.push(path2D);
    }
    const bbox = editor.#getBbox();
    editor.#baseWidth = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);
    editor.#baseHeight = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);
    editor.#setScaleFactor(width, height);
    return editor;
  }
  serialize() {
    if (this.isEmpty()) {
      return null;
    }
    const rect = this.getRect(0, 0);
    const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
    return {
      annotationType: _util.AnnotationEditorType.INK,
      color,
      thickness: this.thickness,
      opacity: this.opacity,
      paths: this.#serializePaths(this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect),
      pageIndex: this.pageIndex,
      rect,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
  }
}
exports.InkEditor = InkEditor;

/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StampEditor = void 0;
var _util = __w_pdfjs_require__(1);
var _editor = __w_pdfjs_require__(4);
var _display_utils = __w_pdfjs_require__(6);
var _annotation_layer = __w_pdfjs_require__(29);
class StampEditor extends _editor.AnnotationEditor {
  #bitmap = null;
  #bitmapId = null;
  #bitmapPromise = null;
  #bitmapUrl = null;
  #bitmapFile = null;
  #canvas = null;
  #observer = null;
  #resizeTimeoutId = null;
  #isSvg = false;
  #hasBeenAddedInUndoStack = false;
  static _type = "stamp";
  constructor(params) {
    super({
      ...params,
      name: "stampEditor"
    });
    this.#bitmapUrl = params.bitmapUrl;
    this.#bitmapFile = params.bitmapFile;
  }
  static initialize(l10n) {
    _editor.AnnotationEditor.initialize(l10n);
  }
  static get supportedTypes() {
    const types = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
    return (0, _util.shadow)(this, "supportedTypes", types.map(type => `image/${type}`));
  }
  static get supportedTypesStr() {
    return (0, _util.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
  }
  static isHandlingMimeForPasting(mime) {
    return this.supportedTypes.includes(mime);
  }
  static paste(item, parent) {
    parent.pasteEditor(_util.AnnotationEditorType.STAMP, {
      bitmapFile: item.getAsFile()
    });
  }
  #getBitmapFetched(data, fromId = false) {
    if (!data) {
      this.remove();
      return;
    }
    this.#bitmap = data.bitmap;
    if (!fromId) {
      this.#bitmapId = data.id;
      this.#isSvg = data.isSvg;
    }
    this.#createCanvas();
  }
  #getBitmapDone() {
    this.#bitmapPromise = null;
    this._uiManager.enableWaiting(false);
    if (this.#canvas) {
      this.div.focus();
    }
  }
  #getBitmap() {
    if (this.#bitmapId) {
      this._uiManager.enableWaiting(true);
      this._uiManager.imageManager.getFromId(this.#bitmapId).then(data => this.#getBitmapFetched(data, true)).finally(() => this.#getBitmapDone());
      return;
    }
    if (this.#bitmapUrl) {
      const url = this.#bitmapUrl;
      this.#bitmapUrl = null;
      this._uiManager.enableWaiting(true);
      this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());
      return;
    }
    if (this.#bitmapFile) {
      const file = this.#bitmapFile;
      this.#bitmapFile = null;
      this._uiManager.enableWaiting(true);
      this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());
      return;
    }
    const input = document.createElement("input");
    input.type = "file";
    input.accept = StampEditor.supportedTypesStr;
    this.#bitmapPromise = new Promise(resolve => {
      input.addEventListener("change", async () => {
        if (!input.files || input.files.length === 0) {
          this.remove();
        } else {
          this._uiManager.enableWaiting(true);
          const data = await this._uiManager.imageManager.getFromFile(input.files[0]);
          this.#getBitmapFetched(data);
        }
        resolve();
      });
      input.addEventListener("cancel", () => {
        this.remove();
        resolve();
      });
    }).finally(() => this.#getBitmapDone());
    input.click();
  }
  remove() {
    if (this.#bitmapId) {
      this.#bitmap = null;
      this._uiManager.imageManager.deleteId(this.#bitmapId);
      this.#canvas?.remove();
      this.#canvas = null;
      this.#observer?.disconnect();
      this.#observer = null;
    }
    super.remove();
  }
  rebuild() {
    if (!this.parent) {
      if (this.#bitmapId) {
        this.#getBitmap();
      }
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (this.#bitmapId) {
      this.#getBitmap();
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  onceAdded() {
    this._isDraggable = true;
    this.div.focus();
  }
  isEmpty() {
    return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile);
  }
  get isResizable() {
    return true;
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this.width) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    this.div.hidden = true;
    if (this.#bitmap) {
      this.#createCanvas();
    } else {
      this.#getBitmap();
    }
    if (this.width) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
    }
    return this.div;
  }
  #createCanvas() {
    const {
      div
    } = this;
    let {
      width,
      height
    } = this.#bitmap;
    const [pageWidth, pageHeight] = this.pageDimensions;
    const MAX_RATIO = 0.75;
    if (this.width) {
      width = this.width * pageWidth;
      height = this.height * pageHeight;
    } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {
      const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);
      width *= factor;
      height *= factor;
    }
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);
    this._uiManager.enableWaiting(false);
    const canvas = this.#canvas = document.createElement("canvas");
    div.append(canvas);
    div.hidden = false;
    this.#drawBitmap(width, height);
    this.#createObserver();
    if (!this.#hasBeenAddedInUndoStack) {
      this.parent.addUndoableEditor(this);
      this.#hasBeenAddedInUndoStack = true;
    }
    this._uiManager._eventBus.dispatch("reporttelemetry", {
      source: this,
      details: {
        type: "editing",
        subtype: this.editorType,
        data: {
          action: "inserted_image"
        }
      }
    });
    this.addAltTextButton();
  }
  #setDimensions(width, height) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.width = width / parentWidth;
    this.height = height / parentHeight;
    this.setDims(width, height);
    if (this._initialOptions?.isCentered) {
      this.center();
    } else {
      this.fixAndSetPosition();
    }
    this._initialOptions = null;
    if (this.#resizeTimeoutId !== null) {
      clearTimeout(this.#resizeTimeoutId);
    }
    const TIME_TO_WAIT = 200;
    this.#resizeTimeoutId = setTimeout(() => {
      this.#resizeTimeoutId = null;
      this.#drawBitmap(width, height);
    }, TIME_TO_WAIT);
  }
  #scaleBitmap(width, height) {
    const {
      width: bitmapWidth,
      height: bitmapHeight
    } = this.#bitmap;
    let newWidth = bitmapWidth;
    let newHeight = bitmapHeight;
    let bitmap = this.#bitmap;
    while (newWidth > 2 * width || newHeight > 2 * height) {
      const prevWidth = newWidth;
      const prevHeight = newHeight;
      if (newWidth > 2 * width) {
        newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);
      }
      if (newHeight > 2 * height) {
        newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);
      }
      const offscreen = new OffscreenCanvas(newWidth, newHeight);
      const ctx = offscreen.getContext("2d");
      ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
      bitmap = offscreen.transferToImageBitmap();
    }
    return bitmap;
  }
  #drawBitmap(width, height) {
    width = Math.ceil(width);
    height = Math.ceil(height);
    const canvas = this.#canvas;
    if (!canvas || canvas.width === width && canvas.height === height) {
      return;
    }
    canvas.width = width;
    canvas.height = height;
    const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(width, height);
    const ctx = canvas.getContext("2d");
    ctx.filter = this._uiManager.hcmFilter;
    ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, width, height);
  }
  #serializeBitmap(toUrl) {
    if (toUrl) {
      if (this.#isSvg) {
        const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);
        if (url) {
          return url;
        }
      }
      const canvas = document.createElement("canvas");
      ({
        width: canvas.width,
        height: canvas.height
      } = this.#bitmap);
      const ctx = canvas.getContext("2d");
      ctx.drawImage(this.#bitmap, 0, 0);
      return canvas.toDataURL();
    }
    if (this.#isSvg) {
      const [pageWidth, pageHeight] = this.pageDimensions;
      const width = Math.round(this.width * pageWidth * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);
      const height = Math.round(this.height * pageHeight * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);
      const offscreen = new OffscreenCanvas(width, height);
      const ctx = offscreen.getContext("2d");
      ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);
      return offscreen.transferToImageBitmap();
    }
    return structuredClone(this.#bitmap);
  }
  #createObserver() {
    this.#observer = new ResizeObserver(entries => {
      const rect = entries[0].contentRect;
      if (rect.width && rect.height) {
        this.#setDimensions(rect.width, rect.height);
      }
    });
    this.#observer.observe(this.div);
  }
  static deserialize(data, parent, uiManager) {
    if (data instanceof _annotation_layer.StampAnnotationElement) {
      return null;
    }
    const editor = super.deserialize(data, parent, uiManager);
    const {
      rect,
      bitmapUrl,
      bitmapId,
      isSvg,
      accessibilityData
    } = data;
    if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {
      editor.#bitmapId = bitmapId;
    } else {
      editor.#bitmapUrl = bitmapUrl;
    }
    editor.#isSvg = isSvg;
    const [parentWidth, parentHeight] = editor.pageDimensions;
    editor.width = (rect[2] - rect[0]) / parentWidth;
    editor.height = (rect[3] - rect[1]) / parentHeight;
    if (accessibilityData) {
      editor.altTextData = accessibilityData;
    }
    return editor;
  }
  serialize(isForCopying = false, context = null) {
    if (this.isEmpty()) {
      return null;
    }
    const serialized = {
      annotationType: _util.AnnotationEditorType.STAMP,
      bitmapId: this.#bitmapId,
      pageIndex: this.pageIndex,
      rect: this.getRect(0, 0),
      rotation: this.rotation,
      isSvg: this.#isSvg,
      structTreeParentId: this._structTreeParentId
    };
    if (isForCopying) {
      serialized.bitmapUrl = this.#serializeBitmap(true);
      serialized.accessibilityData = this.altTextData;
      return serialized;
    }
    const {
      decorative,
      altText
    } = this.altTextData;
    if (!decorative && altText) {
      serialized.accessibilityData = {
        type: "Figure",
        alt: altText
      };
    }
    if (context === null) {
      return serialized;
    }
    context.stamps ||= new Map();
    const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;
    if (!context.stamps.has(this.#bitmapId)) {
      context.stamps.set(this.#bitmapId, {
        area,
        serialized
      });
      serialized.bitmap = this.#serializeBitmap(false);
    } else if (this.#isSvg) {
      const prevData = context.stamps.get(this.#bitmapId);
      if (area > prevData.area) {
        prevData.area = area;
        prevData.serialized.bitmap.close();
        prevData.serialized.bitmap = this.#serializeBitmap(false);
      }
    }
    return serialized;
  }
}
exports.StampEditor = StampEditor;

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __nested_webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __nested_webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "AbortException", ({
  enumerable: true,
  get: function () {
    return _util.AbortException;
  }
}));
Object.defineProperty(exports, "AnnotationEditorLayer", ({
  enumerable: true,
  get: function () {
    return _annotation_editor_layer.AnnotationEditorLayer;
  }
}));
Object.defineProperty(exports, "AnnotationEditorParamsType", ({
  enumerable: true,
  get: function () {
    return _util.AnnotationEditorParamsType;
  }
}));
Object.defineProperty(exports, "AnnotationEditorType", ({
  enumerable: true,
  get: function () {
    return _util.AnnotationEditorType;
  }
}));
Object.defineProperty(exports, "AnnotationEditorUIManager", ({
  enumerable: true,
  get: function () {
    return _tools.AnnotationEditorUIManager;
  }
}));
Object.defineProperty(exports, "AnnotationLayer", ({
  enumerable: true,
  get: function () {
    return _annotation_layer.AnnotationLayer;
  }
}));
Object.defineProperty(exports, "AnnotationMode", ({
  enumerable: true,
  get: function () {
    return _util.AnnotationMode;
  }
}));
Object.defineProperty(exports, "CMapCompressionType", ({
  enumerable: true,
  get: function () {
    return _util.CMapCompressionType;
  }
}));
Object.defineProperty(exports, "DOMSVGFactory", ({
  enumerable: true,
  get: function () {
    return _display_utils.DOMSVGFactory;
  }
}));
Object.defineProperty(exports, "FeatureTest", ({
  enumerable: true,
  get: function () {
    return _util.FeatureTest;
  }
}));
Object.defineProperty(exports, "GlobalWorkerOptions", ({
  enumerable: true,
  get: function () {
    return _worker_options.GlobalWorkerOptions;
  }
}));
Object.defineProperty(exports, "ImageKind", ({
  enumerable: true,
  get: function () {
    return _util.ImageKind;
  }
}));
Object.defineProperty(exports, "InvalidPDFException", ({
  enumerable: true,
  get: function () {
    return _util.InvalidPDFException;
  }
}));
Object.defineProperty(exports, "MissingPDFException", ({
  enumerable: true,
  get: function () {
    return _util.MissingPDFException;
  }
}));
Object.defineProperty(exports, "OPS", ({
  enumerable: true,
  get: function () {
    return _util.OPS;
  }
}));
Object.defineProperty(exports, "PDFDataRangeTransport", ({
  enumerable: true,
  get: function () {
    return _api.PDFDataRangeTransport;
  }
}));
Object.defineProperty(exports, "PDFDateString", ({
  enumerable: true,
  get: function () {
    return _display_utils.PDFDateString;
  }
}));
Object.defineProperty(exports, "PDFWorker", ({
  enumerable: true,
  get: function () {
    return _api.PDFWorker;
  }
}));
Object.defineProperty(exports, "PasswordResponses", ({
  enumerable: true,
  get: function () {
    return _util.PasswordResponses;
  }
}));
Object.defineProperty(exports, "PermissionFlag", ({
  enumerable: true,
  get: function () {
    return _util.PermissionFlag;
  }
}));
Object.defineProperty(exports, "PixelsPerInch", ({
  enumerable: true,
  get: function () {
    return _display_utils.PixelsPerInch;
  }
}));
Object.defineProperty(exports, "PromiseCapability", ({
  enumerable: true,
  get: function () {
    return _util.PromiseCapability;
  }
}));
Object.defineProperty(exports, "RenderingCancelledException", ({
  enumerable: true,
  get: function () {
    return _display_utils.RenderingCancelledException;
  }
}));
Object.defineProperty(exports, "SVGGraphics", ({
  enumerable: true,
  get: function () {
    return _api.SVGGraphics;
  }
}));
Object.defineProperty(exports, "UnexpectedResponseException", ({
  enumerable: true,
  get: function () {
    return _util.UnexpectedResponseException;
  }
}));
Object.defineProperty(exports, "Util", ({
  enumerable: true,
  get: function () {
    return _util.Util;
  }
}));
Object.defineProperty(exports, "VerbosityLevel", ({
  enumerable: true,
  get: function () {
    return _util.VerbosityLevel;
  }
}));
Object.defineProperty(exports, "XfaLayer", ({
  enumerable: true,
  get: function () {
    return _xfa_layer.XfaLayer;
  }
}));
Object.defineProperty(exports, "build", ({
  enumerable: true,
  get: function () {
    return _api.build;
  }
}));
Object.defineProperty(exports, "createValidAbsoluteUrl", ({
  enumerable: true,
  get: function () {
    return _util.createValidAbsoluteUrl;
  }
}));
Object.defineProperty(exports, "getDocument", ({
  enumerable: true,
  get: function () {
    return _api.getDocument;
  }
}));
Object.defineProperty(exports, "getFilenameFromUrl", ({
  enumerable: true,
  get: function () {
    return _display_utils.getFilenameFromUrl;
  }
}));
Object.defineProperty(exports, "getPdfFilenameFromUrl", ({
  enumerable: true,
  get: function () {
    return _display_utils.getPdfFilenameFromUrl;
  }
}));
Object.defineProperty(exports, "getXfaPageViewport", ({
  enumerable: true,
  get: function () {
    return _display_utils.getXfaPageViewport;
  }
}));
Object.defineProperty(exports, "isDataScheme", ({
  enumerable: true,
  get: function () {
    return _display_utils.isDataScheme;
  }
}));
Object.defineProperty(exports, "isPdfFile", ({
  enumerable: true,
  get: function () {
    return _display_utils.isPdfFile;
  }
}));
Object.defineProperty(exports, "loadScript", ({
  enumerable: true,
  get: function () {
    return _display_utils.loadScript;
  }
}));
Object.defineProperty(exports, "noContextMenu", ({
  enumerable: true,
  get: function () {
    return _display_utils.noContextMenu;
  }
}));
Object.defineProperty(exports, "normalizeUnicode", ({
  enumerable: true,
  get: function () {
    return _util.normalizeUnicode;
  }
}));
Object.defineProperty(exports, "renderTextLayer", ({
  enumerable: true,
  get: function () {
    return _text_layer.renderTextLayer;
  }
}));
Object.defineProperty(exports, "setLayerDimensions", ({
  enumerable: true,
  get: function () {
    return _display_utils.setLayerDimensions;
  }
}));
Object.defineProperty(exports, "shadow", ({
  enumerable: true,
  get: function () {
    return _util.shadow;
  }
}));
Object.defineProperty(exports, "updateTextLayer", ({
  enumerable: true,
  get: function () {
    return _text_layer.updateTextLayer;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _api.version;
  }
}));
var _util = __w_pdfjs_require__(1);
var _api = __w_pdfjs_require__(2);
var _display_utils = __w_pdfjs_require__(6);
var _text_layer = __w_pdfjs_require__(26);
var _annotation_editor_layer = __w_pdfjs_require__(27);
var _tools = __w_pdfjs_require__(5);
var _annotation_layer = __w_pdfjs_require__(29);
var _worker_options = __w_pdfjs_require__(14);
var _xfa_layer = __w_pdfjs_require__(32);
const pdfjsVersion = '3.11.174';
const pdfjsBuild = 'ce8716743';
})();

/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=pdf.js.map

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/util/node_modules/inherits/inherits_browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*********************************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(__webpack_require__.g.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/util/node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}


/***/ }),

/***/ "./src/script/elementEnhancement.js":
/*!******************************************!*\
  !*** ./src/script/elementEnhancement.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElementEnhancement = void 0;
class ElementEnhancement {
    constructor(option) {
        this.option = option;
        this.el = null;
        this.selectors = {};
        if (option.selector) {
            this.el = document.querySelector(option.selector);
        }
        else {
            this.el = option.el;
        }
    }
    isAvailable() {
        return !!this.el;
    }
    define(option) {
        this.selectors[option.name] = option.selector;
        return this;
    }
    get(name) {
        return this.el.querySelector(this.selectors[name]);
    }
    gets(name) {
        return Array.from(this.el.querySelectorAll(this.selectors[name]));
    }
    static fromSelector(selector, Cons = ElementEnhancement) {
        return Array.from(document.querySelectorAll(selector)).map(el => new Cons({ el: el }));
    }
    static firstFromSelector(selector, Cons = ElementEnhancement) {
        return new Cons({ el: document.querySelector(selector) });
    }
}
exports.ElementEnhancement = ElementEnhancement;


/***/ }),

/***/ "./src/script/entry/openDataCatelogSite.js":
/*!*************************************************!*\
  !*** ./src/script/entry/openDataCatelogSite.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const pdfjsLib = __importStar(__webpack_require__(/*! pdfjs-dist */ "./node_modules/pdfjs-dist/build/pdf.js"));
const previewFeature_1 = __webpack_require__(/*! ../ttjh/previewFeature */ "./src/script/ttjh/previewFeature.js");
const stylingFeature_1 = __webpack_require__(/*! ../ttjh/stylingFeature */ "./src/script/ttjh/stylingFeature.js");
// Set the worker source
pdfjsLib.GlobalWorkerOptions.workerSrc = chrome.runtime.getURL('pdf.worker.js');
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        const title = document.querySelector('title');
        if (title) {
            console.log('Page Title:', title.innerText);
        }
        let preview = new previewFeature_1.PreviewFeature();
        let styling = new stylingFeature_1.StylingFeature();
        yield styling.enhance();
        yield preview.enhance();
    });
}
if (document.readyState === 'complete') {
    main();
}
else {
    document.addEventListener("readystatechange", () => {
        if (document.readyState === 'complete') {
            main();
        }
    });
}
console.error("????");


/***/ }),

/***/ "./src/script/pdf/pdfAnalyzer.js":
/*!***************************************!*\
  !*** ./src/script/pdf/pdfAnalyzer.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PdfSearcherContext = exports.PdfAnalyzer = void 0;
const commonUI_1 = __webpack_require__(/*! @branch-ts/web/src/ui/commonUI/commonUI */ "./node_modules/@branch-ts/web/src/ui/commonUI/commonUI.js");
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
const pdfjsLib = __importStar(__webpack_require__(/*! pdfjs-dist */ "./node_modules/pdfjs-dist/build/pdf.js"));
let PdfAnalyzer = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _load_decorators;
    return _a = class PdfAnalyzer {
            constructor() {
                this.situation = (__runInitializers(this, _instanceExtraInitializers), new Leaf.Situations({
                    pdfProxy: null,
                    error: null,
                    finish: false,
                }));
                this.scale = 1.5;
                this.pageCache = {};
                this.situation.events.on("error", (e) => {
                    if (e) {
                        commonUI_1.CommonUI.error(e);
                    }
                });
            }
            reset() {
                this.situation.set("pdfProxy", null);
                this.situation.set("error", null);
                this.situation.set("finish", false);
            }
            load(data) {
                this.reset();
                let task = pdfjsLib.getDocument({ data });
                task.promise.then(pdf => {
                    this.situation.set("pdfProxy", pdf);
                    this.situation.set("finish", true);
                });
                task.promise.catch(error => {
                    this.situation.set("error", error);
                    this.situation.set("finish", true);
                });
            }
            wait() {
                return __awaiter(this, void 0, void 0, function* () {
                    yield this.situation.wait("finish", true);
                });
            }
            get pdf() {
                return this.situation.get("pdfProxy");
            }
            ensureSearchContext() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.searchContext) {
                        return;
                    }
                    let contents = [];
                    for (let i = 1; i <= this.pdf.numPages; i++) {
                        let page = yield this.getPage(i);
                        let content = yield page.getTextContent();
                        contents.push(content);
                    }
                    this.searchContext = new PdfSearcherContext(contents);
                    this.searchContext.build();
                });
            }
            search(keyword) {
                return __awaiter(this, void 0, void 0, function* () {
                    yield this.ensureSearchContext();
                    return this.searchContext.search({ keyword, max: 10 });
                });
            }
            getPage(pageNum) {
                return __awaiter(this, void 0, void 0, function* () {
                    console.error("Get page", pageNum, this.pdf.numPages);
                    yield this.wait();
                    let page = this.pageCache[pageNum];
                    if (!page) {
                        page = yield this.pdf.getPage(pageNum);
                        this.pageCache[pageNum] = page;
                    }
                    return page;
                });
            }
            getPageImage(pageNum) {
                return __awaiter(this, void 0, void 0, function* () {
                    let page = yield this.getPage(pageNum);
                    const viewport = page.getViewport({ scale: this.scale });
                    // Prepare canvas using PDF page dimensions
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    const renderContext = {
                        canvasContext: context,
                        viewport: viewport
                    };
                    let renderTask = page.render(renderContext);
                    yield renderTask.promise;
                    let imageUrl = canvas.toDataURL("image/png");
                    return { url: imageUrl, width: viewport.width, height: viewport.height, scale: this.scale };
                });
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _load_decorators = [Leaf.lock()];
            __esDecorate(_a, null, _load_decorators, { kind: "method", name: "load", static: false, private: false, access: { has: obj => "load" in obj, get: obj => obj.load }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.PdfAnalyzer = PdfAnalyzer;
class PdfSearcherContext {
    constructor(contents) {
        this.contents = contents;
        this.sourceMap = [];
    }
    search(option) {
        let max = 10;
        this.build();
        let reg = new RegExp(option.keyword, "ig");
        let matches = Array.from(this.fullText.matchAll(reg) || []);
        let result = [];
        for (let [index, item] of matches.entries()) {
            if (index >= max)
                break;
            let start = item.index;
            let end = start + item[0].length;
            let sourceMaps = this.getSourceMapBetween(start, end);
            result.push({
                pageNum: sourceMaps[0].textContentIndex + 1,
                match: item[0],
                boundingBoxes: sourceMaps.map(item => {
                    let content = this.contents[item.textContentIndex].items[item.textContentItemIndex];
                    let transform = content.transform;
                    return {
                        x: transform[4],
                        y: transform[5],
                        width: content.width,
                        height: content.height,
                        content,
                    };
                })
            });
        }
        return result;
    }
    build() {
        if (this.fullText)
            return;
        let fullText = "";
        let sourceMap = [];
        for (let [textContentIndex, content] of this.contents.entries()) {
            for (let [textContentItemIndex, item] of content.items.entries()) {
                let textItem = item;
                let content = textItem.str.trim();
                if (content.length == 0)
                    continue;
                sourceMap.push({
                    offset: fullText.length,
                    textContentIndex,
                    textContentItemIndex,
                    content
                });
                fullText += content;
            }
        }
        this.fullText = fullText;
        this.sourceMap = sourceMap;
    }
    getSourceMapBetween(start, end) {
        return this.sourceMap.filter(item => {
            let itemStart = item.offset;
            let itemEnd = item.offset + item.content.length;
            return itemEnd > start && itemStart < end;
        });
    }
}
exports.PdfSearcherContext = PdfSearcherContext;


/***/ }),

/***/ "./src/script/ttjh/pdfInstantPreview.html.R.js":
/*!*****************************************************!*\
  !*** ./src/script/ttjh/pdfInstantPreview.html.R.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.R = void 0;
const Leaf = __importStar(__webpack_require__(/*! leaf-ts */ "./node_modules/leaf-ts/dist/leaf.js"));
var R;
(function (R) {
    class PdfInstantPreview extends Leaf.GeneratedWidget {
        constructor() {
            super(function () {
                var _e = this._e.bind(this);
                var _t = this._t.bind(this);
                return _e("div", { "class": { "name": "class", "templates": [{ "type": "raw", "content": "pdf-instant-preview-573cc1" }] } }, [_t({ "templates": [{ "type": "raw", "content": "\n    " }] }), _e("span", { "class": { "name": "class", "templates": [{ "type": "raw", "content": "hint" }] } }, [_t({ "templates": [{ "type": "value", "content": "hint", "reverse": false }] })]), _t({ "templates": [{ "type": "raw", "content": "\n    " }] }), _e("div", { "data-list": { "name": "data-list", "templates": [{ "type": "raw", "content": "previewList" }] } }, [_t({ "templates": [{ "type": "raw", "content": "\n\n    " }] })]), _t({ "templates": [{ "type": "raw", "content": "\n" }] })]);
            }, "PdfInstantPreview", ["hint"]);
            this.TestDatas = PdfInstantPreview.TestDatas;
            this.BindedLists = PdfInstantPreview.BindedLists;
            this.BindedWidgets = PdfInstantPreview.BindedWidgets;
            this.InitialData = PdfInstantPreview.InitialData;
            this.path = PdfInstantPreview.path;
            this.GeneratedConstructor = PdfInstantPreview;
            if (PdfInstantPreview.InitialData) {
                this.renderRecursive(PdfInstantPreview.InitialData);
            }
        }
    }
    PdfInstantPreview.TestDatas = [];
    PdfInstantPreview.BindedLists = [{ "name": "previewList", "type": "void", "reference": null }];
    PdfInstantPreview.BindedWidgets = [];
    PdfInstantPreview.path = "/ttjh/pdfInstantPreview";
    PdfInstantPreview.widgetName = "PdfInstantPreview";
    PdfInstantPreview.InitialData = null;
    R.PdfInstantPreview = PdfInstantPreview;
    PdfInstantPreview["prototype"].widgetName = "PdfInstantPreview";
    (function (PdfInstantPreview) {
        class PreviewListItem extends Leaf.GeneratedWidget {
            constructor() {
                super(function () {
                    var _e = this._e.bind(this);
                    var _t = this._t.bind(this);
                    return _e("div", { "class": { "name": "class", "templates": [{ "type": "raw", "content": "preview-list-item-bcfe96" }] } }, [_t({ "templates": [{ "type": "raw", "content": "\n        " }] }), _e("img", { "data-id": { "name": "data-id", "templates": [{ "type": "raw", "content": "previewImage" }] } }, []), _t({ "templates": [{ "type": "raw", "content": "\n    " }] })]);
                }, "PreviewListItem", []);
                this.TestDatas = PreviewListItem.TestDatas;
                this.BindedLists = PreviewListItem.BindedLists;
                this.BindedWidgets = PreviewListItem.BindedWidgets;
                this.InitialData = PreviewListItem.InitialData;
                this.path = PreviewListItem.path;
                this.GeneratedConstructor = PreviewListItem;
                if (PreviewListItem.InitialData) {
                    this.renderRecursive(PreviewListItem.InitialData);
                }
            }
        }
        PreviewListItem.TestDatas = [];
        PreviewListItem.BindedLists = [];
        PreviewListItem.BindedWidgets = [];
        PreviewListItem.path = "/ttjh/pdfInstantPreview/previewListItem";
        PreviewListItem.widgetName = "PreviewListItem";
        PreviewListItem.InitialData = null;
        PdfInstantPreview.PreviewListItem = PreviewListItem;
        PreviewListItem["prototype"].widgetName = "PreviewListItem";
    })(PdfInstantPreview = R.PdfInstantPreview || (R.PdfInstantPreview = {}));
})(R || (exports.R = R = {}));


/***/ }),

/***/ "./src/script/ttjh/pdfInstantPreview.js":
/*!**********************************************!*\
  !*** ./src/script/ttjh/pdfInstantPreview.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreviewListItem = exports.PdfInstantPreview = void 0;
const pdfInstantPreview_html_R_1 = __webpack_require__(/*! ./pdfInstantPreview.html.R */ "./src/script/ttjh/pdfInstantPreview.html.R.js");
class PdfInstantPreview extends pdfInstantPreview_html_R_1.R.PdfInstantPreview {
    constructor() {
        super();
        this.hasPreview = false;
    }
    previewFirstPage(option) {
        return __awaiter(this, void 0, void 0, function* () {
            yield option.analyzer.wait();
            let info = yield option.analyzer.getPageImage(1);
            let item = new PreviewListItem({
                pageNum: 1,
                imageSrc: info.url,
                matches: [],
                width: info.width,
                height: info.height,
                scale: info.scale,
            });
            this.previewList.push(item);
        });
    }
    clearHint() {
        this.VM.hint = "";
    }
    preview(option) {
        return __awaiter(this, void 0, void 0, function* () {
            this.clearHint();
            yield option.analyzer.wait();
            let keywords = option.keywords.trim();
            if (keywords.length == 0) {
                return false;
            }
            let result = yield option.analyzer.search(keywords);
            let pages = {};
            this.previewList.empty();
            if (result.length == 0) {
                this.VM.hint = `${option.title}"${keywords}" `;
                return false;
            }
            for (let item of result) {
                let matches = pages[item.pageNum];
                if (!matches) {
                    matches = [];
                    pages[item.pageNum] = matches;
                }
                matches.push(item);
            }
            for (let pageNum in pages) {
                let info = yield option.analyzer.getPageImage(+pageNum);
                let item = new PreviewListItem({
                    pageNum: +pageNum,
                    imageSrc: info.url,
                    width: info.width,
                    height: info.height,
                    matches: pages[pageNum],
                    scale: info.scale,
                });
                this.previewList.push(item);
            }
            this.hasPreview = true;
            return true;
        });
    }
}
exports.PdfInstantPreview = PdfInstantPreview;
class PreviewListItem extends pdfInstantPreview_html_R_1.R.PdfInstantPreview.PreviewListItem {
    constructor(option) {
        super();
        this.option = option;
        this.canvas = document.createElement("canvas");
        let canvas = this.canvas;
        canvas.width = option.width;
        canvas.height = option.height;
        this.UI.previewImage.src = option.imageSrc;
        if (this.UI.previewImage.complete) {
            this.setupCanvas();
        }
        else {
            this.UI.previewImage.onload = () => {
                this.setupCanvas();
            };
        }
    }
    setupCanvas() {
        this.UI.previewImage.style.display = "none";
        this.node.appendChild(this.canvas);
        let context = this.canvas.getContext("2d");
        context.drawImage(this.UI.previewImage, 0, 0);
        context.strokeStyle = "red";
        console.error(this.option.matches);
        let scale = this.option.scale;
        let height = this.option.height;
        console.error(height, "Setup canvas");
        for (let match of this.option.matches) {
            for (let box of match.boundingBoxes) {
                context.beginPath();
                console.error(height, box.y, match);
                context.moveTo(box.x * scale, height - box.y * scale);
                context.lineTo((box.x + box.width) * scale, height - box.y * scale);
                context.closePath();
                context.stroke();
            }
        }
    }
}
exports.PreviewListItem = PreviewListItem;


/***/ }),

/***/ "./src/script/ttjh/previewFeature.js":
/*!*******************************************!*\
  !*** ./src/script/ttjh/previewFeature.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaginatorEnhancement = exports.FormEnhancement = exports.DatasetItemEnhancement = exports.DatasetListEnhancement = exports.PreviewButtonEnhancement = exports.SearchBoxEnhancement = exports.PreviewFeature = void 0;
const elementEnhancement_1 = __webpack_require__(/*! ../elementEnhancement */ "./src/script/elementEnhancement.js");
const pdfAnalyzer_1 = __webpack_require__(/*! ../pdf/pdfAnalyzer */ "./src/script/pdf/pdfAnalyzer.js");
const pdfInstantPreview_1 = __webpack_require__(/*! ./pdfInstantPreview */ "./src/script/ttjh/pdfInstantPreview.js");
const util_1 = __webpack_require__(/*! ./util */ "./src/script/ttjh/util.js");
class PreviewFeature {
    constructor() {
        this.splitterReg = new RegExp("[:]");
        this.splitter = ":";
        this.previewButtonEnhancement = new PreviewButtonEnhancement(this);
        this.datalistEnhancement = new DatasetListEnhancement(this);
        this.formEnhancement = new FormEnhancement(this);
        this.searchBoxEnhancement = new SearchBoxEnhancement(this);
        this.paginatorEnhancement = new PaginatorEnhancement(this);
    }
    parseFullKeyword(content) {
        let parts = content.split(this.splitterReg);
        if (parts.length == 1)
            return { base: content, inline: "" };
        return {
            base: parts[0],
            inline: parts.slice(1).join(":")
        };
    }
    genFullKeyword(option) {
        var _a;
        let base = (_a = option.base) === null || _a === void 0 ? void 0 : _a.replace(/\+/ig, " ");
        if (!option.inline)
            return base;
        return base + this.splitter + option.inline;
    }
    get baseSearchKeywords() {
        let info = this.parseFullKeyword(this.searchBoxEnhancement.el.value);
        return info.base;
    }
    set baseSearchKeywords(value) {
        let info = this.parseFullKeyword(this.searchBoxEnhancement.el.value);
        info.base = value;
        this.searchBoxEnhancement.el.value = this.genFullKeyword(info);
    }
    get inlineSearchKeywords() {
        let info = this.parseFullKeyword(this.searchBoxEnhancement.el.value);
        return info.inline;
    }
    set inlineSearchKeywords(value) {
        let info = this.parseFullKeyword(this.searchBoxEnhancement.el.value);
        info.inline = value;
        this.searchBoxEnhancement.el.value = this.genFullKeyword(info);
    }
    enhance() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.previewButtonEnhancement.enhance();
            yield this.formEnhancement.enhance();
            if (window.location.hash.startsWith("#inline=")) {
                yield this.datalistEnhancement.enhance();
                yield this.paginatorEnhancement.enhance();
            }
        });
    }
}
exports.PreviewFeature = PreviewFeature;
class SearchBoxEnhancement extends elementEnhancement_1.ElementEnhancement {
    constructor(preview) {
        super({
            selector: "#field-giant-search"
        });
        this.preview = preview;
    }
}
exports.SearchBoxEnhancement = SearchBoxEnhancement;
class PreviewButtonEnhancement extends elementEnhancement_1.ElementEnhancement {
    constructor(preview) {
        let selector = "#dataset-search-form > div.input-group.search-input-group > .input-group-btn";
        super({
            selector
        });
        this.preview = preview;
        this.previewButton = null;
        this.events = new Leaf.EventEmitter();
    }
    enhance() {
        //this.ensurePreviewButton()
    }
    ensurePreviewButton() {
        if (this.previewButton)
            return;
        let button = document.createElement("button");
        button.classList.add("btn", "btn-default", "btn-lg");
        button.textContent = "";
        this.previewButton = button;
        this.el.prepend(button);
        this.previewButton.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopImmediatePropagation();
            this.onClickPreviewButton();
        });
    }
    onClickPreviewButton() {
        return __awaiter(this, void 0, void 0, function* () {
            this.events.emit("trigger");
        });
    }
}
exports.PreviewButtonEnhancement = PreviewButtonEnhancement;
class DatasetListEnhancement extends elementEnhancement_1.ElementEnhancement {
    constructor(preview) {
        const selector = ".dataset-list";
        super({
            selector
        });
        this.preview = preview;
        this.datasetListItemEnhancements = null;
        this.define({ name: "items", selector: ".dataset-item" });
    }
    enhance() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = this.preview.inlineSearchKeywords) === null || _a === void 0 ? void 0 : _a.trim())) {
                return;
            }
            this.ensureEnhancements();
            yield Promise.all(this.datasetListItemEnhancements.map(item => item.enhance()));
        });
    }
    ensureEnhancements() {
        if (this.datasetListItemEnhancements)
            return;
        this.datasetListItemEnhancements = this.gets("items").map(el => {
            return new DatasetItemEnhancement(this, el);
        });
    }
}
exports.DatasetListEnhancement = DatasetListEnhancement;
class DatasetItemEnhancement extends elementEnhancement_1.ElementEnhancement {
    constructor(list, el) {
        super({
            el
        });
        this.list = list;
        this.previewContainer = null;
        this.define({
            name: "resources", selector: ".dataset-resources li a",
        }).define({
            name: "meta", selector: ".dataset-meta"
        }).define({
            name: "url", selector: "a"
        }).define({
            name: "title",
            selector: ".dataset-heading a"
        });
        this.ensurePreviewSection();
    }
    get url() {
        return this.get("url").getAttribute("href");
    }
    enhance() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let formats = this.gets("resources").map(el => {
                return el.getAttribute("data-format");
            });
            let title = (_a = this.get("title")) === null || _a === void 0 ? void 0 : _a.textContent;
            console.error("Titlte enc", title);
            this.ensurePreviewSection();
            if (!formats.includes("pdf")) {
                let text = document.createElement("div");
                text.classList.add("ttj-not-supported");
                text.textContent = `PDF`;
                this.previewContainer.appendChild(text);
                return;
            }
            let openDataCatelogUtil = new util_1.OpenDataCatelogUtil();
            let url = this.url;
            let docs = yield openDataCatelogUtil.getOpenDataEntryDocuments(url);
            let pdfs = docs.filter(doc => doc.type == "pdf");
            let hint = document.createElement("div");
            this.previewContainer.appendChild(hint);
            pdfs.reverse();
            let all = [];
            let previews = [];
            for (let [index, doc] of pdfs.entries()) {
                hint.textContent = `${index + 1}/${pdfs.length}...`;
                let pdfPreview = new pdfInstantPreview_1.PdfInstantPreview();
                let binary = yield openDataCatelogUtil.getResourceBinaryViaProxy(doc.url);
                let title = doc.title;
                this.previewContainer.prepend(pdfPreview.node);
                let analyzer = new pdfAnalyzer_1.PdfAnalyzer();
                analyzer.load(binary);
                all.push(pdfPreview.preview({ title, analyzer, keywords: this.list.preview.inlineSearchKeywords }));
                previews.push(pdfPreview);
            }
            yield Promise.all(all);
            if (previews.find(item => item.hasPreview)) {
                hint.parentElement.removeChild(hint);
                for (let preview of previews) {
                    if (!preview.hasPreview) {
                        preview.node.parentElement.removeChild(preview.node);
                    }
                }
            }
            else {
                for (let preview of previews) {
                    preview.node.parentElement.removeChild(preview.node);
                }
                hint.textContent = `"${this.list.preview.inlineSearchKeywords}" `;
                hint.style.color = "red";
            }
        });
    }
    ensurePreviewSection() {
        if (this.previewContainer) {
            this.previewContainer.innerHTML = "";
            return;
        }
        let previewContainer = document.createElement("dd");
        previewContainer.classList.add("dataset-meta-item");
        let title = document.createElement("dt");
        title.classList.add("dataset-meta-item", "dataset-meta-item-title");
        title.textContent = "";
        let meta = this.get("meta");
        meta.appendChild(title);
        meta.appendChild(previewContainer);
        this.previewContainer = previewContainer;
    }
}
exports.DatasetItemEnhancement = DatasetItemEnhancement;
class FormEnhancement extends elementEnhancement_1.ElementEnhancement {
    constructor(preview) {
        super({
            selector: "#dataset-search-form"
        });
        this.preview = preview;
    }
    enhance() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let hash = (_a = window.location.hash) === null || _a === void 0 ? void 0 : _a.replace("#", "");
            hash.split("&").forEach(item => {
                let [k, v] = item.split("=");
                if (k == "inline") {
                    this.preview.inlineSearchKeywords = decodeURIComponent(v);
                }
            });
            console.error(hash, "enh??");
            this.el.addEventListener("submit", (e) => {
                console.error("submit???");
                let currentUrl = new URL(window.location.toString());
                e.preventDefault(); // Prevent the original form submission
                const form = e.target;
                let url = new URL(form.action);
                let q = this.preview.baseSearchKeywords.split(/\s+/).filter(Boolean).join("+");
                url.searchParams.set("q", q);
                // Modify the URL or add a hash
                url.hash = `#inline=${encodeURIComponent(this.preview.inlineSearchKeywords)}`;
                window.location.href = url.toString();
                if (currentUrl.searchParams.get("q") == q) {
                    window.location.reload();
                }
            });
        });
    }
}
exports.FormEnhancement = FormEnhancement;
class PaginatorEnhancement extends elementEnhancement_1.ElementEnhancement {
    constructor(preview) {
        let selector = "#content > div.row.wrapper > div  div.pagination-wrapper > ul";
        super({ selector });
        this.preview = preview;
        this.define({ name: "pageItem", selector: "li a" });
    }
    enhance() {
        var _a;
        let hash = (_a = window.location.hash) === null || _a === void 0 ? void 0 : _a.replace("#", "");
        this.gets("pageItem").map(item => {
            let url = new URL(item.getAttribute("href"), window.location.toString());
            url.hash = hash;
            item.setAttribute("href", url.toString());
        });
    }
}
exports.PaginatorEnhancement = PaginatorEnhancement;


/***/ }),

/***/ "./src/script/ttjh/stylingFeature.js":
/*!*******************************************!*\
  !*** ./src/script/ttjh/stylingFeature.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StylingFeature = void 0;
class StylingFeature {
    enhance() {
        document.body.classList.add("ttjh-enhanced");
    }
}
exports.StylingFeature = StylingFeature;


/***/ }),

/***/ "./src/script/ttjh/util.js":
/*!*********************************!*\
  !*** ./src/script/ttjh/util.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpenDataCatelogUtil = void 0;
class OpenDataCatelogUtil {
    getOpenDataEntryDocuments(url) {
        return __awaiter(this, void 0, void 0, function* () {
            let content = yield this.getHTML(url);
            const parser = new DOMParser();
            let parsed = parser.parseFromString(content, "text/html");
            let resourceSelector = "#dataset-resources > ul > li > a";
            let els = Array.from(parsed.querySelectorAll(resourceSelector));
            let results = els.map(el => {
                var _a;
                let title = el.getAttribute("title");
                let label = el.querySelector(`[property="dc:format"]`);
                let url = el.getAttribute("href");
                if (!label)
                    return null;
                return {
                    title,
                    url,
                    type: (_a = label === null || label === void 0 ? void 0 : label.getAttribute("data-format")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()
                };
            }).filter(Boolean);
            return results;
        });
    }
    getHTML(url) {
        return __awaiter(this, void 0, void 0, function* () {
            console.error("Load html of", url);
            let res = yield fetch(url);
            return res.text();
        });
    }
    getResourceBinaryViaProxy(url) {
        return __awaiter(this, void 0, void 0, function* () {
            url = url + "/proxy";
            console.error("Load resource of", url);
            let res = yield fetch(url);
            return res.arrayBuffer();
        });
    }
}
exports.OpenDataCatelogUtil = OpenDataCatelogUtil;


/***/ }),

/***/ "?4a14":
/*!************************!*\
  !*** canvas (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?fe90":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?d446":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4c38":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?9f5f":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?afbb":
/*!**********************!*\
  !*** zlib (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/nanoid/index.browser.js":
/*!**********************************************!*\
  !*** ./node_modules/nanoid/index.browser.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),
/* harmony export */   customRandom: () => (/* binding */ customRandom),
/* harmony export */   nanoid: () => (/* binding */ nanoid),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   urlAlphabet: () => (/* reexport safe */ _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__.urlAlphabet)
/* harmony export */ });
/* harmony import */ var _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url-alphabet/index.js */ "./node_modules/nanoid/url-alphabet/index.js");

let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
let customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  let step = -~((1.6 * mask * defaultSize) / alphabet.length)
  return (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let j = step
      while (j--) {
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size = 21) =>
  customRandom(alphabet, size, random)
let nanoid = (size = 21) =>
  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    byte &= 63
    if (byte < 36) {
      id += byte.toString(36)
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte > 62) {
      id += '-'
    } else {
      id += '_'
    }
    return id
  }, '')



/***/ }),

/***/ "./node_modules/nanoid/url-alphabet/index.js":
/*!***************************************************!*\
  !*** ./node_modules/nanoid/url-alphabet/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   urlAlphabet: () => (/* binding */ urlAlphabet)
/* harmony export */ });
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/script/entry/openDataCatelogSite.js");
/******/ 	
/******/ })()
;